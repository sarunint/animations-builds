{"version":3,"sources":["../../../packages/animations/esm5/src/players/animation_player.js","../../../packages/animations/esm5/src/players/animation_group_player.js"],"names":["NoopAnimationPlayer","duration","delay","this","_onDoneFns","_onStartFns","_onDestroyFns","_started","totalTime","prototype","_onFinish","_finished","fn","push","play","hasStarted","triggerMicrotask","scheduleMicroTask","_this","_onStart","destroy","_destroyed","triggerCallback","phaseName","methods","AnimationGroupPlayer","_players","destroyCount","startCount","total","players","length","forEach","player","onDone","doneCount","onDestroy","_onDestroy","onStart","reduce","time","Math","max","init","parentPlayer","finish","reset","p","timeAtPosition","getPosition","min","beforeDestroy"],"mappings":";;;;;;;;;;;;;;;;;;;;sFAoJ8B,oBACjBA,oBAAmBC,SAAAC,YACR,IAAZD,WAAkBA,SAAA,QACjB,IAADC,QAAoBA,MAAA,GACxBC,KAAKC,cACLD,KAAKE,eACLF,KAAKG,iBACRH,KAAAI,UAAA,8DAIDJ,KAAAK,UAAoBP,SAAUC,iCAKjBO,UAAiBC,qBAI5BP,KAAAQ,4IAcF,SAAAC,IAAAT,KAAoBE,YAAUQ,KAAMD,0CASpC,SAAAA,IAAAT,KAAoBC,WAAUS,KAAAD,qOA2BjBH,UAAWK,gBAItBX,KAAAY,8FAWkBN,UAACO,2CAMrBC,kBAAoB,WAAU,OAAQC,MAAAR,mCAKlBD,UAAMU,wEAK1BhB,KAAAE,0MA0BaI,UAAiBW,mBAItBjB,KAAKkB,aACLlB,KAAKkB,YAAa,EACblB,KAAAY,cACRZ,KAAAgB,2IAaL,2IAuBAnB,oBAAmBS,UAAEa,yBAKnBC,WAEF,IAAAC,QAAA,SAAAD,UAAApB,KAAAE,YAAAF,KAAAC,4FAjL0B,wBCnHC,oBAClBqB,qBAAiBC,UACtB,IAAIR,MAACf,KACLA,KAAKC,cACLD,KAAKE,eACLF,KAAKQ,WAAY,EACjBR,KAAKI,UAAU,qBAEfJ,KAAIG,wCAEJH,KAAIK,UAAY,wCAKZmB,aAAY,EAEfC,WAAA,EAEGC,MAAK1B,KAAQ2B,QAAQC,OACjB,2BACU,WAAkB,OAAEb,MAAAR,mBAG7BoB,QAAEE,QAAA,SAAAC,QACHA,OAAOC,OAAA,aACGC,WAAYN,OACdX,MAAMR,cAGduB,OAAOG,UAAQ,aACLT,cAAcE,OAChBX,MAAMmB,eAGfJ,OAAAK,QAAA,aACNV,YAAAC,OACaX,MAAQC,eAK1BhB,KAAAK,UAAqBL,KAAA2B,QAAUS,OAAS,SAAAC,KAAAP,QAAA,OAAAQ,KAAAC,IAAAF,KAAAP,OAAAzB,YAAA,+BAK3BC,UAAiBC,qBAI5BP,KAAAQ,0IAYF,WAAAR,KAAA2B,QAAqBE,QAAU,SAAOC,QAAA,OAAAA,OAAAU,8GAajBlC,UAAQU,oBAI3BhB,KAAAY,gJAcF,SAAAH,IAAAT,KAAqBC,WAAUS,KAAAD,wLAoBXH,UAAAK,gBAIlBX,KAAAyC,0CAIFzC,KAAA2B,QAAAE,QAAqB,SAAUC,QAAK,OAAAA,OAAAnB,iQAmBnBL,UAAQoC,mCAKzB1C,KAAA2B,QAAAE,QAAqB,SAAUC,QAAO,OAAAA,OAAAY,sGAYzBpC,UAAkB4B,sBAIvBlC,KAAKkB,aACRlB,KAAAkB,YAAA,EACHlB,KAAAO,+KASiBD,UAASqC,0LAiBpBC,OAEDC,eAAAD,EAAA5C,KAAAK,UACLL,KAAA2B,QAAAE,QAAA,SAAAC,yIAScxB,UAAAwC,2BAKTC,IAAA,EAMP,OALI/C,KAAA2B,QAAWE,QAAA,SAAAC,yDAKfiB,0BAKmBzC,UAAA0C,yBAIjBhD,KAAA2B,QAAAE,QAAA,SAAAC,wDAYFR,qBAAqBhB,UAAAa,yBAKnBC,WAEF,IAAAC,QAAA,SAAAD,UAAApB,KAAAE,YAAAF,KAAAC,6FAjP2B","file":"/mnt/c/Users/Sarun/dev/angular/dist/packages-dist/animations/bundles/animations.umd.min.js.map","sourcesContent":["/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nimport { scheduleMicroTask } from '../util';\n/**\n * Provides programmatic control of a reusable animation sequence,\n * built using the `build()` method of `AnimationBuilder`. The `build()` method\n * returns a factory, whose `create()` method instantiates and initializes this interface.\n *\n * @see `AnimationBuilder`\n * @see `AnimationFactory`\n * @see `animate()`\n *\n * \\@publicApi\n * @record\n */\nexport function AnimationPlayer() { }\n/**\n * Provides a callback to invoke when the animation finishes.\n * \\@param fn The callback function.\n * @see `finish()`\n * @type {?}\n */\nAnimationPlayer.prototype.onDone;\n/**\n * Provides a callback to invoke when the animation starts.\n * \\@param fn The callback function.\n * @see `run()`\n * @type {?}\n */\nAnimationPlayer.prototype.onStart;\n/**\n * Provides a callback to invoke after the animation is destroyed.\n * \\@param fn The callback function.\n * @see `destroy()`\n * @see `beforeDestroy()`\n * @type {?}\n */\nAnimationPlayer.prototype.onDestroy;\n/**\n * Initializes the animation.\n * @type {?}\n */\nAnimationPlayer.prototype.init;\n/**\n * Reports whether the animation has started.\n * \\@return True if the animation has started, false otherwise.\n * @type {?}\n */\nAnimationPlayer.prototype.hasStarted;\n/**\n * Runs the animation, invoking the `onStart()` callback.\n * @type {?}\n */\nAnimationPlayer.prototype.play;\n/**\n * Pauses the animation.\n * @type {?}\n */\nAnimationPlayer.prototype.pause;\n/**\n * Restarts the paused animation.\n * @type {?}\n */\nAnimationPlayer.prototype.restart;\n/**\n * Ends the animation, invoking the `onDone()` callback.\n * @type {?}\n */\nAnimationPlayer.prototype.finish;\n/**\n * Destroys the animation, after invoking the `beforeDestroy()` callback.\n * Calls the `onDestroy()` callback when destruction is completed.\n * @type {?}\n */\nAnimationPlayer.prototype.destroy;\n/**\n * Resets the animation to its initial state.\n * @type {?}\n */\nAnimationPlayer.prototype.reset;\n/**\n * Sets the position of the animation.\n * \\@param position A 0-based offset into the duration, in milliseconds.\n * @type {?}\n */\nAnimationPlayer.prototype.setPosition;\n/**\n * Reports the current position of the animation.\n * \\@return A 0-based offset into the duration, in milliseconds.\n * @type {?}\n */\nAnimationPlayer.prototype.getPosition;\n/**\n * The parent of this player, if any.\n * @type {?}\n */\nAnimationPlayer.prototype.parentPlayer;\n/**\n * The total run time of the animation, in milliseconds.\n * @type {?}\n */\nAnimationPlayer.prototype.totalTime;\n/**\n * Provides a callback to invoke before the animation is destroyed.\n * @type {?|undefined}\n */\nAnimationPlayer.prototype.beforeDestroy;\n/**\n * \\@internal\n * Internal\n * @type {?|undefined}\n */\nAnimationPlayer.prototype.triggerCallback;\n/**\n * \\@internal\n * Internal\n * @type {?|undefined}\n */\nAnimationPlayer.prototype.disabled;\n/**\n * An empty programmatic controller for reusable animations.\n * Used internally when animations are disabled, to avoid\n * checking for the null case when an animation player is expected.\n *\n * @see `animate()`\n * @see `AnimationPlayer`\n * @see `GroupPlayer`\n *\n * \\@publicApi\n */\nvar /**\n * An empty programmatic controller for reusable animations.\n * Used internally when animations are disabled, to avoid\n * checking for the null case when an animation player is expected.\n *\n * @see `animate()`\n * @see `AnimationPlayer`\n * @see `GroupPlayer`\n *\n * \\@publicApi\n */\nNoopAnimationPlayer = /** @class */ (function () {\n    function NoopAnimationPlayer(duration, delay) {\n        if (duration === void 0) { duration = 0; }\n        if (delay === void 0) { delay = 0; }\n        this._onDoneFns = [];\n        this._onStartFns = [];\n        this._onDestroyFns = [];\n        this._started = false;\n        this._destroyed = false;\n        this._finished = false;\n        this.parentPlayer = null;\n        this.totalTime = duration + delay;\n    }\n    /**\n     * @return {?}\n     */\n    NoopAnimationPlayer.prototype._onFinish = /**\n     * @return {?}\n     */\n    function () {\n        if (!this._finished) {\n            this._finished = true;\n            this._onDoneFns.forEach(function (fn) { return fn(); });\n            this._onDoneFns = [];\n        }\n    };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    NoopAnimationPlayer.prototype.onStart = /**\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) { this._onStartFns.push(fn); };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    NoopAnimationPlayer.prototype.onDone = /**\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) { this._onDoneFns.push(fn); };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    NoopAnimationPlayer.prototype.onDestroy = /**\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) { this._onDestroyFns.push(fn); };\n    /**\n     * @return {?}\n     */\n    NoopAnimationPlayer.prototype.hasStarted = /**\n     * @return {?}\n     */\n    function () { return this._started; };\n    /**\n     * @return {?}\n     */\n    NoopAnimationPlayer.prototype.init = /**\n     * @return {?}\n     */\n    function () { };\n    /**\n     * @return {?}\n     */\n    NoopAnimationPlayer.prototype.play = /**\n     * @return {?}\n     */\n    function () {\n        if (!this.hasStarted()) {\n            this._onStart();\n            this.triggerMicrotask();\n        }\n        this._started = true;\n    };\n    /** @internal */\n    /**\n     * \\@internal\n     * @return {?}\n     */\n    NoopAnimationPlayer.prototype.triggerMicrotask = /**\n     * \\@internal\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        scheduleMicroTask(function () { return _this._onFinish(); });\n    };\n    /**\n     * @return {?}\n     */\n    NoopAnimationPlayer.prototype._onStart = /**\n     * @return {?}\n     */\n    function () {\n        this._onStartFns.forEach(function (fn) { return fn(); });\n        this._onStartFns = [];\n    };\n    /**\n     * @return {?}\n     */\n    NoopAnimationPlayer.prototype.pause = /**\n     * @return {?}\n     */\n    function () { };\n    /**\n     * @return {?}\n     */\n    NoopAnimationPlayer.prototype.restart = /**\n     * @return {?}\n     */\n    function () { };\n    /**\n     * @return {?}\n     */\n    NoopAnimationPlayer.prototype.finish = /**\n     * @return {?}\n     */\n    function () { this._onFinish(); };\n    /**\n     * @return {?}\n     */\n    NoopAnimationPlayer.prototype.destroy = /**\n     * @return {?}\n     */\n    function () {\n        if (!this._destroyed) {\n            this._destroyed = true;\n            if (!this.hasStarted()) {\n                this._onStart();\n            }\n            this.finish();\n            this._onDestroyFns.forEach(function (fn) { return fn(); });\n            this._onDestroyFns = [];\n        }\n    };\n    /**\n     * @return {?}\n     */\n    NoopAnimationPlayer.prototype.reset = /**\n     * @return {?}\n     */\n    function () { };\n    /**\n     * @param {?} position\n     * @return {?}\n     */\n    NoopAnimationPlayer.prototype.setPosition = /**\n     * @param {?} position\n     * @return {?}\n     */\n    function (position) { };\n    /**\n     * @return {?}\n     */\n    NoopAnimationPlayer.prototype.getPosition = /**\n     * @return {?}\n     */\n    function () { return 0; };\n    /** @internal */\n    /**\n     * \\@internal\n     * @param {?} phaseName\n     * @return {?}\n     */\n    NoopAnimationPlayer.prototype.triggerCallback = /**\n     * \\@internal\n     * @param {?} phaseName\n     * @return {?}\n     */\n    function (phaseName) {\n        /** @type {?} */\n        var methods = phaseName == 'start' ? this._onStartFns : this._onDoneFns;\n        methods.forEach(function (fn) { return fn(); });\n        methods.length = 0;\n    };\n    return NoopAnimationPlayer;\n}());\n/**\n * An empty programmatic controller for reusable animations.\n * Used internally when animations are disabled, to avoid\n * checking for the null case when an animation player is expected.\n *\n * @see `animate()`\n * @see `AnimationPlayer`\n * @see `GroupPlayer`\n *\n * \\@publicApi\n */\nexport { NoopAnimationPlayer };\nif (false) {\n    /** @type {?} */\n    NoopAnimationPlayer.prototype._onDoneFns;\n    /** @type {?} */\n    NoopAnimationPlayer.prototype._onStartFns;\n    /** @type {?} */\n    NoopAnimationPlayer.prototype._onDestroyFns;\n    /** @type {?} */\n    NoopAnimationPlayer.prototype._started;\n    /** @type {?} */\n    NoopAnimationPlayer.prototype._destroyed;\n    /** @type {?} */\n    NoopAnimationPlayer.prototype._finished;\n    /** @type {?} */\n    NoopAnimationPlayer.prototype.parentPlayer;\n    /** @type {?} */\n    NoopAnimationPlayer.prototype.totalTime;\n}\n//# sourceMappingURL=animation_player.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { scheduleMicroTask } from '../util';\n/**\n * A programmatic controller for a group of reusable animations.\n * Used internally to control animations.\n *\n * @see `AnimationPlayer`\n * @see `{\\@link animations/group group()}`\n *\n */\nvar /**\n * A programmatic controller for a group of reusable animations.\n * Used internally to control animations.\n *\n * @see `AnimationPlayer`\n * @see `{\\@link animations/group group()}`\n *\n */\nAnimationGroupPlayer = /** @class */ (function () {\n    function AnimationGroupPlayer(_players) {\n        var _this = this;\n        this._onDoneFns = [];\n        this._onStartFns = [];\n        this._finished = false;\n        this._started = false;\n        this._destroyed = false;\n        this._onDestroyFns = [];\n        this.parentPlayer = null;\n        this.totalTime = 0;\n        this.players = _players;\n        /** @type {?} */\n        var doneCount = 0;\n        /** @type {?} */\n        var destroyCount = 0;\n        /** @type {?} */\n        var startCount = 0;\n        /** @type {?} */\n        var total = this.players.length;\n        if (total == 0) {\n            scheduleMicroTask(function () { return _this._onFinish(); });\n        }\n        else {\n            this.players.forEach(function (player) {\n                player.onDone(function () {\n                    if (++doneCount == total) {\n                        _this._onFinish();\n                    }\n                });\n                player.onDestroy(function () {\n                    if (++destroyCount == total) {\n                        _this._onDestroy();\n                    }\n                });\n                player.onStart(function () {\n                    if (++startCount == total) {\n                        _this._onStart();\n                    }\n                });\n            });\n        }\n        this.totalTime = this.players.reduce(function (time, player) { return Math.max(time, player.totalTime); }, 0);\n    }\n    /**\n     * @return {?}\n     */\n    AnimationGroupPlayer.prototype._onFinish = /**\n     * @return {?}\n     */\n    function () {\n        if (!this._finished) {\n            this._finished = true;\n            this._onDoneFns.forEach(function (fn) { return fn(); });\n            this._onDoneFns = [];\n        }\n    };\n    /**\n     * @return {?}\n     */\n    AnimationGroupPlayer.prototype.init = /**\n     * @return {?}\n     */\n    function () { this.players.forEach(function (player) { return player.init(); }); };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    AnimationGroupPlayer.prototype.onStart = /**\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) { this._onStartFns.push(fn); };\n    /**\n     * @return {?}\n     */\n    AnimationGroupPlayer.prototype._onStart = /**\n     * @return {?}\n     */\n    function () {\n        if (!this.hasStarted()) {\n            this._started = true;\n            this._onStartFns.forEach(function (fn) { return fn(); });\n            this._onStartFns = [];\n        }\n    };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    AnimationGroupPlayer.prototype.onDone = /**\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) { this._onDoneFns.push(fn); };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    AnimationGroupPlayer.prototype.onDestroy = /**\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) { this._onDestroyFns.push(fn); };\n    /**\n     * @return {?}\n     */\n    AnimationGroupPlayer.prototype.hasStarted = /**\n     * @return {?}\n     */\n    function () { return this._started; };\n    /**\n     * @return {?}\n     */\n    AnimationGroupPlayer.prototype.play = /**\n     * @return {?}\n     */\n    function () {\n        if (!this.parentPlayer) {\n            this.init();\n        }\n        this._onStart();\n        this.players.forEach(function (player) { return player.play(); });\n    };\n    /**\n     * @return {?}\n     */\n    AnimationGroupPlayer.prototype.pause = /**\n     * @return {?}\n     */\n    function () { this.players.forEach(function (player) { return player.pause(); }); };\n    /**\n     * @return {?}\n     */\n    AnimationGroupPlayer.prototype.restart = /**\n     * @return {?}\n     */\n    function () { this.players.forEach(function (player) { return player.restart(); }); };\n    /**\n     * @return {?}\n     */\n    AnimationGroupPlayer.prototype.finish = /**\n     * @return {?}\n     */\n    function () {\n        this._onFinish();\n        this.players.forEach(function (player) { return player.finish(); });\n    };\n    /**\n     * @return {?}\n     */\n    AnimationGroupPlayer.prototype.destroy = /**\n     * @return {?}\n     */\n    function () { this._onDestroy(); };\n    /**\n     * @return {?}\n     */\n    AnimationGroupPlayer.prototype._onDestroy = /**\n     * @return {?}\n     */\n    function () {\n        if (!this._destroyed) {\n            this._destroyed = true;\n            this._onFinish();\n            this.players.forEach(function (player) { return player.destroy(); });\n            this._onDestroyFns.forEach(function (fn) { return fn(); });\n            this._onDestroyFns = [];\n        }\n    };\n    /**\n     * @return {?}\n     */\n    AnimationGroupPlayer.prototype.reset = /**\n     * @return {?}\n     */\n    function () {\n        this.players.forEach(function (player) { return player.reset(); });\n        this._destroyed = false;\n        this._finished = false;\n        this._started = false;\n    };\n    /**\n     * @param {?} p\n     * @return {?}\n     */\n    AnimationGroupPlayer.prototype.setPosition = /**\n     * @param {?} p\n     * @return {?}\n     */\n    function (p) {\n        /** @type {?} */\n        var timeAtPosition = p * this.totalTime;\n        this.players.forEach(function (player) {\n            /** @type {?} */\n            var position = player.totalTime ? Math.min(1, timeAtPosition / player.totalTime) : 1;\n            player.setPosition(position);\n        });\n    };\n    /**\n     * @return {?}\n     */\n    AnimationGroupPlayer.prototype.getPosition = /**\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var min = 0;\n        this.players.forEach(function (player) {\n            /** @type {?} */\n            var p = player.getPosition();\n            min = Math.min(p, min);\n        });\n        return min;\n    };\n    /**\n     * @return {?}\n     */\n    AnimationGroupPlayer.prototype.beforeDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this.players.forEach(function (player) {\n            if (player.beforeDestroy) {\n                player.beforeDestroy();\n            }\n        });\n    };\n    /** @internal */\n    /**\n     * \\@internal\n     * @param {?} phaseName\n     * @return {?}\n     */\n    AnimationGroupPlayer.prototype.triggerCallback = /**\n     * \\@internal\n     * @param {?} phaseName\n     * @return {?}\n     */\n    function (phaseName) {\n        /** @type {?} */\n        var methods = phaseName == 'start' ? this._onStartFns : this._onDoneFns;\n        methods.forEach(function (fn) { return fn(); });\n        methods.length = 0;\n    };\n    return AnimationGroupPlayer;\n}());\n/**\n * A programmatic controller for a group of reusable animations.\n * Used internally to control animations.\n *\n * @see `AnimationPlayer`\n * @see `{\\@link animations/group group()}`\n *\n */\nexport { AnimationGroupPlayer };\nif (false) {\n    /** @type {?} */\n    AnimationGroupPlayer.prototype._onDoneFns;\n    /** @type {?} */\n    AnimationGroupPlayer.prototype._onStartFns;\n    /** @type {?} */\n    AnimationGroupPlayer.prototype._finished;\n    /** @type {?} */\n    AnimationGroupPlayer.prototype._started;\n    /** @type {?} */\n    AnimationGroupPlayer.prototype._destroyed;\n    /** @type {?} */\n    AnimationGroupPlayer.prototype._onDestroyFns;\n    /** @type {?} */\n    AnimationGroupPlayer.prototype.parentPlayer;\n    /** @type {?} */\n    AnimationGroupPlayer.prototype.totalTime;\n    /** @type {?} */\n    AnimationGroupPlayer.prototype.players;\n}\n//# sourceMappingURL=animation_group_player.js.map"]}