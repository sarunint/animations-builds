{"version":3,"sources":["../../../../node_modules/tslib/tslib.es6.js","../../../packages/animations/esm5/browser/src/render/shared.js","../../../packages/animations/esm5/browser/src/render/animation_driver.js","../../../packages/animations/esm5/browser/src/util.js","../../../packages/animations/esm5/browser/src/dsl/animation_transition_expr.js","../../../packages/animations/esm5/browser/src/dsl/animation_ast_builder.js","../../../packages/animations/esm5/browser/src/dsl/animation_timeline_instruction.js","../../../packages/animations/esm5/browser/src/dsl/element_instruction_map.js","../../../packages/animations/esm5/browser/src/dsl/animation_timeline_builder.js","../../../packages/animations/esm5/browser/src/dsl/style_normalization/web_animations_style_normalizer.js","../../../packages/animations/esm5/browser/src/dsl/animation.js","../../../packages/animations/esm5/browser/src/dsl/style_normalization/animation_style_normalizer.js","../../../packages/animations/esm5/browser/src/dsl/animation_transition_instruction.js","../../../packages/animations/esm5/browser/src/dsl/animation_transition_factory.js","../../../packages/animations/esm5/browser/src/dsl/animation_trigger.js","../../../packages/animations/esm5/browser/src/render/timeline_animation_engine.js","../../../packages/animations/esm5/browser/src/render/transition_animation_engine.js","../../../packages/animations/esm5/browser/src/render/animation_engine_next.js","../../../packages/animations/esm5/browser/src/render/css_keyframes/element_animation_style_handler.js","../../../packages/animations/esm5/browser/src/render/css_keyframes/css_keyframes_player.js","../../../packages/animations/esm5/browser/src/render/css_keyframes/direct_style_player.js","../../../packages/animations/esm5/browser/src/render/css_keyframes/css_keyframes_driver.js","../../../packages/animations/esm5/browser/src/render/web_animations/web_animations_player.js","../../../packages/animations/esm5/browser/src/render/web_animations/web_animations_driver.js"],"names":["exports","module","factory","require","extendStatics","d","b","__proto__","Array","p","hasOwnProperty","__","this","constructor","Object","create","prototype","assign","t","s","i","n","arguments","length","call","players","_angular_animations","NoopAnimationPlayer","preStyles","normalizedKeyframes","previousOffset","previousKeyframe","offset","kf","isSameOffset","normalizedKeyframe","keys","forEach","prop","normalizedProp","AUTO_STYLE","errors","normalizedValue","ÉµPRE_STYLE","postStyles","normalizer","normalizeStyleValue","push","listenOnPlayer","player","eventName","event","callback","onStart","copyAnimationEvent","onDone","disabled","makeAnimationEvent","e","element","triggerName","fromState","toState","phaseName","undefined","totalTime","data","getOrSetAsInMap","map","key","defaultValue","Map","get","set","value","separatorPos","command","indexOf","_matches","selector","_query","multi","isNode","Element","_isNode","matches","proto","fn_1","matchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","webkitMatchesSelector","apply","results","querySelectorAll","elm","querySelector","_IS_WEBKIT","_CACHED_BODY","document","body","getBodyNode","style","substring","containsVendorPrefix","charAt","toUpperCase","substr","result","invokeQuery","hypenatePropsObject","object","newObj","NoopAnimationDriver","matchesElement","containsElement","Injectable","delay","easing","previousPlayers","scrubberAccessRequested","duration","AnimationDriver","NG_ANIMATING_SELECTOR","resolveTimingValue","unit","ONE_SECOND","exp","match","_convertTimeValueToMS","parseFloat","delayMatch","Math","floor","easingVal","allowNegativeValues","containsErrors","startIndex","normalizeStyles","styles","normalizedStyles","isArray","copyStyles","destination","getStyleAttributeString","writeStyleAttribute","styleAttrValue","item","getPropertyValue","startsWith","camelProp","dashCaseToCamelCase","normalizeAnimationEntry","steps","PARAM_REGEX","RegExp","SUBSTITUTION_EXPR_START","extractStyleParams","params","val","toString","exec","original","replace","_","varName","localVal","iteratorToArray","iterator","arr","next","done","DASH_CASE_REGEXP","input","m","_i","balancePreviousStylesIntoKeyframes","keyframes","previousStyles","previousStyleProps","missingStyleProps_1","startingKeyframe_1","computeStyle","_loop_1","visitor","node","context","type","visitTrigger","visitState","visitTransition","visitSequence","visitGroup","visitAnimate","visitKeyframes","visitStyle","visitReference","visitAnimateChild","visitAnimateRef","visitQuery","transitionValue","expressions","split","str","eventStr","alias","parseAnimationAlias","separator","makeLambdaFromStates","parseInnerTransitionStr","lhs","rhs","LHS_MATCH_BOOLEAN","TRUE_BOOLEAN_VALUES","has","FALSE_BOOLEAN_VALUES","RHS_MATCH_BOOLEAN","lhsMatch","ANY_STATE","rhsMatch","buildAnimationAst","driver","metadata","AnimationAstBuilderVisitor","build","_resetContextStyleTimingState","depCount","states","transitions","name","def","stateDef_1","name_1","transition","_this","queryCount","styleAst","astParams","options","containsDynamicStyles","stylesObj_1","sub","params_1","missingSubs_1","add","size","missingSubsArr","values","join","animation","visitDslNode","matchers","parseTransitionExpr","expr","currentTime","furthestTime","step","innerAst","max","timingAst","timings","makeTimingAst","strValue","some","v","ast","dynamic","constructTimingAst","currentAnimateTimings","styleMetadata","isEmpty","newStyleData","styleMetadata_1","_styleAst","isEmptyStep","_makeStyleAst","styleTuple","styleData","isObject","styleMap","_validateStyleAst","endTime","startTime","tuple","_driver","validateStyleProperty","collectedStyles","updateCollectedStyle","collectedEntry","style$$1","offsetVal","obj","consumeOffset","totalKeyframesWithOffsets","keyframesOutOfRange","offsetsOutOfOrder","offsets","generatedOffset","animateDuration","limit","durationUpToThisFrame","parentSelector","_a","hasAmpersand","find","token","SELF_TOKEN","SELF_TOKEN_REGEX","normalizeSelector","includeSelf","currentQuerySelector","currentQuery","visitStagger","resolveTiming","currentTransition","normalizeAnimationOptions","copyObj","createTimelineInstruction","preStyleProps","postStyleProps","subTimeline","instructions","_map","delete","ElementInstructionMap","append","existingInstructions","clear","buildAnimationTimelines","rootElement","enterClassName","leaveClassName","startingStyles","finalStyles","subInstructions","AnimationTimelineContext","timelines","filter","timeline","containsAnimation","tl","allowOnlyTimelineStyles","setStyles","AnimationTimelineBuilderVisitor","elementInstructions","consume","innerContext","createSubContext","_visitSubInstructions","instruction","instructionTimings","appendInstructionToTimeline","subContextCount","ctx","previousNode","currentTimeline","snapshotCurrentStyles","DEFAULT_NOOP_PREVIOUS_NODE","applyStylesToKeyframe","innerTimelines","delayNextStep","_visitTiming","interpolateParams","incrementTime","getCurrentStyleProperties","forwardFrame","applyEmptyStep","innerTimeline","mergeTimelineCollectedStyles","elms","originalSelector","optional","sameElementTimeline","currentQueryIndex","currentQueryTotal","transformIntoNewTimeline","maxTime","parentContext","currentStaggerTime","startingTime","_enterClassName","_leaveClassName","initialTimeline","defineProperty","updateOptions","skipIfExists","newOptions","optionsToUpdate","paramsToUpdate_1","newParams","_copyOptions","oldParams_1","newTime","target","fork","ENTER_TOKEN_REGEX","LEAVE_TOKEN_REGEX","elements","query","slice","TimelineBuilder","_elementTimelineStylesLookup","_previousKeyframe","_currentKeyframe","_keyframes","_styleSummary","_pendingStyles","_backFill","_currentEmptyStepKeyframe","_localTimelineStyles","_globalTimelineStyles","_loadKeyframe","hasPreStyleStep","forwardTime","_updateStyle","time","allStyles","allProperties","flattenStyles","props","getFinalKeyframe","properties","details0","details1","buildKeyframes","Set","keyframe","finalKeyframe","finalKeyframes","kf0","kf1","tslib_1.__extends","preProps","postProps","_super","SubTimelineBuilder","_stretchStartingKeyframe","newFirstKeyframe","oldFirstKeyframe","timeAtKeyframe","roundOffset","newKeyframes","decimalPoints","Animation","start","dest","destinationStyles","_animationAst","errorMessage","Error","NoopAnimationStyleNormalizer","normalizePropertyName","WebAnimationsStyleNormalizer","userProvidedProperty","normalizedProperty","trim","valAndSuffixMatch","strVal","createTransitionInstruction","isRemovalTransition","fromStyles","toStyles","queriedElements","matchFns","currentState","nextState","fn","backupStateStyler","_stateStyles","animationOptions","__assign","transitionAnimationParams","nextAnimationParams","skipAstBuild","currentStateStyles","nextStateStyles","preStyleMap","postStyleMap","AnimationStateStyles","buildStyles","defaultParams","styleObj_1","combinedParams","AnimationTrigger","transitionFactories","balanceProperties","AnimationTransitionFactory","key1","key2","TimelineAnimationEngine","bodyNode","_normalizer","register","id","_animations","EMPTY_INSTRUCTION_MAP","inst","autoStylesMap","optimizeGroupPlayer","_buildPlayer","_getPlayer","destroy","_playersById","args","play","pause","reset","restart","finish","init","setPosition","EMPTY_PLAYER_ARRAY","NULL_REMOVAL_STATE","namespaceId","setForMove","hasAnimation","removedBeforeQueried","NULL_REMOVED_QUERIED_STATE","REMOVAL_FLAG","isObj","normalizeTriggerValue","StateValue","AnimationTransitionNamespace","hostElement","_engine","_triggers","phase","listeners","_elementListeners","triggersWithStates","statesByElement","afterFlush","index","splice","trigger","_getTrigger","TransitionAnimationPlayer","addClass","absorbOptions","queued","matchTransition","isFallbackTransition","defaultToFallback","fallbackTransition","totalQueuedPlayers","_queue","removeClass","playersByElement","index_1","a","k1","k2","fromStyles_1","matchStyles","toStyles_1","reportError","eraseStyles","deregister","clearElementCache","elementPlayers","namespaces","fetchNamespacesByElement","ns","triggerLeaveAnimation","triggerStates","players_1","markElementAsRemoved","destroyAfterComplete","processLeaveNode","prepareLeaveAnimationListeners","listener","DEFAULT_STATE_VALUE","removeNode","engine","childElementCount","currentPlayers","playersByQueriedElement","containsPotentialParentTransition","parent_1","parentNode","insertNode","parent","_hostClassName","drainQueuedTransitions","destroyed","entry","baseEvent","microtaskId","markedForDestroy","sort","d0","d1","containsData","TransitionAnimationEngine","newHostElements","disabledNodes","totalAnimations","_namespaceLookup","_namespaceList","_flushFns","_whenQuietFns","onRemovalComplete","createNamespace","_balanceNamespaceList","nextNamespace","found","_fetchNamespace","namespacesByHostElement","elementStates","nsId","insertBefore","isElementNode","details","setForRemoval","markElementAsDisabled","_onRemovalComplete","collectedLeaveElements","destroyInnerAnimations","containerElement","NG_TRIGGER_SELECTOR","destroyActiveAnimationsForElement","whenRenderingDone","Promise","resolve","flush","collectedEnterElements","cleanupFns","_flushAnimations","quietFns_1","allPreStyleElements","disabledElementsSet","i_1","nodesThatAreDisabled","enterNodeMap","buildRootMap","allTriggerElements","enterNodeMapIds","nodes","root","className","allLeaveNodes","mergedLeaveNodes","leaveNodesWithoutAnimations","i_2","leaveNodeMapIds","leaveNodeMap","from","allPlayers","i_3","nodeIsOrphaned","skippedPlayers","stretchStartingKeyframe","subTimelines","stringMap","setVal_1","setVal","allPostStyleElements","errors_1","erroneousTransitions","allPreviousPlayersMap","_beforeAnimationBuild","_getPreviousPlayers","prevPlayer","replacePostStylesAsPre","cloakAndComputeStyles","postStylesMap","replaceNodes","post","pre","rootPlayers","NO_PARENT_ANIMATION_ELEMENT_DETECTED","onDestroy","overrideTotalTime","parentWithAnimation_1","animationElementMap","detectedParent","parentsToAdd","_buildAnimation","skippedPlayersMap","preStylesMap","parentPlayers","parentPlayer","subPlayers","playersForElement","syncPlayerEvents","i_4","queriedPlayerResults","j","queriedInnerElements","queriedPlayers","activePlayers","removeNodesAfterAnimationDone","elementContainsData","isQueriedElement","toStateValue","queriedElementPlayers","isRemovalAnimation_1","targetNameSpaceId","targetTriggerName","this_1","realPlayer","getRealPlayer","beforeDestroy","allSubElements","allNewPlayers","timelineInstruction","finalPlayers","ÉµAnimationGroupPlayer","_flattenGroupPlayersRecur","pp","normalizeKeyframes","wrappedPlayer","setRealPlayer","allQueriedPlayers","currentValues","deleteOrUnsetInMap","allConsumedElements","animate","_player","_containsRealPlayer","_queuedCallbacks","triggerCallback","_queueEvent","cloakElement","valuesMap","elementPropsMap","defaultStyle","cloakVals","roots","rootMap","localRootMap","getRoot","NULL_NODE","classList","classes","CLASSES_CACHE_KEY","remove","postEntry","preEntry","AnimationEngine","_triggerCache","_transitionEngine","componentId","cacheKey","disableAnimations","property","parseTimelineCommand","action","_timelineEngine","eventPhase","configurable","ANIMATION_PROP","ElementAnimationStyleHandler","_element","_name","_duration","_delay","_easing","_fillMode","_onDoneFn","_finished","_eventFn","_handleCallback","anim","getAnimationStyle","char","c","countChars","_startTime","Date","now","playPauseAnimation","position","setAnimationStyle","_position","timestamp","_ngTestManualTimestamp","elapsedTime","toFixed","addRemoveAnimationEvent","_destroyed","findMatchingTokenIndex","tokens","findIndexForAnimation","searchToken","oldValue","CssKeyframesPlayer","animationName","_finalStyles","_onDoneFns","_onStartFns","_onDestroyFns","_started","currentSnapshot","_state","_styler","_flushDoneFns","_flushStartFns","hasStarted","resume","_buildStyler","methods","finished_1","DirectStylePlayer","__initialized","_startingStyles","setProperty","removeProperty","CssKeyframesDriver","tab","keyframeStr","_notifyFaultyScrubber","previousCssKeyframePlayers","flatKeyframes","flattenKeyframesIntoStyles","_count","kfElm","buildKeyframeElement","appendChild","_warningIssued","console","warn","WebAnimationsPlayer","_initialized","_onFinish","_preparePlayerBeforeStart","domPlayer","addEventListener","_resetDomPlayerState","getPosition","_finalKeyframe","WebAnimationsDriver","_isNativeImpl","_cssKeyframesDriver","playerOptions","fill","previousWebAnimationPlayers","window","getElementAnimateFn"],"mappings":";;;;;0BAAA,iBAAAA,SAAA,oBAAAC,OAAAC,QAAAF,QAAAG,QAAA,uBAAAA,QAAA,wXAqBEC,cAAA,SAAAC,EAAAC,GAIE,6CAFYC,wBAAgBC,OAAA,SAAAH,EAAAC,GAAAD,EAAAE,UAAAD,IAC5B,SAAcD,EAAGC,GAAG,IAAA,IAAAG,KAAAH,EAAAA,EAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,MACCJ,EAAAC,4BAKrB,SAAQK,KAAGC,KAAOC,YAAUR,EADrBD,cAAWC,EAAAC,eAEE,OAANA,EAAaQ,OAAAC,OAAUT,IAASK,GAAIK,UAAOV,EAAAU,UAAA,IAAAL,iBAGpD,2BACMG,OAAEG,QAAA,SAAAC,GACZ,IAAA,IAAAC,EAAAC,EAAA,EAAAC,EAAAC,UAAAC,OAAAH,EAAAC,EAAAD,IAEJ,IAAA,IAAAX,KADUU,EAAAG,UAAeF,GACzBN,OAAAE,UAAAN,eAAAc,KAAAL,EAAAV,KAAAS,EAAAT,GAAAU,EAAAV;;;;;oFCZ4BgB,gBACrBA,QAAAF,aACI,EACP,OAAA,IAAAG,oBAAAC,oBACJ,KAAA,sLAgBO,IAAAC,YAAwBA,iEAK5BC,uBAEIC,gBAAU,EAEVC,iBAAmB,KAoCvB,kCAjCI,IAAAC,OAAwBC,GAAgB,OAEpCC,aAAIF,QAAqBF,eAEzBK,mBAAsBD,cAASH,4BAC/BK,KAAQH,IAAAI,QAAK,SAAUC,UAEnBC,eAAQD,qBAEAL,GAAAK,SACA,sCACCE,WAAAA,sBAAUD,eAAAE,QACXC,sBACAhB,oBAAMiB,WACVD,gBAAAd,UAAAU,MACI,+BACeE,WACfE,gBAAME,WAAAN,MACb,MACJ,QACDI,gBACDG,WAAAC,oBAAAR,KAAAC,eAAAG,gBAAAD,QAIHN,mBAAmBI,gBAAmBG,kBAEvCR,cACCL,oBAAekB,KAAAZ,oBAEfJ,iBAAiBI,mBACjBL,eAAgBE,SAEpBS,OAAOlB,OAAA,iIAcHyB,eAAWC,OAAAC,UAAAC,MAAAC,iBACPF,eACA,QACJD,OAAKI,QAAS,WAAA,OAAAD,SAAAD,OAAAG,mBAAAH,MAAA,QAAAF,WACV,UACA,OACPA,OAAAM,OAAA,WAAA,OAAAH,SAAAD,OAAAG,mBAAAH,MAAA,OAAAF,WACJ,qMAgBOO,WAAQ,OAAMA,SAEjBL,MAAAM,mBAAAC,EAAAC,QAAAD,EAAAE,YAAAF,EAAAG,UAAAH,EAAAI,QAAAC,WAAAL,EAAAK,eAAAC,GAAAC,UAAAP,EAAAO,UAAAA,UAAAT,UAEJU,KAAA,EAAA,iXA2BOC,gBAAYC,IAAAC,IAAAC,+BAGfF,eAAAG,WACIH,IAAAI,IAAAH,OAEGD,IAACK,IAAOJ,IAAAK,MAAAJ,eAIhBI,MAAYN,IAACC,kFAab,IAAAM,aAAmBC,QAACC,QAAA,KAMpB,qHAMAC,SAAU,SAAAnB,QAAAoB,UACZ,OAAA,GAIEC,OAAO,SAAWrB,QAAOoB,SAAKE,yBAI1BC,qBACH,oBAAAC,QAAA,8DAGGC,SAASD,QAAAnE,UAAAqE,uFAKLC,MAAqBH,QAAqB,UAEjDI,KAAAD,MAAAE,iBAAAF,MAAAG,oBAAAH,MAAAI,mBACKJ,MAAGK,kBAAmBL,MAAUM,6BAE9Bd,SAAU,SAAGnB,QAAAoB,UAAA,OAAAQ,KAAAM,MAAAlC,SAAAoB,oBAGhB,SAAApB,QAAAoB,SAAAE,yBAGGA,MACAa,QAAO/C,KAAE8C,MAAAC,QAAAnC,QAAAoC,iBAAAhB,eAER,CAEL,IAAOiB,IAAOrC,QAACsC,cAAAlB,UACjBiB,KACLF,QAAA/C,KAAAiD,2CAkBDE,YAAgB,uCAMRC,eACJA,wDAoBO,OAAAC,SAAiBC,KAEjB,OAAA,KAtBPC,OACIJ,aAAa,aAAuBK,OAAoB,qBAAC,aAAAA,mBAGjD,EACK,aAASA,uBAjB1B,MAAmB,SAAnBjE,KAAUkE,UAAS,EAAA,GAiB4BC,CAAsBnE,iBAChEA,QAAA,aAAAiE,QACJL,oBAEJ,SAAA5D,KAAAoE,OAAA,GAAAC,cAAArE,KAAAsE,OAAA,0BAID,OAAgBC,6DAgBhBC,YAAgB9B,gBAKR+B,oBAAmBC,YAEpBC,iBACHnG,OAAOsB,KAAA4E,QAAO3E,QAAA,SAAAC,iRCpQd4E,oBAAmBlG,UAAUmG,mFAa7BD,oBAAoBlG,UAAIoG,+UAwDdzD,QAAE0D,UAAAA,SAAYC,MAAAC,OAAAC,gBAAAC,yBAExB,YADE,IAAAD,kBAAAA,oBACK,IAAA9F,oBAAoBC,oBAAA+F,SAAAJ,gGAY3BK,gBAAA,2GAAA,oDCnFJC,sBAAmC,yBAK1BC,mBAAmBnD,UACX,iBAAFA,MACX,OAAOA,iMAaCoD,MACP,IAAA,IACJ,OAAApD,MAAAqD,2LA0BOL,SAEAJ,MAAI,SAEA,MACS,iBAATU,IAAoB,CAExB,IAAA3C,QAAW2C,IAAAC,oGAGP,OADAxF,OAAAM,KAAU,8BAAciF,IAAA,kBACxBN,SAAkB,EAAEJ,MAAA,EAAAC,OAAA,aAEvBW,sBAAAC,WAAA9C,QAAA,IAAAA,QAAA,IAED,IAAI+C,WAAY/C,QAAS,GACV,MAAX+C,aACAd,MAAMY,sBAAaG,KAAAC,MAAAH,WAAAC,aAAA/C,QAAA,SAGtBkD,UAAAlD,QAAA,GACDkD,YACHhB,OAAAgB,iCAMGC,oBAAkB,KAEdC,gBAAiB,EAEjBC,WAAWjG,OAAAlB,OACXmG,SAAW,IACXjF,OAAAM,KAAA,oEACH0F,gBAAA,GAEGnB,MAAO,IACV7E,OAAAM,KAAA,iEACJ0F,gBAAA,GAEJA,kWAoBIE,gBAAAC,YAEGC,2BACHrI,MAAAsI,QAAAF,QACDA,OAAOvG,QAAA,SAAiB6B,MAAA,OAAA6E,WAAA7E,MAAA,EAAA2E,0IAcP,IAAbG,cAAyBA,8BAKzB,IAAA,IAAQ1G,QAAQsG,OACnBI,YAAA1G,MAAAsG,OAAAtG,mEAcA2G,wBAAAtF,QAAAU,IAAAK,cAGAA,MACJL,IAAA,IAAAK,MAAA,gBAUOwE,oBAAkBvF,SAGtB,QADCwF,eAAA,GACQ/H,EAAG,EAAIA,EAAAuC,QAAQ4C,MAAOhF,OAAAH,IAAA,iBAGd6H,wBAAAtF,EADTU,IAACV,QAAa4C,MAAC6C,KAAAhI,GACNuC,QAAA4C,MAAA8C,iBAAAhF,oCAIb,GAAAV,QAAA4C,MAAkB7F,eAAA2D,OAAwBA,IAAAiF,WAAS,wLAcxC3F,QAAOiF,gBACf,mDAGC,IAAAW,UAAAC,oBAA6BlH,MAChCqB,QAAA4C,MAAAgD,WAAAX,OAAAtG,qEAaWqB,QAAMiF,gBACf,mDAGC,IAAAW,UAAAC,oBAA6BlH,MAChCqB,QAAA4C,MAAAgD,WAAA,sDAYJE,wBAAAC,OACD,OAAAlJ,MAAAsI,QAAAY,OACH,GAAAA,MAAAnI,0DA0BD,IAAAoI,YAAgB,IAAAC,OAAmBC,oBAAO,cAKlCC,mBAAgBpF,WAEhBqF,aACe,iBAARrF,MAAoB,CAK/B,QAHKsF,IAAAtF,MAAAuF,WAEJhC,WAAA,EACMA,MAAO0B,YAAAO,KAAAF,MACjBD,OAAAhH,KAAAkF,MAAA,4HAgBWkC,SAAWC,QAACT,YAAA,SAAAU,EAAAC,aAEfC,SAAAR,OAAAO,gBAEFP,OAAArJ,eAAA4J,kFAEIC,SAAO,kEAWdC,gBAAmBC,UAKtB,QAHOC,OAEJtB,KAAWqB,SAAAE,QACdvB,KAAAwB,2DA6BD,IAAAC,iBAAgB,yBAKPrB,oBAAAsB,cACDA,MAASV,QAAGS,iBAAc,WAEjC,IADM,IAAAE,KACNC,GAAA,EAAAA,GAAA1J,UAAAC,OAAAyJ,qJA2BOC,mCAAoCtH,QAAEuH,UAAAC,oBAEtCC,mBAAItK,OAAwBsB,KAAC+I,mBAC7BC,mBAAmB7J,QAAQ2J,UAAU3J,OAAM,wBAEnC2J,UAAyB,GAE7BG,6CACDhJ,QAAA,SAAAC,MACCgJ,mBAAoB5K,eAAQ4B,OACxB+I,oBAAUtI,KAAYT,yBAEbA,MAAa6I,eAAA7I,4BAExBf,OAOH,2BAJK,IAAAU,GAASiJ,UAAC9J,GACbiK,oBAAAhJ,QAAA,SAAAC,MAAAL,GAAAK,MAAAiJ,aAAA5H,QAAArB,SAGQlB,EAAA,EAAAA,EAAA8J,UAAA3J,OAAAH,IACpBoK,iDAYkBC,QAAQC,KAAUC,gBAC7BD,KAAME,WACF,EACJ,OAAMH,QAAAI,aAAAH,KAAAC,cACF,EACJ,OAAMF,QAAAK,WAAAJ,KAAAC,cACF,EACJ,OAAMF,QAAAM,gBAAAL,KAAAC,cACF,EACJ,OAAMF,QAAAO,cAAAN,KAAAC,cACF,EACJ,OAAMF,QAAAQ,WAAAP,KAAAC,cACF,EACJ,OAAMF,QAAAS,aAAAR,KAAAC,cACF,EACJ,OAAMF,QAAAU,eAAAT,KAAAC,cACF,EACJ,OAAOF,QAAAW,WAAAV,KAAAC,cACH,EACJ,OAAOF,QAAAY,eAAAX,KAAAC,cACH,EACJ,OAAOF,QAAAa,kBAAAZ,KAAAC,cACH,GACJ,OAAAF,QAAAc,gBAAAb,KAAAC,cACI,GACP,OAAAF,QAAAe,WAAAd,KAAAC,SACJ,KAAA;;;;;;;6DCjb4Bc,gBAAAhK,YAExBiK,qBACI,iBAAAD,gBACD,gBACHE,MAAA,WACMtK,QAAA,SAAYuK,KAAA,gBAaMC,SAAQH,YAAAjK,WAClB,cAAP,GAAO,CAEX,IAAAoE,gBA+BWiG,MAAYrK,eACvBqK,WACI,SACJ,MAAK,gBACD,SACJ,MAAA,gBACI,aACA,OAAO,SAASjJ,UAAAC,SAAA,OAAAqE,WAAArE,SAAAqE,WAAAtE,YACvB,IAAA,aACJ,OAAA,SAAAA,UAAAC,SAAA,OAAAqE,WAAArE,SAAAqE,WAAAtE,2BAEGpB,OAAAM,KAAmB,+BAA0B+J,MAAA,gCA1CjCC,CAAqBF,SAAQpK,QACxC,GAAA,mBAAAoE,OAEG,qCAEAgG,SAAY,2EAIhB,GAAa,MAAT5E,OAAiBA,MAAI1G,OAAA,EAErB,yFAAAmL,YAGJ,IAAA7I,UAAgBoE,MAAC,GAEb+E,UAAA/E,MAAkB,GAElBnE,QAAAmE,MAAgB,eACnBlF,KAAAkK,qBAAApJ,UAAAC,2KAnCkBoJ,CAAAN,IAAAF,YAAAjK,2JAuEnBwK,qBAA0BE,IAAEC,SAExBC,kBAAkBC,oBAAoBC,IAAIJ,MAAUK,qBAAAD,IAAAJ,KAEpDM,kBAAkBH,oBAAoBC,IAAIH,MAAQI,qBAAAD,IAAAH,YAClD,SAAavJ,UAAIC,aAEhB4J,SAAAP,KAAAQ,WAAAR,KAAAtJ,UAEG+J,SAAWR,KAAOO,WAAGP,KAAAtJ,eACxB4J,UAAAL,mBAAA,kBAAAxJ,YACD6J,SAAe7J,UAAYyJ,oBAACC,IAAAJ,KAAAK,qBAAAD,IAAAJ,OAEnCS,UAAAH,mBAAA,kBAAA3J,0LCzFD,SAAI+J,kBAAAC,OAA0BC,SAAAtL,QAC1B,OAAA,IAASuL,2BAA2BF,QAASG,MAAAF,SAAAtL,2HAa7CuL,2BAA0BhN,UAAEiN,eAK1BF,SAAAtL,uMAUUzB,UAAuBkN,uCAIjCvC,0HAWFqC,2BAA2BhN,UAAE6K,sBAKrBkC,SAAWpC,wDAKXwC,SAASxC,QAAKwC,SAAgB,EAEjCC,UAEGC,eA4BN,MA3BuB,KAAjBN,SAAQO,KAAI5H,OAAK,oKAIbwH,8BAA6BvC,SACtB,GAAP4C,IAAA3C,KAAwB,KAEpB4C,WAA6B,IAEjCC,OAAWD,WAAaF,KAC3BG,OAAAxE,WAAA0C,MAAA,WAAAtK,QAAA,SAAAhB,GACImN,WAAYF,KAAKjN,sDAGlBmN,WAAUF,KAAIG,YAEd,GAAiB,GAAjBF,IAAA3C,KAA6B,KAE5B8C,WAAAC,MAAA5C,gBAAA,IAAAJ,SACDiD,YAAcF,WAAME,WACvBT,UAAAO,WAAAP,SACFE,YAAAtL,KAAA2L,iBAGK/C,QAAElJ,OAAaM,KAAE,qMAc7BiL,2BAA2BhN,UAAE8K,oBAKrBiC,SAASpC,aAETkD,SAAIjO,KAAAwL,WAAuB2B,SAAGnF,OAAA+C,SAE9BmD,UAAYf,SAAGgB,SAAgBhB,SAAAgB,QAAAhF,QAAA,QAC/B8E,SAASG,sBAAe,oCAITF,cAclB,mBAbezM,QAAA,SAAmBqC,mBACfA,OAAK,iBAEJ,aACFtC,KAAA6M,aAAA5M,QAAA,SAAAC,MACJwH,mBAAAmF,YAAA3M,OAAAD,QAAA,SAAA6M,KACNC,SAAAzO,eAAAwO,MACFE,cAAAC,IAAAH,YAMNE,cAAAE,KAAA,CAEO,IAAGC,eAAA/E,gBAAA4E,cAAAI,UACH7D,QAAElJ,OAAaM,KAAA,UAAAgL,SAAAO,KAAA,iFAAAiB,eAAAE,KAAA,eAIzB7D,KAAA,gFAWFoC,2BAA2BhN,UAAE+K,2CAMzBJ,QAAIiD,WAAW,EACfjD,QAAOwC,SAAA,MAEHuB,UAAUC,aAAQ/O,KAAA6I,wBAAAsE,SAAA2B,WAAA/D,gBAIlBC,KAAA,EACFgE,SAHYC,oBAAoB9B,SAAA+B,KAAAnE,QAAAlJ,QAIpCiN,UAAAA,wHAWF1B,2BAA2BhN,UAAEgL,uBAKrB+B,SAASpC,aACXgD,MAAA/N,KACJ,gJAWFoN,2BAA2BhN,UAAEiL,oBAKrB8B,SAAYpC,wBAGZoE,YAAQpE,QAAcoE,YAEtBC,aAAe,EAEftG,MAAOqE,SAASrE,MAAAtF,IAAA,SAAA6L,MACjBtE,QAAAoE,YAAAA,YAEH,IAAOG,SAAAP,aAAAhB,MAAAsB,KAAAtE,SAEH,OADAqE,aAAO3H,KAAA8H,IAAAH,aAAArE,QAAAoE,aACAG,WAGb,eADIH,YAAAC,uFAYNhC,2BAA2BhN,UAAEkL,sBAKrB6B,SAASpC,SAEb,IAGCkD,SAHGuB,mBA6dP1L,MAAAjC,4BAGGiC,MAAIhE,eAAW,YACf2P,QAAoB,wFAKpB,OAAAC,cAAsC,SAAY,EAAE,QAGpDC,SAA4B,SAEhBA,SAAG5D,MAAS,OAAA6D,KAAA,SAAAC,GAAA,MAAA,KAAAA,EAAA/J,OAAA,IAAA,KAAA+J,EAAA/J,OAAA,KACxB,CAEJ,IAAOgK,IAAcJ,cAAwB,EAAA,EAAO,WACpDI,IAAOC,SAAA,EACVD,IAAAH,SAAAA,2HAhfWK,CAA+B7C,SAAGsC,QAAe1E,QAAGpF,QACxDoF,QAAIkF,sBAAuBT,6FAKJ,GAAnBU,cAAIlF,6DAGJ,qCAIImF,SAAI,sBACa,UAChB,EAEJ,IAAAC,gBACOZ,UAAA7I,+CAGR0J,gBAAqBvP,oBAAW6E,MAAAyK,cAEnCrF,QAAAoE,aAAAK,UAAA1I,SAAA0I,UAAA9I,MAED,IAAO4J,UAAAtQ,KAAAwL,WAAA6E,gBAAAtF,SACHuF,UAAOC,YAAAJ,QACPlC,SAASqC,yBAETL,sBAAa,MAEnBjF,KAAA,kDAWFoC,2BAA2BhN,UAAEoL,oBAK3B2B,SAAApC,sGAWFqC,2BAA2BhN,UAAEoQ,gCAKbzF,qCAGCoC,SAAAnF,QACImF,SAAA,OAAA1L,QAAA,SAAAgP,YACc,iBAAfA,WACHA,YAAA3P,oBAAAc,WACJoG,OAAA7F,KAAA,YAGA4I,QAAAlJ,OAAAM,KAAA,mCAAAsO,WAAA,oBAIEzI,OAAK7F,KAAiB,cAK7B6F,OAAA7F,KAAAgL,SAAkBnF,gFAMV,SAAS0I,cACbC,SAAID,WAAQ,KAERE,SAA0B,UAE1BjK,OAACiK,SAAuB,UACxBjK,uCAEIiK,SAAoB,uCAGhBlP,QAAMkP,SAAA,CAGjB,GADIA,SAAAlP,MACJ2H,WAAApF,eAAA,EAAA,CACJmK,uBAAA,EACF,YAODpD,KAAA,EACJhD,OAAAA,gHAWFoF,2BAAwBhN,UAAAyQ,2BAKhBf,IAAO/E,wBAGP0E,QAAO1E,QAAIkF,sBAEda,QAAA/F,QAAAoE,YAEG4B,UAAWhG,QAASoE,qBACT4B,UAAA,IACXA,WAAYtB,QAAO3I,SAAQ2I,QAAU/I,0BAEtB,SAAQsK,OACR,iBAAPA,iDAGJ,GAAIjD,MAAAkD,QAAeC,sBAAWxP,MAA9B,CAKA,IFnIQoC,MAAAqK,QAAAtM,sBEmIJsP,gBAAgBpG,QAAAoG,gBAAApG,QAAA,qCAEDoG,gBAAezP,4BAE1B,gXAKJ0P,sBAA2B,GAK3BL,UAAQM,eAASN,WAEpBK,uBACFD,gBAAAzP,OAAAqP,UAAAA,UAAAD,QAAAA,UAET/F,QAAAoD,UFtJkBrK,kBAAAqK,wBAAAtM,6BAEPsM,QAAOhF,oBAEXD,mBAAApF,QACFnD,QACN8D,QAAAhD,QAAA,SAAAiI,SACJP,OAAArJ,eAAA4J,2OE0JG0D,2BAA2BhN,UAAEmL,wBAKrB4B,SAAQpC,aACRgD,MAAO/N,yCAGX,IAAI+K,QAAAkF,sBAEA,uFAAAH,0JAiBA,IAAIwB,SAASvD,MAAQyC,cAAExI,OAAA+C,SAEnBwG,UAAwB,MAAf5L,SAAMvE,OAAmBkQ,SAAAlQ,gBA0O5B4G,WACC,iBAARA,cACH,gBAEI,sBACMA,uBACC,SAAIyI,eACdE,SAAAF,aAAAA,WAAA3Q,eAAA,UAAA,CAER,IAAA0R,IAAA,WACQpQ,OAASmG,WAAgCiK,IAAY,kCAK7D,GAAAb,SAAA3I,SAAAA,OAAAlI,eAAA,UAAA,CAEJ,IAAA0R,IAAA,qEA3PiDC,CAAAH,SAAAtJ,QAEtC5G,OAAA,EASA,OARiB,MAAjBmQ,YACAG,4BACAtQ,OAAakQ,SAAQlQ,OAAAmQ,WAEtBI,oBAAAA,qBAAAvQ,OAAA,GAAAA,OAAA,EACCwQ,kBAAmBA,mBAAExQ,OAAAF,eACrBA,eAAeE,OAClByQ,QAAA1P,KAAAf,QACGkQ,WAEHK,2HAIG5G,QAAAlJ,OAAeM,KAAK,4DAGvBxB,OAAAwM,SAAArE,MAAAnI,OAEGmR,gBAAkB,EACrBJ,0BAAA,GAAAA,0BAAA/Q,mIAIGmR,mBAAkCnR,OAAA,uBAKtCwO,YAAkBpE,QAAAoE,YAEdc,sBAAyClF,QAAgC,sBAEzEgH,gBAAI9B,sBAAiCnJ,0BACrCrF,QAAQ,SAAcJ,GAAAb,GAEtB,IAAAY,OAAM0Q,gBAAsB,EAAQtR,GAACwR,MAAA,EAAAF,gBAAAtR,EAAAqR,QAAArR,GAEjCyR,sBAAgB7Q,OAAA2Q,gBACrBhH,QAAAoE,YAAAA,YAAAc,sBAAAvJ,MAAAuL,sBACHhC,sBAAWnJ,SAAAmL,sBACblE,MAAA8C,kBAAAxP,GAAA0J,qDAWFqC,2BAA2BhN,UAAEqL,wBAKvB0B,SAAApC,SACJ,qJAWFqC,2BAA2BhN,UAAEsL,2BAKvByB,SAAApC,gBACJA,QAAAwC,yEAWFH,2BAA2BhN,UAAEuL,yBAKvBwB,SAAApC,SACJ,+HAWFqC,2BAA2BhN,UAAEwL,oBAKzBuB,SAAQpC,SAER,IAAImH,eAAgCnH,QAA6B,qBAE7DoD,QAAyBhB,SAAAgB,YAC7BpD,QAAAiD,2CAEA,IAAImE,YAoDPhO,UAED,IAAAiO,eAAmBjO,SAAS4H,MAAM,WAAEsG,KAAA,SAAoBC,OAAA,OAAAA,OAAAC,qCAE3CpO,SAAAqF,QAAegJ,iBAAsB,8MAxD1CC,CAAYtF,SAAmBhJ,UAAAA,SAAuBgO,GAAC,GAAAO,YAAmBP,GAAE,GAChFpH,QAAQ4H,qBACRT,eAAQvR,OAAoBuR,eAAkB,IAAA/N,SAAAA,SAC9CZ,gBAAOwH,QAAAoG,gBAAApG,QAAA4H,6BAEH7D,UAAUC,aAAQ/O,KAAA6I,wBAAAsE,SAAA2B,WAAA/D,wBAClB6H,aAAe,aACfD,qBAAoBT,gBAEpBlH,KAAA,GACF7G,SAAAA,SACJ6N,MAAA7D,QAAA6D,OAAA,mKAWF5E,2BAA2BhN,UAAEyS,sBAKrB1F,SAAUpC,SACVA,QAAE6H,cACF7H,QAAAlJ,OAAcM,KAAA,oDAGdsN,QAA8B,SAArBtC,SAAEsC,SACX3I,SAAS,EAAIJ,MAAA,EAAAC,OAAA,QACfmM,cAAA3F,SAAAsC,QAAA1E,QAAAlJ,QAAA,GACJ,OACKmJ,KAAA,GACN8D,UAAAC,aAAA/O,KAAA6I,wBAAAsE,SAAA2B,WAAA/D,SAAA0E,QAAAA,oFAqCiC,2BACL5N,QACzB7B,KAAK6B,OAAAA,OACL7B,KAAKgO,WAAA,EACLhO,KAAKuN,SAAW,EAChBvN,KAAK+S,kBAAoB,KACzB/S,KAAK4S,aAAe,KACvB5S,KAAA2S,qBAAA,KACD3S,KAAOiQ,sBAA0B,KAChCjQ,KAAAmP,YAAA,6CATiC,yFA0G7B6D,0BAAA7E,aA7GaqD,WA8GjBrD,iBACI8E,QAAA9E,UACY,SAChBA,QAAA,QAjHiBqD,IAiHjBrD,QAAA,QAhHQ8E,QAAUzB,KAAK,oIC1lBpB0B,0BAAgBnQ,QAAAuH,UAAA6I,cAAAC,eAAAtM,SAAAJ,MAAAC,OAAA0M,yBACL,IAAX1M,SAAoBA,OAAA,WACL,IAAf0M,cAAeA,aAAa,IAE5BrI,KAAA,EACAjI,QAAOA,QACPuH,UAAWA,UACb6I,cAAAA,cACLC,eAAAA,6PC/BQrQ,aAEGuQ,aAAetT,KAAGuT,KAAA3P,IAAAb,gBACrBuQ,aACDtT,KAAOuT,KAAAC,OAAazQ,uCAYxB0Q,sBAAmBrT,UAAYsT,gBAK1B3Q,QAAAuQ,cAEH,IAAAK,qBAAA3T,KAAAuT,KAAA3P,IAAAb,uOAkBF0Q,sBAAArT,UAAAwT,4JCzBHC,wBAAA3G,OAAA4G,YAAAhE,IAAAiE,eAAAC,eAAAC,eAAAC,YAAA/F,QAAAgG,gBAAAtS,oBACG,IAAAoS,iBAA+BA,wBACtB,IAATC,cAASA,qBACR,IAAArS,SAAAA,2QA2eD,yEA3cIqL,OAAQ4G,YAAkBhE,IAAAiE,eAAAC,eAAAC,eAAAC,YAAA/F,QAAAgG,gBAAAtS,aAClB,IAARA,SAAwBA,WACxBsS,gBAAiBA,iBAAgB,IAAAV,sBAEjC,IAAI1I,QAAS,IAAGqJ,yBAAyBlH,OAAU4G,YAAYK,gBAAgBJ,eAAiBC,eAAOnS,WACvGkJ,QAAIoD,QAAUA,qGAEDnO,KAAA8P,IAAU/E,uBAEZA,QAAWsJ,UAAYC,OAAM,SAAUC,UAAQ,OAASA,SAAAC,mCAC9D7T,QAAAT,OAAAsB,KAAA0S,aAAAvT,OAAA,CAEL,IAAO8T,GAAAJ,UAAgBA,UAAG1T,OAAc,GACnC8T,GAAAC,2BACPD,GAAAE,WAAAT,aAAA,KAAAnJ,QAAAlJ,OAAAsM,kKAWFyG,gCAAwBxU,UAAA6K,qCAaxB2J,gCAAwBxU,UAAA8K,mCAaxB0J,gCAAwBxU,UAAA+K,wCAaxByJ,gCAAwBxU,UAAAsL,2BAKhBoE,IAAI/E,aAEJ8J,oBAAgB9J,QAAQoJ,gBAAgBW,QAAY/J,QAAAhI,iCAGpD,IAAIgS,aAAahK,QAASiK,iBAAAlF,IAAA3B,uDAIzB2C,QAAA9Q,KAAAiV,sBAAAJ,oBAAAE,aAAAA,aAAA,SACJhE,WAAAD,6EAaL8D,gCAAwBxU,UAAAuL,yBAKpBmE,IAAQ/E,SAEV,IAAAgK,aAAAhK,QAAAiK,iBAAAlF,IAAA3B,iTAsBMiB,iIAIgB,MAAZjB,QAAYzH,MAAAO,mBAAAkH,QAAAzH,OAAA,YACH,2BACVjF,QAAA,SAAAyT,aAEA,IAAAC,mBAAapK,QAAAqK,4BAAAF,YAAApO,SAAAJ,OACtB0I,yGAWFwF,gCAAwBxU,UAAAqL,8IAexBmJ,gCAAwBxU,UAAAgL,uBAKhB0E,IAAM/E,wBAGNsK,gBAAYtK,QAAcsK,gBAE1BC,IAAIvK,gBAEI+E,IAAI3B,qBACAA,QAAAhF,QAAgBgF,QAAAzH,sBAChBsO,iBAAe7G,2DAGX,GAARmH,IAAAC,aAAQvK,OACRsK,IAAAE,gBAAoBC,wBAC3BH,IAAAC,aAAAG,4BAGG,IAAAhP,MAAMO,mBAAuBkH,QAAOzH,wHAOpC8O,gBAAIG,wBAIdL,IAAAD,gBAAAA,2EAWFT,gCAAwBxU,UAAAiL,oBAKhByE,IAAA/E,wBAGA6K,kBAEAxG,aAAIrE,QAAeyK,gBAAQrG,kBAEvBW,IAAA3B,SAAa2B,IAAA3B,QAAczH,MAAOO,mBAAA6I,IAAA3B,QAAAzH,OAAA,YACrCjF,QAAA,SAAAlB,GAED,IAAAwU,aAAmBhK,QAAKiK,iBAAclF,IAAA3B,SACtCzH,OACDqO,aAAAc,cAAAnP,uHAIHkP,eAAezT,KAAQ4S,aAAUS,8MAcrCZ,gCAAwBxU,UAAA0V,sBAKhBhG,IAAI/E,YACJ,IAAqBgF,QAAa,KAEjCJ,SAAA,IAAAA,SAGP,OAAAmD,cADG/H,QAAA5B,OAAA4M,kBAAApG,SAAA5E,QAAA5B,OAAA4B,QAAAlJ,QAAA8N,SACH5E,QAAAlJ,yEAWF+S,gCAAwBxU,UAAAkL,sBAKhBwE,IAAO/E,aAEP0E,QAAS1E,QAAAkF,sBAAwBjQ,KAAA8V,aAAAhG,IAAAL,QAAA1E,0CAGjCpF,QAAKe,QACLf,QAAKqQ,cAAUvG,QAAA/I,OACf6N,SAAKkB,6BAGLnE,SAAQxB,IAAAnK,MACO,GAAf2L,SAAKtG,KACLhL,KAAAuL,eAAS+F,SAAqBvG,UAGlCA,QAAQiL,cAAkBvG,QAAC3I,UAC7B9G,KAAAwL,WAAA,SAAAT,wGAWF6J,gCAAwBxU,UAAAoL,iCAOpB,IAAI+I,SAAQxJ,QAAIyK,gBAEf/F,QAAA1E,QAAA,uBAGG0E,SAAI8E,SAAa0B,4BAAAtV,QACjB4T,SAAS2B,mBAGTvP,OAAS8I,SAAUA,QAAU9I,QAAUmJ,IAAAnJ,OAC1CmJ,IAAAS,YACDgE,SAAQ4B,eAAmBxP,uGAY/BiO,gCAAwBxU,UAAAmL,wIAWpBzE,SAAcmJ,sBAASnJ,SAInBsP,yCAA0BZ,8BAC1B7O,OAAcsJ,sBAA2BtJ,WACzCqB,OAAAvG,QAAc,SAAA4N,2EAIlB+G,cAAQzB,UAAgBtF,KAAArH,OAAAqH,KAAA1I,OAA6BoE,QAAAlJ,OAAekJ,QAAAoD,iDAKtEpD,QAAAyK,gBAAAa,6BAAAD,8FAWFxB,gCAAwBxU,UAAAwL,oBAKhBkE,IAAO/E,wBAGPgG,UAAUhG,QAAQyK,gBAAiBrG,YAEnChB,QAAwB2B,IAAA3B,YAE3BzH,MAAAyH,QAAAzH,MAAAO,mBAAAkH,QAAAzH,OAAA,yCAEe,GAAZqK,WAAehG,QAAUyK,gBAAAS,4BAAAtV,0DAEzBoK,QAAOwK,aAAQG,4BAGnB,IAAItG,aAAA2B,UAEAuF,KAAOvL,QAAC7E,YAAiB4J,IAAK3L,SAAA2L,IAAAyG,iBAAAzG,IAAAkC,MAAAlC,IAAA4C,cAAAvE,QAAAqI,SAAAzL,QAAAlJ,kDAG9B4U,oBAAW,kBACP,SAAa1T,QAAAvC,WAChBkW,kBAAAlW,MAEGuU,aAAAhK,QAAsBiK,iBAAalF,IAAA3B,QAAgBpL,SACtD2D,OACDqO,aAAac,cAAWnP,oIAS5BqO,aAAQS,gBAAsBG,wBAE9B,IAAQ7E,QAAAiE,aAAAS,gBAAuCrG,YAC3CC,aAAA3H,KAAmB8H,IAAEH,aAAA0B,mBAErB4F,kBAAwB,UAC3BC,kBAAA,EACD5L,QAAQ6L,yBAAmBxH,cAC7BqH,2KAWF7B,gCAAwBxU,UAAAyS,8JAepBgE,QAAQ/P,UAAkBiE,QAAA4L,kBAAA,SAElB7P,SAAeiE,QAAQ2L,yBAEhBjH,QAAA3I,SAAA,EAAA,UAAA2I,QAAA9I,YAEP,UACPD,MAAAmQ,QAAAnQ,YAEG,IAAA,OACAA,MAAOoQ,cAAAC,mBAIX,IAAIxC,SAAAxJ,QAAeyK,gBACnB9O,OACA6N,SAAQsB,cAAmBnP,sFAK3BqE,QAAAwK,aAAczF,qCAOlB2E,GAAAtF,YAA0B6H,cAAAvC,GAAA1D,UAAyB+F,cAAAtB,gBAAAzE,YAEnD6D,0FAI0C,oBACjCR,yBAAkBnD,QAAgBlO,QAAAoR,gBAAA8C,gBAAAC,gBAAArV,OAAAwS,UAAA8C,iBACvCnX,KAAKiR,QAASA,QACdjR,KAAK+C,QAASA,QACd/C,KAAKmU,gBAAgBA,gBACrBnU,KAAKiX,gBAAAA,gBACLjX,KAAKkX,gBAAeA,gBACpBlX,KAAK6B,OAAAA,OACL7B,KAAKqU,UAAYA,UACjBrU,KAAK8W,cAAA,KACL9W,KAAKiQ,sBAAsB,KAC3BjQ,KAAKuV,aAAAG,2BACL1V,KAAKqV,gBAAkB,EACvBrV,KAAAmO,WACHnO,KAAA0W,kBAAA,EACD1W,KAAO2W,kBAAe,EAClB3W,KAAG+W,mBAAA,uIAIHK,eAAgBhD,yBAAAhU,UAAA,UAChBwD,2EAYJwQ,yBAAmBhU,UAAciX,uBAKzBlJ,QAAUmJ,6BAEd,GAAInJ,QAAJ,KAGIoJ,WAAmB,QAEnBC,gBAAgBxX,KAAImO,QAEvB,MAAAoJ,WAAAzQ,6EAGc,MAAXyQ,WAAW7Q,kFAIP6Q,WAAmBpO,oBACtB,KAEGsO,iBAAsCD,gBAAuB,2CAE5DxX,KAAAmO,QAAAhF,WAERjJ,OAAAsB,KAAAkW,WAAAjW,QAAA,SAAAiM,MACH4J,cAAAG,iBAAA3X,eAAA4N,+HASmBtN,UAAAuX,+CAMTxJ,QAAI,KAEPyJ,YAAA5X,KAAAmO,QAAAhF,OACJ,GAAAyO,YAAA,CAEH,IAAArJ,SAAAJ,QAAA,2KAkBMA,QAAUpL,QAAI8U,cACV,IAAR1J,UAAuBA,QAAK,MAE5B,IAAA2J,OAAQ/U,SAAe/C,KAAA+C,QAEvBgI,QAAQ,IAAAqJ,yBAAyBpU,KAAAiR,QAAkB6G,OAAA9X,KAAAmU,gBAAAnU,KAAAiX,gBAAAjX,KAAAkX,gBAAAlX,KAAA6B,OAAA7B,KAAAqU,UAAArU,KAAAwV,gBAAAuC,KAAAD,OAAAD,SAAA,WACnD9M,QAAQwK,aAAAvV,KAAoBuV,aAC5BxK,QAAQkF,sBAAqBjQ,KAAAiQ,sBAC7BlF,QAAKoD,QAAAnO,KAAkB2X,eACvB5M,QAAOsM,cAAQlJ,SACjBpD,QAAA2L,kBAAA1W,KAAA0W,uJAUsBtW,UAAAwW,kCAItBiB,0QAkBM3C,YAAUpO,SAAAJ,2BAGVI,SAAc,MAAJA,SAAIA,SAAwBoO,YAASpO,SAC/CJ,MAAC1G,KAAUwV,gBAAcrG,aAAA,MAAAzI,MAAAA,MAAA,GAAAwO,YAAAxO,MAC7BC,OAAO,gRAWcvG,UAAA4V,6JAevBtP,mHAwBGvC,SAAAoS,iBAAAvE,MAAAU,YAAA8D,SAAA3U,0BAGG6Q,aACAxN,QAAQ/C,KAAGnC,KAAA+C,SAEXoB,SAASxD,OAAQ,EAAI,CAGrBwD,UADAA,SAAIA,SAAgBqF,QAAQwO,kBAAkB,IAAEhY,KAAUiX,kBACzCzN,QAAAyO,kBAAA,IAAAjY,KAAAkX,2BAEA,GAATlF,MAERkG,SAAalY,KAAMiR,QAASkH,MAAAnY,KAAU+C,QAAAoB,SAAAE,OACzC,IAAA2N,QACIkG,SAAYlG,MAAQ,EAAMkG,SAAOE,MAAAF,SAAAvX,OAAAqR,MAAAkG,SAAAvX,QAC3BuX,SAAKE,MAAW,EAAGpG,QAE9B9M,QAAO/C,KAAQ8C,MAAAC,QAAAgT,UAwCnB,OAtCO1B,UAAyB,GAAzBtR,QAAAvE,QACNkB,OAAAM,KAAA,WAAAoU,iBAAA,4CAAAA,iBAAA,uDAqCQrR,SAELkP,yBAjQuB,mBAmQlB,oBACAiE,gBAAapH,QAAAlO,QAAAgO,UAAAuH,8BAClBtY,KAAKiR,QAAAA,QACLjR,KAAK+C,QAAAA,QACL/C,KAAK+Q,UAAUA,UACf/Q,KAAKsY,6BAAmBA,6BACxBtY,KAAK8G,SAAA,EACL9G,KAAKuY,qBACLvY,KAAKwY,oBACLxY,KAAKyY,WAAK,IAAA9U,SACN+U,sBACHC,kBACD3Y,KAAK4Y,aACL5Y,KAAK6Y,0BAAqB,KACrB7Y,KAAKsY,+BACNtY,KAAKsY,6BAA6B,IAAA3U,UAErCmV,qBAAA5Y,OAAAC,OAAAH,KAAA4Y,cACD5Y,KAAK+Y,sBAAgB/Y,KAAAsY,6BAAA1U,IAAAb,SACxB/C,KAAA+Y,uJAID/Y,KAAAgZ,uCAKc5Y,UAAAoU,oCAINxU,KAAAyY,WAAA/J,WACI,EACP,OAAA,EACH,KAAA,sFASKtO,UAAA6V,qCAGH,OAAc/V,OAAOsB,KAAKxB,KAAAwY,0BAC1BpB,eAAgBiB,gBAAAjY,UAAA,eAChBwD,qIAeI8C,2BAEC,GAAA1G,KAAAyY,WAAA/J,MAAAxO,OAAAsB,KAAAxB,KAAA2Y,gBAAAhY,OACJX,KAAA8G,UAAAmS,sBACIC,YAAAlZ,KAAAmP,YAAAzI,OACGuS,iBACPjZ,KAAAyV,gDAYL4C,gBAAUjY,UAAS2X,mCAOnB,oCAAA,IAAeM,gBAAWrY,KAAAiR,QAAalO,QAAAoM,aAAAnP,KAAAmP,YAAAnP,KAAAsY,+CAK1BlY,UAAA4Y,yBAILhZ,KAAKwY,mBACLxY,KAAKuY,kBAAoBvY,KAAAwY,kBAE/BxY,KAAAwY,iBAAAxY,KAAAyY,WAAA7U,IAAA5D,KAAA8G,oKASO1G,UAAgB8V,+EAWhB9V,UAAA8Y,iGAcTb,gBAAgBjY,UAAO+Y,+GAQvBnZ,KAAA0Y,cAAgBhX,OAAU0X,KAAApZ,KAAAmP,YAAuBrL,MAAAA,0DAQjD,WAAA,OAAgB9D,KAAU6Y,4BAAc7Y,KAAAwY,kCAKxBpY,UAAK+V,8FAenBjW,OAAAsB,KAAAxB,KAAA+Y,uBAAAtX,QAAA,SAAAC,4RAqBE,IAAIqM,MAAM/N,cAENA,KAAAuY,kBAA8B,OAAK5R,YAGnCwC,OAAUgF,SAAAA,QAAkBhF,WAE5BnB,gBAuRMkC,MAAUmP,4DAKf,SAAA/G,OACS,MAAVA,OACHgH,cAAAA,eAAApZ,OAAAsB,KAAA6X,YACF5X,QAAA,SAAAC,MAAAsG,OAAAtG,MAAAZ,oBAAAc,kDA/RU2X,CAAMrP,MAAAlK,KAAqB+Y,mCAC5B/Q,QAAMvG,QAAc,SAAUC,cAE1BE,kBAAAA,OAAAA,MAAWuH,OAAAtH,cAClB8W,eAAAjX,MAAA0H,IACI2E,MAAC+K,qBAAwBhZ,eAAA4B,QAC/BqM,MAAA6K,UAAAlX,MAAAqM,MAAAgL,sBAAAjZ,eAAA4B,MACLqM,MAAAgL,sBAAArX,iIAaE,IAAIqM,MAAM/N,KAENgI,OAAChI,KAAA2Y,yCAGe,GAAhBa,MAAI7Y,cAELgY,kBACHa,MAAM/X,QAAM,SAAKC,UAET0H,IAAMpB,OAAAtG,YACT8W,iBAAA9W,MAAA0H,MAEPlJ,OAAAsB,KAAAxB,KAAA8Y,sBAAArX,QAAA,SAAAC,uIASctB,UAAKqV,qCAIb1H,MAAM/N,YACPwB,KAAAxB,KAAA8Y,sBAAArX,QAAA,SAAAC,8HAUAtB,UAAAqZ,4BAGH,OAAYzZ,KAAAyY,WAAA7U,IAAA5D,KAAA8G,wFAOX,IAAA4S,cACD,IAAA,IAAYhY,QAAI1B,KAAAwY,iBAChBkB,WAAkBvX,KAAAT,yEAWNtB,UAAKiW,oDAKbtI,MAAI/N,YACJwB,KAAK+S,SAAYmE,eAAajX,QAAG,SAAeC,UAE/CiY,SAAA5L,MAAA2K,cAAAhX,MAEPkY,SAAArF,SAAAmE,cAAAhX,2GASOtB,UAAAyZ,0BAIL,IAAI9L,MAAA/N,4DAKAoT,eAAY,IAAQ0G,IAEpB3J,QAA+B,IAA3BnQ,KAAAyY,WAAgB/J,MAA2B,IAAR1O,KAAM8G,2CAGrCrF,QAAQ,SAAcsY,SAAMX,wBAE5BjR,WAAuB4R,UAAC,UAC3BvY,KAAAwY,eAAAvY,QAAA,SAAAC,UAEGoC,MAAAkW,cAAmBtY,MACtBoC,OAAAhD,oBAAAiB,WACFoR,cAAA1E,IAAA/M,MAECoC,OAAchD,oBAAwBc,YACzCwR,eAAA3E,IAAA/M,kBAIDsY,cAAyB,OAAIZ,KAAGrL,MAAAjH,UAEhCmT,eAAY9X,KAAA6X,yKAOZ7J,QAAI,CAEJ,IAAA+J,IAAAD,eAAuB,GAEpBE,IAAAlH,QAAAiH,KACTA,IAAA,OAAA,EACKC,IAAA,OAAgB,EACtBF,gBAAAC,IAAAC,KAmCDC,OAAkBlH,0BAA2BlT,KAAC+C,QAAAkX,eAAAI,SAAAC,UAAAta,KAAA8G,SAAA9G,KAAA+Q,UAAA/Q,KAAA2G,QAAA,IAE1C0R,gBA3XK,sBA6XmB,SAAAkC,iBAEnBC,mBAAiBtN,OAAAnK,QAAcuH,UAAA6I,cAAAC,eAAA3D,QAAAgL,+BACb,IAAvBA,2BAAsCA,0BAAA,GACtC,IAAA1M,MAAMwM,OAAA3Z,KAAAZ,KAAwBkN,OAAGnK,QAAA0M,QAAA/I,QAAyB1G,KAO9D,OANI+N,MAAMhL,QAAUA,QAChBgL,MAAAzD,UAAaA,UAChByD,MAAAoF,cAAAA,8LAIDpF,uBAVUyM,mBAAYD,qHAsBLna,UAAQyZ,uDAMjB1H,GAAInS,KAAAyP,QAAY/I,MAAWyL,GAAAzL,MAAMI,SAAAqL,GAAArL,SAAAH,OAAAwL,GAAAxL,oEAKjCtD,UAAgByD,SAAUJ,kCAI1BgU,iBAAiBvS,WAAYmC,UAAY,IAAA,GACzCoQ,iBAAkB,OAAA,sCAGlB,IAAAC,iBAAqBxS,WAAYmC,UAAA,IAAA,iEAEpBnI,KAAAwY,0BAET3I,MAAI1H,UAAS3J,OAAA,oBAGb,IAAGU,GAAA8G,WAAYmC,UAAY9J,IAAA,GAIvBoa,eAAalU,MAFpBrF,GAAA,OAEoByF,SACrBzF,GAAU,OAAAwZ,YAAAD,eAAAvX,WACVyX,aAAY3Y,KAAAd,IAGhByF,SAAOzD,UACTqD,MAAA,EACKC,OAAA,GACT2D,UAAkBwQ,0JA7DY,2BAsF/BD,YAAAzZ,OAAA2Z,uICpqCAvZ,uCC3DWwZ,UAAM/J,QAAA/G,OACVlK,KAAIiR,QAAOA,YAEPpP,UAEHiO,IAAA7C,kBAAAgE,QAAA/G,MAAArI,QACD,GAAIA,OAAClB,OAAa,+OAyBlB,IAAAsa,MAAArb,MAAkBsI,QAAA+L,gBAAuBlM,gBAAAkM,gBAAwB,eAE7DiH,KAAMtb,MAAGsI,QAAAiT,mBAA6BpT,gBAAkBoT,mBAAqC,4CAGzFhH,iBAAe,IAAAV,0BAEtBxN,OAAA4N,wBAAA7T,KAAAiR,QAAAlO,QAAA/C,KAAAob,oCAAAH,MAAAC,KAAA/M,QAAAgG,gBAAAtS,QACD,GAAAA,OAAOlB,OAAO,CAEX,IAAA0a,aAAU,+BAAAxZ,OAAAgN,KAAA,MACjB,MAAA,IAAAyM,MAAAD,8ECHJ,+GAaIE,6BAAwBnb,UAAUob,sbF5ClCC,6BAAwBrb,UAAQob,kKAsBxBE,qBAAqBC,mBAAuB7X,MAAKjC,iBAE7C,UAECiC,MAAAuF,WAAAuS,8EAEG,iBAAA9X,MACJoD,KAAI,SAEH,CAER,IAAA2U,kBAAA/X,MAAAuD,MAAA,0BACMwU,mBAAc,GAAAA,kBAAA,GAAAlb,QACvBkB,OAAAM,KAAA,uCAAAuZ,qBAAA,IAAA5X,OAKF,OAAAgY,OAAoB5U,oFAWvB1F,sUALDuK,MAAS;;;;;;;YGbDgQ,4BAAqBhZ,QAAAC,YAAmBC,UAAAC,QAAA8Y,oBAAAC,WAAAC,SAAA7H,UAAA8H,gBAAAhJ,cAAAC,eAAA/P,UAAAxB,eAExCmJ,KAAA,EACAjI,QAASA,QACTC,YAAUA,YACVgZ,oBAAoBA,oBACpB/Y,UAAAA,UACAgZ,WAAAA,WACA/Y,QAAAA,QACAgZ,SAASA,SACT7H,UAAQA,UACV8H,gBAAAA,gBACLhJ,cAAAA,8HCnDI,2QAyIwBiJ,SAAAC,aAAAC,UAAAvZ,QAAAoG,eACrBiT,SAAKxM,KAAA,SAAgB2M,IAAA,OAAcA,GAAAF,aAAAC,UAAAvZ,QAAAoG,wJArGnC,IAAAqT,kBAAqBxc,KAAAyc,aAAY,w1BAuDjCC,kBAAkBvT,OAAcwT,YAAcC,0BAA0BC,sBAEpExI,UAAOyI,gBAAAjJ,wBAA0C3G,OAAcnK,QAAA/C,KAAc8P,IAAAhB,UAAWiF,eAAWC,eAAoB+I,mBAAyBC,gBAAaN,iBAAuBvI,gBAAUtS,QAElMwB,UAAU,yFAENxB,OAAOlB,mMAGJc,QAAA,SAAqBgT,IAExB,IAAIrP,IAAAqP,GAAS1R,QAETsX,SAAQ9W,gBAAS0Z,YAAA7X,yBACjB3D,QAAoB,SAAKC,MAAA,OAAA2Y,SAAA3Y,OAAA,IAE9B,IAAA4Y,UAAA/W,gBAAA2Z,aAAA9X,6EAECA,MAAArC,SACGoZ,gBAAA1N,IAAArJ,wSA/GV,sJAsJD+X,qBAAkB/c,UAAQgd,qBAKhBjU,OAAMtH,YAERqS,8BAEIjB,QAAmBjT,KAAGqd,6BACzB7b,KAAA2H,QAAA1H,QAAA,SAAAgC,KAED,IAACK,MAAOqF,OAAO1F,KACJ,MAAPK,mFAKc,iBAAVA,MAAqB,gBAEO,aAC3BtC,KAAA8b,YAAA7b,QAAA,SAAAC,MAEF,IAAA0H,IAAAkU,WAAA5b,MACN0H,IAAAzI,OAAA,IACFyI,IAAA2M,kBAAA3M,IAAAmU,eAAA1b,SAELqS,YAAAxS,MAAA0H,mECxKgC,oBACzBoU,iBAAY9P,KAAAoC,KACjB,uBAAI/B,MAAO/N,yBAEP8P,IAAIA,SACJ2N,4BACDjQ,UACHsC,IAAAtC,OAAA/L,QAAkB,SAAWqO,KAEzB,IAAAuN,cAAoBvN,IAAA3B,SAAe2B,IAAA3B,QAAAhF,WACnC4E,MAAMP,OAAAsC,IAAApC,MAAmB,IAACyP,qBAASrN,IAAAnK,MAA0B0X,iBAEjEK,kBAAK1d,KAAkBwN,OAAG,OAAA,KAC7BkQ,kBAAA1d,KAAAwN,OAAA,QAAA,KACDsC,IAAOrC,YAAAhM,QAAe,SAAgBqO,KAC/B/B,MAAA0P,oBAAAtb,KAAA,IAAAwb,2BAAAjQ,KAAAoC,IAAA/B,MAAAP,oHA4EHxC,KAAA,EACF8D,WAJY9D,KAAQ,EAAAlC,SAAAqF,QAAA,MAKtBa,UAPW,SAAA/L,UAAAC,SAAA,OAAA,IAQdiL,QAAA,qDA3EOiJ,eAAgBoG,iBAAApd,UAAA,mBAChBwD,6bApB6B,YA0GhC8Z,kBAAAlM,IAAAoM,KAAAC,UACI/d,eAAQ8d,MACLpM,IAAK1R,eAAa+d,QACzBrM,IAAAqM,MAAArM,IAAAoM,iFCtHsB,IAAAnK,8CACG,oBACjBqK,wBAAkBC,SAAA9M,QAAA+M,aACvBhe,KAAK+d,SAAUA,SAClB/d,KAAAiR,QAAAA,qGAWD6M,wBAAwB1d,UAAA6d,kBAKhBC,GAAM/Q,cAETtL,UAEGiO,IAAK7C,kBAAkBjN,KAAIiR,QAAA9D,SAAAtL,WAC9BA,OAAAlB,OACH,MAAA,IAAA2a,MAAA,8DAAAzZ,OAAAgN,KAAA,yFAkBErO,EAAOQ,UAAagB,yRAoBpB,IAAI+L,MAAM/N,wCAONsT,uBAFAxD,IAAK9P,KAAAme,YAAAD,kBAIS,IAAGva,yBAEdkQ,wBAAA7T,KAAAiR,QAAAlO,QAAA+M,gCAAA3B,QAAAiQ,sBAAAvc,SACNJ,QAAA,SAAA4c,MAEG,IAAOrW,OAAKzE,gBAAA+a,cAAAD,KAAAtb,YACZsb,KAAAjL,eAAkB3R,QAAA,SAAAC,MAAA,OAAAsG,OAAAtG,MAAA,UAIrBG,OAAAM,KAAA,uEACDmR,iBAEGzR,OAAAlB,wJAICT,OAAIsB,KAAMwG,QAAGvG,QAAc,SAAMC,MAASsG,OAAAtG,MAAAqM,MAAAkD,QAAAtG,aAAA5H,QAAArB,KAAAZ,oBAAAc,oBAShDS,OAAAkc,iDAJM,IAACvW,OAAYsW,cAAc1a,IAAApD,EAAAuC,SAC/B,OAAOgL,MAAUyQ,aAAYhe,KAAEwH,+LAmB/B,IAAI3F,OAASrC,KAAGye,WAAAP,WACZQ,iBACH1e,KAAA2e,aAAAT,yIAeAA,IAEH,IAAA7b,OAAArC,KAAA2e,aAAAT,wJAoBAA,GAAAnb,QAAAT,UAAAE,sMAoBM0b,GAAAnb,QAAWiB,QAAU4a,gCAKxB,UAAA5a,aAOG3B,OAAKrC,KAAOye,WAAAP,WACRla,aACA,OACJ3B,OAAKwc,OACD,UACA,QACJxc,OAAKyc,QACD,UACA,QACJzc,OAAK0c,QACD,UACA,UACJ1c,OAAW2c,UACP,UACA,SACJ3c,OAAK4c,SACD,UACA,OACJ5c,OAAK6c,OACD,UACA,cACP7c,OAAA8c,YAAA5X,WAAAqX,KAAA,KACH,MACK,IAAA,UACP5e,KAAA0e,QAAAR,UA7BQ,IAAA/P,QAA6ByQ,KAAA,OACjC5e,KAAQG,OAAO+d,GAAAnb,QAAAoL,cANXnO,KAAIie,SAAOC,GAAsBU,KAAO,6BA/KtB,GCU1BQ,sBAEAC,oBACFC,YAAA,oBAEEC,YAAA,EACAC,cAAa,EACbC,sBAAiB,GAGjBC,4BACFJ,YAAA,2EA6CEK,aAAU,0BAKe,uDAED,IAAhBL,cAAsBA,YAAiB,IAC3Ctf,KAAKsf,YAAQA,2DAITxb,MAAO8b,MAAQ1V,MAAS,MAAAA,cACxBpG,eAuoEXA,qCAvoEgB+b,CAAO/b,OACf8b,MAAA,CAEG,IAAIzR,QAAQ8E,QAAM,cACrB9E,QAAA,MACGnO,KAAKmO,QAAiB,aAG7BnO,KAAAmO,WAEMnO,KAAAmO,QAAAhF,iCA0CA,cAtCHiO,eAAgB0I,WAAA1f,UAAA,UAChBwD,uHAeIuK,uBAEQA,QAAYhF,oBACZ,KAELyO,YAAA5X,KAAAmO,QAAA,OACNjO,OAAAsB,KAAAkW,WAAAjW,QAAA,SAAAC,MACH,MAAAkW,YAAAlW,QACKkW,YAAWlW,MAAAgW,UAAAhW,WAcXoe,WA5DkB,uBAiEN,IAAOA,WAFf,qCAGW,oBACbC,6BAAe7B,GAAA8B,YAAAC,SACpBjgB,KAAKke,GAAAA,GACLle,KAAKggB,YAAAA,YACLhgB,KAAKigB,QAAAA,QACLjgB,KAAAa,WACHb,KAAAkgB,oMAoBOnd,QAAS2K,KAAQyS,MAAM3d,wBACvBuL,MAAM/N,SACTA,KAAAkgB,UAAApgB,eAAA4N,MACG,MAAC,IAAA4N,MAAA,oDAA4B6E,MAAA,oCAAAzS,KAAA,wBAEhC,MAAAyS,OAAA,GAAAA,MAAAxf,yKAIG,MAAI,IAAK2a,MAAM,yCAAyC6E,MAAA,gCAAAzS,KAAA,uBAG5D,IAAI0S,UAAA7c,gBAAqBvD,KAAAqgB,kBAA6Btd,YAElDO,MAASoK,KAAAA,KAASyS,MAAAA,MAAA3d,SAAsBA,oBACxCL,KAASmB,UAEZgd,mBAAA/c,gBAAAvD,KAAAigB,QAAAM,gBAAAxd,mBACDud,mBAAmBxgB,eAAA4N,2IASVuS,QAAAO,WAAA,eAEGC,MAAOL,UAAAnc,QAAmBX,MAC7Bmd,OAAA,GACFL,UAAAM,OAAAD,MAAA,GAET1S,MAAAmS,UAAAxS,2CAWFqS,6BAAqB3f,UAAA6d,kBAKZvQ,KAAAoC,YACD9P,KAAKkgB,UAAUxS,kGAiBlBA,MAEH,IAAAiT,QAAA3gB,KAAAkgB,UAAAxS,6NAqBE,IAAIK,MAAM/N,wDAGV,IAAI2gB,QAAC3gB,KAAA4gB,YAAoB5d,aAErBX,OAAS,IAAAwe,0BAA6B7gB,KAAMke,GAAGlb,YAAaD,SAE/Dud,mBAAAtgB,KAAAigB,QAAAM,gBAAA3c,IAAAb,8BAEG+d,SAAS/d,kEAET/C,KAAAigB,QAAUM,gBAAe1c,IAAOd,QAASud,wBAG7C,IAAIrd,UAAUqd,mBAAWtd,aAExBE,QAAA,IAAA4c,WAAAhc,MAAA9D,KAAAke,SAEIpa,OAAWA,MAAAhE,eAAA,WACHmD,WACZC,QAAA6d,cAAA9d,UAAAkL,SAEDmS,mBAAgBtd,aAAkBE,mDA7I3B,wBAyJWD,UAAMa,QAAAZ,QAAAY,uGAwBTrC,QAAA,SAAoBY,QAK/BA,OAAUid,aAAWvR,MAAAmQ,IAAgB7b,OAAAW,aAAiBA,aAAeX,OAAS2e,0CAKnEL,QAAAM,gBAAAhe,UAAAa,MAAAZ,QAAAY,MAAAf,QAAAG,QAAAiG,QAEX+X,sBAAuB,MAC1BpT,WAAA,CACG,IAACqT,kBACA,OACDrT,WAAC6S,QAAoBS,mBACrBF,sBAAkB,cAErBjB,QAAAoB,qBACDrhB,KAAAshB,OAAOnf,MAAOY,QAAYA,QAAAC,YAAAA,YAAA8K,WAAAA,WAAA7K,UAAAA,UAAAC,QAAAA,QAAAb,OAAAA,OAAA6e,qBAAAA,8CAEtBJ,SAAS/d,6BACTV,OAAII,QAAU,WAAE8e,YAAAxe,uCAEfJ,OAAA,WAED,IAAI8d,MAAO1S,MAAGlN,QAAMoD,QAAQ5B,QACxBoe,OAAS,6CAIL1S,MAAQkS,QAAOuB,iBAAY5d,IAAAb,oBAC9B,CAEN,IAAA0e,QAAA5gB,QAAAoD,QAAA5B,QACSof,SAAM,GAClB5gB,QAAiB6f,OAAKe,QAAQ,kFA8kErBC,EAAIhiB,GAEjB,IAAAiiB,GAASzhB,OAAOsB,KAAIkgB,GAEhBE,GAAI1hB,OAAOsB,KAAM9B,MACjBiiB,GAAAhhB,QAAOihB,GAAAjhB,cACH,MACP,IAAAH,EAAA,EAAAA,EAAAmhB,GAAAhhB,OAAAH,IAAA,CAEJ,IAAAkB,KAAAigB,GAAAnhB,sGA/oEe,IAAIqB,UAEHggB,aAAAlB,QAAAmB,YAAA7e,UAAAa,MAAAb,UAAAkG,OAAAtH,QAEGkgB,WAAapB,QAAAmB,YAAW5e,QAAYY,MAAAZ,QAAAiG,OAAAtH,eAChClB,YACAsf,QAAS+B,YAAUngB,QAG9B7B,KAAAigB,QAAAO,WAAA,WACMyB,YAAAlf,QAAA8e,cACVlN,UAAA5R,QAAAgf,6CAyDgB3hB,UAAA8hB,oBAIbxU,UACDK,MAAA/N,YACLA,KAAAkgB,UAAAxS,yRAUetN,UAAsB+hB,2BAI/Bpf,cACAkd,QAAAM,gBAAuB/M,OAAAzQ,cACvBsd,kBAAa7M,OAAAzQ,SAEnB,IAAAqf,eAAApiB,KAAAigB,QAAAuB,iBAAA5d,IAAAb,wPAmBE,IAAIgL,MAAQ/N,4HAQJoF,IAAAua,mBAGA0C,WAAMtU,MAAAkS,QAAqBqC,yBAAEld,KAChCid,WAAA3T,KACF2T,WAAA5gB,QAAA,SAAA8gB,IAAA,OAAAA,GAAAC,sBAAApd,IAAA2F,SAAA,GAAA,wKAsBCgD,MAAI/N,+GAMQyiB,eAAehhB,QAAQ,SAASuB,sBAGnCkd,UAAAld,aAAA,CAEN,IAAAX,OAAA0L,MAAA4S,QAAA5d,QAAAC,YA3TA,OA2TAme,mBACC9e,QACKqgB,UAAQvgB,KAAAE,WAIbqgB,UAAO/hB,cACVX,KAAAigB,QAAA0C,qBAAA3iB,KAAAke,GAAAnb,SAAA,EAAAgI,SACJ6X,sBACWrE,oBAACmE,WAAA/f,OAAA,WAAA,OAAAoL,MAAAkS,QAAA4C,iBAAA9f,qDAWI3C,UAAA0iB,qDAKb/U,MAAI/N,gEAGI,uBAEO,IAAA8Z,cACXrY,QAAA,SAAsBshB,UAEtB,IAAI/f,YAAU+f,SAAMrV,+IAWpBzK,qDAAcD,cAAqBggB,oBAE/B9f,QAAS,IAAA4c,WAzWd,QA2WKzd,OAAA,IAAYwe,0BAAU9S,MAAAmQ,GAAAlb,YAAAD,eACtBkd,QAASoB,2BACTC,OAASnf,MACTY,QAAQA,QACRC,YAAAA,YACD8K,WAAAA,WACJ7K,UAAAA,UACNC,QAAAA,QACHb,OAAAA,sCAWF0d,6BAA4B3f,UAAA6iB,oBAKpBlgB,QAAKgI,aACRgD,MAAA/N,KAEGkjB,OAAKljB,KAAAigB,WACLld,QAAOogB,gMAUP,IAAIC,eAAcF,OAAIriB,QAAcF,OAASuiB,OAAAG,wBAAAzf,IAAAb,eAKzCqgB,gBAAeA,eAAQziB,OACvB2iB,mCAA2B,wBAInBvgB,iBACMwgB,SAAAC,YAAA,CAGjB,GADIN,OAAA3C,gBAAA3c,IAAA2f,UACJ,CACJD,mCAAA,eAUAR,+BAAA/f,2CAIGmgB,OAAOP,qBAAW3iB,KAAcke,GAAAnb,SAAa,EAAAgI,sKAerDgV,6BAA6B3f,UAASqjB,WAKtC,SAAA1gB,QAAA2gB,QAA6B5C,SAAS/d,QAAC/C,KAAA2jB,8CAKlBvjB,UAAAwjB,iDAKb7V,MAAI/N,wFAMJ,IAAIqC,OAAAwhB,UAAJ,aAGYC,MAAQ/gB,kBAEJgL,MAAAsS,kBAAYzc,IAAAb,8BAEhBtB,QAAA,SAAoBshB,aACvBA,SAAArV,MAAAoW,MAAA9gB,YAAA,CAER,IAAA+gB,UAAAlhB,mBAAAE,QAAA+gB,MAAA9gB,YAAA8gB,MAAA7gB,UAAAa,MAAAggB,MAAA5gB,QAAAY,OACU,UAAkB,MAAAkgB,YACnB5hB,eAAQ0hB,MAAWzhB,OAAY0gB,SAAA5C,MAAA4D,UAAAhB,SAAAvgB,oBAIlCyhB,iBACNlW,MAAAkS,QAAAO,WAAA,WAGAne,OAAAqc,6CAOD4C,UACAhO,aAAe4Q,KAAM,SAAGxC,EAAAhiB,OAEvBykB,GAAAzC,EAAA5T,WAAAgC,IAAAvC,SAEF6W,GAAA1kB,EAAAoO,WAAAgC,IAAAvC,SACL,OAAA,GAAA4W,IAAA,GAAAC,wGAUuBhkB,UAAase,mNAgBlC3b,SAEA,IAAAshB,cAAmB,SACrBrkB,KAAAqgB,kBAAA1T,IAAA5J,WACKshB,cAAA,GACNA,6HA/gBqB,6BAkjBA,oBACbC,0BAAyBvG,SAAG7Q,OAAA8Q,aACjChe,KAAK+d,SAAAA,SACL/d,KAAKkN,OAAAA,OACLlN,KAAKge,YAAAA,YACLhe,KAAKa,WACLb,KAAKukB,gBAAkB,IAAE5gB,IACzB3D,KAAKwhB,iBAAkB,IAAK7d,IAC5B3D,KAAKqjB,wBAAsB,IAAA1f,IAC3B3D,KAAKugB,gBAAiB,IAAG5c,IACzB3D,KAAKwkB,cAAe,IAAA1K,IACpB9Z,KAAKykB,gBAAkB,EACvBzkB,KAAKqhB,mBAAA,EACLrhB,KAAK0kB,oBACL1kB,KAAK2kB,kBACL3kB,KAAK4kB,aACR5kB,KAAA6kB,8OAmBG9hB,QAAYgI,SAAA/K,KAAA8kB,kBAAA/hB,QAAAgI,+HAQH4Z,eAAEljB,QAAA,SAAA8gB,IACJA,GAAA1hB,QAAAY,QAAA,SAAAY,QACIA,OAAQ2e,QAClBngB,QAAAsB,KAAAE,qDAcLiiB,0BAAuBlkB,UAAa2kB,yBAK/BzF,YAAAU,oRAyBLsE,0BAAyBlkB,UAAE4kB,+BAKnBzC,GAAIvC,8DAGI,EAAA,gBAEI,EACJxf,EAAKwR,MAAOxR,GAAC,EAAAA,IAAA,KAEhBykB,cAAAjlB,KAAA2kB,eAAAnkB,GACJ,GAAAR,KAAAkN,OAAA1G,gBAAAye,cAAAjF,YAAAA,aAAA,CACIhgB,KAAO2kB,eAAAjE,OAAAlgB,EAAA,EAAA,EAAA+hB,IACJ2C,OAAC,EACR,OAGIA,OACRllB,KAAA2kB,eAAAjE,OAAA,EAAA,EAAA6B,kGAcL+B,0BAAuBlkB,UAAa6d,kBAK/BqB,YAAAU,aAEH,IAAAuC,GAAAviB,KAAA0kB,iBAAApF,4IAkBGA,YAAA5R,KAAAiT,0GAYL2D,0BAAuBlkB,UAASse,iBAKtBY,YAAQvU,SACd,IAAIgD,MAAC/N,QACDsf,iBAGAiD,GAAIviB,KAAKmlB,gBAAS7F,kBAClBkB,WAAS,iBACL4E,wBAAqB5R,OAAY+O,GAAGvC,oBACvCjS,MAAA2W,iBAAApF,aAED,IAACmB,MAAA1S,MAAA4W,eAAyB1gB,QAAcse,IAC9C9B,OAAA,sKAcF,SAAAvC,IAAA,OAAAle,KAA0B0kB,iBAAUxG,2EAS5Bnb,aAEAsf,WAAW,IAAMvI,6GAMTtZ,EAAI,EAAEA,EAAGgB,KAAKb,OAAAH,IAAgB,UAE1B6kB,cAAiB7jB,KAAEhB,IAAA8e,oBACtB,CAER,IAAAiD,GAAAviB,KAAAmlB,gBAAAG,MACJ/C,IACMF,WAAW5T,IAAA8T,yFAqBCxf,QAAS2K,KAAM5J,wBACnBf,SAAK,CAEnB,IAAAwf,GAAAviB,KAAAmlB,gBAAA7F,aACD,GAAOiD,UACTA,GAAA5B,QAAA5d,QAAA2K,KAAA5J,4EAoBMwb,YAAWvc,QAAQ2gB,OAAa6B,iBAChCC,cAAQziB,cAGR0iB,QAAiB1iB,QAAA4c,iBACjB8F,SAASA,QAAOC,cAAA,SACRA,eAAC,UACRnG,YAAA,wKAmBDgD,IACIA,GAACkB,WAAA1gB,QAAoB2gB,+KAsBjCY,0BAA0BlkB,UAAAulB,+BAKjB5iB,QAAAe,OACJA,MACQ9D,KAAKwkB,cAAc7X,IAAI5J,WACxB/C,KAACwkB,cAAc/V,IAAO1L,SAC1B+d,SAAY/d,uOAqBhB,GAAIyiB,cAAKziB,SAAT,KAKIwf,GAAKjD,YAAAtf,KAAAmlB,gBAAkC7F,aAAgB,KAC1DiD,GACHA,GAAAU,WAAAlgB,QAAAgI,wEANM/K,KAAI4lB,mBAAA7iB,QAAAgI,4EA0BJuU,YAAAvc,QAAsByc,aAAKzU,cAC7B8a,uBAAA1jB,KAAAY,SACJA,QAAA4c,qKAsBAL,YAAAvc,QAAA2K,KAAAyS,MAAA3d,8dA6BmBpC,UAAA0lB,gCAIbC,sBACAhY,MAAO/N,KAEXkY,SAASlY,KAAQkN,OAAUiL,MAAA4N,iBAAwBC,qBAAA,GACrD9N,SAAAzW,QAAA,SAAAsB,SAAA,OAAAgL,MAAAkY,kCAAAljB,0WAkBctB,QAAO,SAAAY,QAIVA,OAAA2e,OACF3e,OAAA4hB,kBAAA,yGAgBNlhB,6JAUkB3C,UAAU8lB,uCAIpBlmB,gBACDmmB,QAAU,SAAAC,YACbrY,MAAAlN,QAAAF,OACF,OAAA4d,oBAAAxQ,MAAAlN,SAAA8B,OAAA,WAAA,OAAAyjB,mDAWchmB,UAAAyiB,uCAKb9U,MAAQ/N,aAEC+C,QAAuB4c,4DAGxBA,cAAIN,2BACDC,YAAA,MACNwG,uBAAA/iB,SAED,IAACwf,GAAAviB,KAAAmlB,gBAA4BM,QAAQnG,aAC5CiD,IACQA,GAAMJ,kBAAgBpf,SAG3B/C,KAAC4lB,mBAAsB7iB,QAAA0iB,QAAiBC,eAEzC1lB,KAAAkN,OAAA3G,eAAAxD,iCACL/C,KAAA2lB,sBAAA5iB,SAAA,oJAUmB3C,UAAAimB,eAIbrC,iBACAjW,MAAK/N,UACA,IAALgkB,cAA0BA,aAAG,GAEjC,IAAInjB,cACAb,KAAKukB,gBAAe7V,+GAEhB6V,gBAAe3Q,cAElB6Q,iBAAAzkB,KAAAsmB,uBAAA3lB,OACJ,IAAA,IAAAH,EAAA,EAAAA,EAAAR,KAAAsmB,uBAAA3lB,OAAAH,IAAA,UAESR,KAAAsmB,uBAA2B9lB,+BAI7BmkB,eAAehkB,SAClBX,KAAAqhB,oBAAArhB,KAAA6lB,uBAAAllB,QAAA,KAEG4lB,0BAECvmB,KAAAwmB,iBAAAD,WAAAvC,aAER,QACI,IAAAxjB,EAAA,EAAAA,EAAA+lB,WAAA5lB,OAAAH,IACI+lB,WAAY/lB,WAKpB,IAAAA,EAAA,EAAAA,EAAAR,KAAA6lB,uBAAAllB,OAAAH,IAAA,CAEI,IAAAuC,QAAA/C,KAAsB6lB,uBAAYrlB,GAClCR,KAAA6iB,iBAAuB9f,YAG5B/C,KAAIqhB,mBAAmB,4CAEnBwE,uBAAsBllB,OAAA,OACtBikB,UAAKnjB,QAAa,SAAM8a,IAAA,OAAAA,YACxBqI,kBACIC,cAAAlkB,OAAoB,gBAEnBX,KAAA6kB,mBACDA,iBACHhkB,QAAAF,OACJ4d,oBAAA1d,SAAA8B,OAAA,WAAA8jB,WAAAhlB,QAAA,SAAA8a,IAAA,OAAAA,mFAWenc,UAAA4hB,mJAYpBsC,0BAAsBlkB,UAAaomB,0BAK3BD,WAAcvC,6JAad0C,oBAAsB,IAAC/iB,iCAIvBgjB,oBAAqB,IAAG7M,uBACpBrY,QAAmB,SAAKqJ,0BAC3B2D,IAAA3D,MAGD,8EAAQ8b,IAAO,EAACA,IAAQC,qBAAClmB,OAAAimB,iJAS7BE,aAAaC,aAAkBC,mBAAahnB,KAAAsmB,wBAExCW,gBAAgB,IAAAtjB,IAEhBnD,EAAA,eACDiB,QAAA,SAAAylB,MAAAC,MAEC,IAAAC,qBAAmB5mB,wCAEnB0mB,MAAAzlB,QAAA,SAAuBqJ,MAAM,OAAAgW,SAAAhW,KAAAsc,mBAGjC,IAAAC,iBAEIC,iBAAmB,IAAAxN,IAEnByN,4BAAW,IAAqBzN,IAC5B0N,IAAO,EAAAA,IAAIxnB,KAAQ6lB,uBAAellB,OAAA6mB,MAAA,WAElCzkB,QAAA/C,KAAA6lB,uBAA8B2B,MAEC7H,gBAC9B8F,QAAAC,8BACIvjB,KAAAY,0BACD0L,IAAA1L,SACH0iB,QAAAjG,aACJxf,KAAAkN,OAAAiL,MAAApV,QA10CM,qBA00CN,GAAAtB,QAAA,SAAA2D,KAAA,OAAAkiB,iBAAA7Y,IAAArJ,OAGDmiB,4BAA4B9Y,IAAA1L,cAK5B0kB,gBAAgB,IAAA9jB,IAEhB+jB,aAAcX,aAAcC,mBAAoBpnB,MAAM+nB,KAAAL,gCACvD7lB,QAAA,SAAAylB,MAAAC,MAEC,IAAAC,qBAA+B5mB,8CAE3BiB,QAAI,SAASqJ,MAAA,OAAsBgW,SAAAhW,KAAesc,0BAEnDjlB,KAAA,WACH2kB,aAAarlB,QAAQ,SAAUylB,MAAOC,MAElC,IAAIC,UAA+BH,gBAAgBrjB,IAAIujB,MACvDD,MAAMzlB,QAAQ,SAAUqJ,MAAQ,OAAOyW,YAAYzW,KAAMsc,eAE7DM,aAAajmB,QAAQ,SAACylB,MAAUC,8CAGhCD,MAAUzlB,QAAM,SAAAqJ,MAAA,OAAAyW,YAAAzW,KAAAsc,eAEhBC,cAAA5lB,QAAoB,SAAMsB,SAAAgL,MAAA8U,iBAAA9f,qBAG1B6kB,sCAGIC,IAAI7nB,KAAM2kB,eAAgBhkB,OAAA,EAAAknB,KAAA,EAAAA,MAAA,CAEtB7nB,KAAA2kB,eAAgBkD,4BACE7D,aAAEviB,QAAA,SAAAqiB,mEAKhB3hB,KAAOE,cACPikB,uBAAiB3lB,OAAA,KAEpB8kB,QAAA1iB,QAAA4c,yDAGDtd,OAAAqc,wFAOA1K,eAAkCyT,gBAAe7jB,IAAAb,SAEjDgR,eAAOkT,gBAAArjB,IAAAb,8MAWV+kB,eAIG,wKADAC,eAAM5lB,KAAAE,WAKTyhB,MAAA5C,yNAWDhM,YAAYb,UAAA5S,QAAgB,SAAQgT,IAAU,OAAOA,GAAEuT,yBAAyB,IAChFC,aAAYvU,OAAA3Q,QAAcmS,YAAQb,eAE9BrD,OAASkE,YAAcA,YAAY7S,OAAAA,OAAAU,QAAAA,4BACzBZ,KAAQ6O,2IAEVmC,cAAQ1R,QAAA,SAAsBymB,UAAAnlB,mBAE9B7C,OAAAsB,KAAA0mB,oBACHvnB,OAAA,CAEJ,IAAAwnB,SAAAzB,oBAAA9iB,IAAAb,SACFolB,UACSzB,oBAAe7iB,IAAQd,QAAUolB,SAAW,IAAArO,KAEhDN,MAAK/X,QAAS,SAAMC,MAAW,OAAAymB,SAAA1Z,IAAA/M,uBAG9B0R,eAAQ3R,QAAA,SAAAymB,UAAAnlB,aAEZyW,MAAAtZ,OAAAsB,KAAA0mB,WAEFE,OAAAC,qBAAAzkB,IAAAb,SACJqlB,QACNC,qBAAAxkB,IAAAd,QAAAqlB,OAAA,IAAAtO,yFAMqBnZ,OAAS,CAE3B,IAAA2nB,YACAC,qBAAiB9mB,QAAU,SAAAyT,aAC9BoT,SAAAnmB,KAAA,IAAA+S,YAAAlS,YAAA,4KAIGhD,KAAAgiB,YAAAsG,cAGAE,sBAAoB,IAAQ7kB,wBAExB,IAAoBA,uBACdlC,QAAA,SAAsBqiB,OAEjC,IAAA/gB,QAAA+gB,MAAA/gB,QACHklB,aAAetb,IAAQ5J,oDAEfgL,MAAA0a,sBAAyB3E,MAAAzhB,OAAAid,YAAAwE,MAAA5O,YAAAsT,yCAG7B/mB,QAAgB,SAAQY,YAEpBU,QAAUV,OAACU,QAEhBgL,MAAA2a,oBAAA3lB,SAAA,EAAAV,OAAAid,YAAAjd,OAAAW,YAAA,mCAECO,gBAAeilB,sBAAqBzlB,YAAgBZ,KAAAwmB,YACpDA,WAAOjK,mEAKP,OAAAkK,uBAAuB9d,KAAA4b,oBAAsB2B,sCAG7B,IAAC1kB,IAElBklB,sBAAAC,cAAA9oB,KAAAkN,OAAAqa,4BAAAc,qBAAAvnB,oBAAAc,mCAECgnB,uBAAyB9d,KAAA4b,oBAAA2B,uBAC7BU,aAAqB5mB,KAAA2I,8CAKTrJ,QAAG,SAAcylB,MAASC,wIAGlC1lB,QAAiB,SAAKqJ,kEAKtBge,cAAajlB,IAAGiH,KAAA6R,YAAAqM,KAAAC,QAGpB,IAAAC,6BAIIC,2DACQ1nB,QAAA,SAAwBqiB,mBAClBA,MAAC/gB,QAAUV,OAAYyhB,MAAEzhB,OAAO6S,YAAmB4O,MAAA5O,4BAGzDvI,IAAA5J,SAAoB,IACpB4jB,oBAAOha,IAAA5J,gBACVV,OAAA+mB,UAAA,WAAA,OAAAzU,UAAA5R,QAAAmS,YAAAgH,+BAEG7Z,OAAAgnB,kBAAwBnU,YAAA7R,gBACxB0kB,eAAA5lB,KAAoBE,YAIpBinB,sBAAsBH,wCACtBI,oBAAiB7a,KAAU,EAAE,SAEzBtJ,IAAIrC,4BAGAqC,IAAMoe,YAAA,CAEV,IAAAgG,eAAqBD,oBAAE3lB,IAAAwB,KAC1B,GAAAokB,eAAA,CACDF,sBAA+BE,eAClC,MAEGC,aAActnB,KAAMiD,KAEpBqkB,aAAAhoB,QAAqB,SAAKiiB,QAAA,OAAA6F,oBAAsC1lB,IAAA6f,OAAA4F,yCAG/Dvb,MAAA2b,gBAAArnB,OAAAid,YAAApK,YAAAsT,sBAAAmB,kBAAAC,aAAAd,oDAEDQ,wBAA0BH,qCAC1BD,YAAI/mB,KAAaE,YAEhB,CAEJ,IAAAwnB,cAAA9b,MAAAyT,iBAAA5d,IAAA0lB,uBACJO,eAAAA,cAAAlpB,SACI0B,OAAAynB,aAAAvL,oBAAAsL,gBAED9B,eAAiB5lB,KAAAE,cAIjB4f,YAAWlf,QAAKmS,YAAQ+G,YACxB5Z,OAAI+mB,UAAA,WAAwB,OAAUzU,UAAA5R,QAAAmS,YAAAgH,YAI3C6N,WAAA5nB,KAAAE,0CAEQ0lB,eAAQ5lB,KAAUE,qBAKrBZ,QAAI,SAAcY,YAErB2nB,kBAAAL,kBAAA/lB,IAAAvB,OAAAU,SACF,GAAAinB,mBAAAA,kBAAArpB,OAAA,4GASYc,QAAO,SAAGY,QACpBA,OAAAynB,aACFznB,OAAA4nB,iBAAA5nB,OAAAynB,qCASC,IAAAI,IAAW,EAACA,IAAO7C,cAAE1mB,OAAiBupB,MAAA,aAIlCzE,qCAA+B9F,6BAC/B5c,uFAWC2L,KAAA,CAED,IAAIyb,qBAAuBhO,gBAAYvY,IAAMb,SAC7ConB,sBAAoBA,qBAA6BxpB,sFAItBX,KAAAkN,OAASiL,MAAApV,QAAgBiE,uBAAA,GAC/CojB,EAAA,EAAAA,EAAAC,qBAAA1pB,OAAAypB,IAAA,CAER,IAAAE,eAAAnO,gBAAAvY,IAAAymB,qBAAAD,2CAEGvpB,QAAgBsB,KAAA8C,MAAQpE,QAAOypB,qBAK/BC,cAAK1pB,QAAiByT,OAAS,SAAAzU,GAAA,OAAAA,EAAAgkB,YAClC0G,cAAA5pB,OACJ6pB,8BAAAxqB,KAAA+C,QAAAwnB,eAGDvqB,KAAY6iB,iBAAkB9f,oDAKlBtB,QAAQ,SAAMY,cAClBxB,QAAMsB,KAAQE,eACfM,OAAA,WACHN,OAAWqc,UAER,IAAA+B,MAAY1S,MAAAlN,QAAAoD,QAAA5B,QACrB0L,MAAAlN,QAAA6f,OAAAD,MAAA,kCAWF6D,0BAAuBlkB,UAASqqB,6BAKxBnL,YAAWvc,SAEf,IAAIshB,cAAK,EAELoB,QAA4B1iB,QAAK4c,qBACjC8F,SAAAA,QAAmBC,gBACnBrB,cAAK,GACLrkB,KAAAwhB,iBAAoB7U,IAAA5J,WACxBshB,cAAY,GACdrkB,KAAAqjB,wBAAA1W,IAAA5J,8MAcF,SAAAP,UAAAxC,KAA0B4kB,UAAUziB,KAAAK,+LA0B5BO,QAAI2nB,iBAAwBpL,YAAKtc,YAAA2nB,iDAGhC,KAEAC,sBAAA5qB,KAAAqjB,wBAAAzf,IAAAb,iCAEGlC,QAAA+pB,+CAKe5qB,KAAMwhB,iBAAA5d,IAAAb,2BACN,2BAEA4nB,cAllDhB,QAklDgBA,4BACHlpB,QAAW,SAAEY,QACtBA,OAAA2e,SAEV6J,sBAAAxoB,OAAAW,aAAAA,cAEUnC,QAAGsB,KAAQE,+BAIHW,uBACXnC,QAAYyT,OAAA,SAAAjS,QACb,QAAAid,aAAAA,aAAAjd,OAAAid,gBAEAtc,aAAQA,aAAAX,OAAAW,uLAuBX8Q,YAAUoB,YAAUnS,QAEpB+nB,kBAAc5V,YAAA8G,yBAA4B5Y,EAAAkc,YAE1CyL,kBAAoB7V,YAAU8G,yBAAiB5Y,EAAAJ,0FAK/C0nB,iBAAuB3nB,UAAW+Q,YAE9BjT,QAAI0C,gBAAUilB,sBAA4BzlB,YAE3BioB,OAAAtC,oBAAgB3lB,QAAA2nB,iBAAAI,kBAAAC,kBAAA7V,YAAAhS,SAC9BzB,QAAA,SAAAY,QAED,IAAA4oB,WAAqB5oB,OAAA6oB,gBACtBD,WAAAE,eACLF,WAAAE,gBAEG9oB,OAAUqc,UACP7d,QAAAsB,KAAAE,wEAMVuI,QAD2BuH,GAAA/H,mHAyBrBkV,YAAcpK,YAAYsT,sBAAQmB,kBAAAC,aAAAd,mJAWlCsC,eAAA,IAAoBtR,IAEpBuR,cAAcnW,YAAQb,UAAc7Q,IAAA,SAAA8nB,yBAEhCvoB,QAAOuoB,oBAAIvqB,2EAIf,GAAI0kB,SAAAA,QAAkBhG,4BACb,IAAA3e,oBAAwBC,oBAAoBuqB,oBAAAxkB,SAAAwkB,oBAAA5kB,WA0kBhE7F,4DAtkBe+F,iBAskBf/F,SAtkBkD2nB,sBAAgB5kB,IAAAb,UAAAqc,oBACpD5b,IAAA,SAAA3D,GAAA,OAAAA,EAAAqrB,qEAglBHrqB,QAAgC0qB,kBACnC,IAAA/qB,EAAA,EAAAA,EAAAK,QAAAF,OAAAH,IAAA,KAEG6B,OAAAxB,QAAiBL,GACpB6B,kBAAAvB,oBAAA0qB,sBACJC,0BAAAppB,OAAAxB,QAAA0qB,0GAjlBW,QAAAG,GAAU3oB,SAAG2oB,GAAA3oB,UAAkBA,oFAO/BuH,UAAAqhB,mBAA+B5d,MAAIb,OAAAa,MAAAiQ,YAAmBjb,EAAAuoB,oBAAAhhB,UAAAtJ,UAAAgB,YAEzDK,OAAA0L,MAAAyQ,aAAA8M,oBAAAhhB,UAAA1D,oBAGG0kB,oBAAoBjY,aAAIsW,mBACxByB,eAAc3c,IAAA1L,SAEjB2nB,iBAAA,CAEF,IAAAkB,cAAA,IAAA/K,0BAAAvB,YAAAtc,YAAAD,SACH6oB,cAAkBC,cAAkBxpB,QAChCypB,kBAAsB3pB,KAAAypB,eAEvB,OAAAvpB,oDAGCkB,gBAASwK,MAAAsV,wBAAmChhB,OAAAU,YAAAZ,KAAAE,QAChDA,OAAOM,OAAU,WAAY,gBA6UVa,IAAAC,IAAAK,2CAGPH,sBACJH,IAAAI,IAAcH,KACjB,CACD,GAAIsoB,cAAcprB,OAAM,CAEvB,IAAA8f,MAAAsL,cAAA9nB,QAAAH,OACJioB,cAAArL,OAAAD,MAAA,GAEA,GAAAsL,cAAAprB,QACD6C,IAAAgQ,OAAmB/P,4BAKXD,IAAAC,KACH,CACD,GAAIsoB,cAAcprB,OAAM,CAEvB,IAAA8f,MAAAsL,cAAA9nB,QAAAH,OACJioB,cAAArL,OAAAD,MAAA,GAEgB,GAAdsL,cAAcprB,eACxB6C,IAAAC,0BAtWoCuoB,CAAAje,MAAAsV,wBAAAhhB,OAAAU,QAAAV,gCAEfZ,QAAa,SAAWsB,SAAW,OAAA+d,SAAA/d,2GAIjDkpB,oBAAuBxqB,QAAA,SAAmBsB,SAAE,OAAgBwe,YAAAxe,0BAC5D4R,UAAcb,YAAAoB,YAAAgH,2NAoBd,OAAA5R,UAAWvJ,OAAAA,EACbf,KAAAkN,OAAAgf,QAAAhX,YAAAnS,QAAAuH,UAAA4K,YAAApO,SAAAoO,YAAAxO,MAAAwO,YAAAvO,OAAAC,iBA6CO,IAAA9F,oBAA0BC,oBAAamU,YAAapO,SAASoO,YAAAxO,QAElE4d,0BAtvCkB,6BAwvCCvjB,oBACd8f,0BAAsBvB,YAAMtc,YAAAD,SACjC/C,KAAKsf,YAAAA,YACLtf,KAAKgD,YAAYA,YACjBhD,KAAK+C,QAAAA,QACL/C,KAAKmsB,QAAQ,IAAGrrB,oBAAMC,oBACtBf,KAAKosB,qBAAc,EACnBpsB,KAAKqsB,oBACRrsB,KAAA6jB,WAAA,6GAUoBzjB,UAAAyrB,uBAIXxpB,YACF0L,MAAM/N,KACPA,KAAAosB,sBAEHpsB,KAAKmsB,QAAA9pB,OACLnC,OAAKsB,KAAAxB,KAAAqsB,kBAAyB5qB,QAAW,SAAA0e,OACzCpS,MAAAse,iBAA0BlM,OAAM1e,QAAS,SAAAe,UAAA,OAAAJ,eAAAC,OAAA8d,WAAA/c,EAAAZ,4GAK7C,KAA0Bwe,QAAU,sDAQpC,WAAA,OAAAhhB,KAA0BmsB,+DAS1B,SAAA9oB,WAAA,KAAoCA,UAAgBA,qCAK/BjD,UAAA6pB,0BAIb5nB,YACH0L,MAAA/N,KAEDH,EAAiBG,KAAqB,QACxCH,EAAAysB,sLAWFzL,0BAA0BzgB,UAAAmsB,6HAYLnsB,UAAAuC,gBAInB4Z,gGAUmBnc,UAAAqC,iBAInB8Z,kGAUmBnc,UAAAgpB,mBAInB7M,gDAIFvc,KAAAmsB,QAAA/C,UAA0B7M,2iBA+CAnc,UAACse,qCAK3B1e,KAAAmsB,QAAAzN,qDAQA,YAAA1e,KAAAghB,QAA0BhhB,KAASmsB,QAACpN,mCAKd3e,UAAA+e,8KAsBtB0B,0BAAqBzgB,UAAAksB,yBAKhBnpB,WAEL,IAAOtD,EAAAG,KAA0B,QAChCH,EAAAysB,yEAzNsBvrB,wEA4T1ByrB,aAAAzpB,QAAAe,kHAcO+kB,sBAAoB4D,UAAAvf,OAAAgL,SAAAwU,gBAAAC,wCAGhBlrB,QAAS,SAAGsB,SAAA,OAAA6pB,UAAAzqB,KAAAqqB,aAAAzpB,kDAGRtB,QAAQ,SAAY+X,MAASzW,6BAGjCtB,QAAU,SAAUC,UAEhBoC,MAAAkE,OAAetG,MAAKwL,OAASvC,aAAA5H,QAAArB,KAAAirB,cAG5B7oB,OAAsB,GAAjBA,MAASnD,SACxBoC,QAAA4c,cAAAD,2DAIH+M,UAAO5oB,IAAAd,QAAeiF,kIAYlB+e,aAAc8F,MAAC3F,OAEnB,IAAI4F,QAAS,IAAKnpB,IAElB,8DAAkB,GAAdujB,MAAAvmB,6DAOJosB,aAAiB,IAAMppB,iBA6BlBlC,QAAA,SAAAqJ,MAEL,IAAOqc,cA1BC6F,QAAIliB,UACJA,sBAGJ,IAAIqc,KAAO4F,aAAYnpB,IAAEkH,cAErB,OAAOqc,gBAEFrc,KAAQ0Y,WAcjB,OAXC2D,yBAAAzD,2BAIAuJ,UAISD,QAAAtJ,QAEVqJ,aAAWlpB,IAAAiH,KAAYqc,MACnBA,KAIO6F,CAAAliB,MAClBqc,OAAA8F,4HA6BOlqB,QAAImqB,UACJnqB,QAAKmqB,UAASze,IAAA2Y,eAEb,CAEJ,IAAA+F,QAAApqB,QAAAqqB,mBACJD,mHAYOpqB,QAAImqB,UACJnqB,QAAImqB,UAASG,OAAAjG,eAEZ,CAER,IAAA+F,QAAApqB,QAAAqqB,iSAsEG,IAAIE,UAAUjF,qBAAAzkB,IAAAb,aACVuqB,UACH,OAAA,MAEGC,SAAA7G,oBAA+B9iB,IAAEb,gBACpCwqB,SACDD,UAAA7rB,QAAqB,SAAO6B,MAAS,OAAA,SAAAmL,IAAAnL,+GC18ET,oBACnBkqB,gBAAAzP,SAAoB9M,QAAUhP,YACnC,IAAI8L,MAAC/N,KACLA,KAAK+d,SAAAA,SACL/d,KAAKiR,QAAAA,aACDwc,sBACF3I,kBAAA,SAAA/hB,QAAAgI,WACL/K,KAAA0tB,kBAAA,IAAApJ,0BAAAvG,SAAA9M,QAAAhP,wQAsBQ0rB,YAASrO,YAAAU,YAAAtS,KAAAP,cAEVygB,SAAUD,YAAM,IAAAjgB,KAEhBiT,QAAO3gB,KAAAytB,cAAqBG,cAC5BjN,QAAU,KAET9e,UAEGiO,IAAwB7C,kBAAWjN,KAAAiR,QAAA,SAAApP,QAC1C,GAAAA,OAAAlB,OACI,MAAA,IAAA2a,MAAkB,0BAA6B5N,KAAM,0DAAS7L,OAAAgN,KAAA,qCHlC3E,OAAA,IAAA2O,iBAAgB9P,KAAkBoC,uHG8C9B0d,gBAAUptB,UAAa6d,qGAavBuP,gBAAUptB,UAAase,qYA6CvB8O,gBAAUptB,UAAgBytB,sJAsBlBvO,YAAKvc,QAAgB+qB,SAAYhqB,UACpC,KAAAgqB,SAAAhoB,OAAA,GAAA,KACIqM,GAAA4b,qBAAAD,UAAA5P,GAAA/L,GAAA,GAAA6b,OAAA7b,GAAA,GAEJyM,KAAA,MACH5e,KAAAiuB,gBAAAjqB,QAAAka,GAAAnb,QAAAirB,OAAApP,yHAsBGU,YAAAvc,QAAAT,UAAA4rB,WAAA1rB,UAEH,GAAA,KAAAF,UAAAwD,OAAA,GAAA,sOAUM1F,UAAgBimB,eAIjBrC,qHAIQwJ,gBAAuBptB,UAAC,eAInC,WACD,OAAAJ,KAAA0tB,kBAAA,4DAIHS,cAAgB,IAKhBX,gBAAAptB,UAAA8lB,gGAjM4B,GCI5BkI,eAAA,+BAEqB,4CAGU,oBACtBC,6BAAgBC,SAAAC,MAAAC,UAAAC,OAAAC,QAAAC,UAAAC,WACrB,IAAI7gB,MAAQ/N,KACZA,KAAKsuB,SAASA,SACdtuB,KAAKuuB,MAAAA,MACLvuB,KAAKwuB,UAAYA,UACjBxuB,KAAKyuB,OAAAA,OACLzuB,KAAK0uB,QAAUA,QACf1uB,KAAK2uB,UAAYA,UACjB3uB,KAAK4uB,UAAWA,UACnB5uB,KAAA6uB,WAAA,wDAID7uB,KAAA8uB,SAAA,SAA6BhsB,GAAA,OAAUiL,MAAKghB,gBAAAjsB,wCAKhB1C,UAAK6E,2BAoIhBlC,QAAAe,WAEbkrB,KAAKC,kBAAiBlsB,QAAM,IAAA6Y,OAEhC6E,MAAA,EACAuO,KAAOruB,SACV8f,eAkGe3c,MAAMorB,oBAEV,EACP1uB,EAAA,EAAAA,EAAAsD,MAAAnD,OAAAH,IAAA,CAEJ,IAAA2uB,EAAArrB,MAAAgC,OAAAtF,kCAvGA4uB,CAAAJ,KAAA,KAAA,oOApIGhvB,KAAAqvB,WAAAC,KAAAC,oKAeA,WAAAC,mBAA6BxvB,KAASsuB,SAACtuB,KAAWuuB,MAAA,wEAShDkB,2GAIFC,kBAAA1vB,KAAAsuB,SAA6B,QAAU,IAAWtuB,KAAA2vB,UAAA,KAAAlP,2DAQlD,WAAA,OAAAzgB,KAAA2vB,2EASQptB,WAEAqtB,UAAWrtB,MAAGstB,wBAAAP,KAAAC,MAEpBO,YA3EY,IA2EZvoB,WAAAhF,MAAAutB,YAAAC,0KASa3vB,UAAA6e,kBAIbjf,KAAA6uB,+CAIFmB,wBAA4BhwB,KAACsuB,SAAUtuB,KAAO8uB,UAAA,kCAK/B1uB,UAAAse,mBAIb1e,KAAAiwB,aAEDjwB,KAAAiwB,YAAA,uCAoED,WAAShB,kBAAOlsB,QAAA,eAIZ0d,MAAAyP,uBAA+BC,OAAQziB,SAC1C+S,OAAA,EAAA,CACJ0P,OAAAzP,OAAAD,MAAA,mIAhLkC;;;;;;;0JA2L3B2P,sBAAuBrtB,QAAMe,WAEhCkrB,KAAAC,kBAAAlsB,QAAA,IACD,OAAAisB,KAAO/qB,QAAA,KAAA,8FAYNisB,uBAAAC,OAAAE,aACD,IAAA,IAAS7vB,EAAC,EAAAA,EAAA2vB,OAAAxvB,OAAAH,IACb,GAAA2vB,OAAA3vB,GAAAyD,QAAAosB,cAAA,+LAuBOX,kBAAe3sB,QAAa2K,KAAM5J,MAAC2c,uCAG3B,YAAM,KAEV6P,SAAQvtB,QAAW4C,MAAMjE,SAC5B4uB,SAAA3vB,OAAA,CAEG,IAAAwvB,OAAWG,SAASvkB,MAAA,KAC/BokB,OAAA1P,OAAA3c,8JC9OY,4BACsB,oBACtBysB,mBAAgBxtB,QAAAuH,UAAAkmB,cAAAhC,UAAAC,OAAA9nB,OAAA8pB,cACrBzwB,KAAK+C,QAAAA,QACL/C,KAAKsK,UAAUA,UACftK,KAAKwwB,cAAgBA,cACrBxwB,KAAKwuB,UAAAA,UACLxuB,KAAKyuB,OAAQA,OACbzuB,KAAKywB,aAAeA,aACpBzwB,KAAK0wB,cACL1wB,KAAK2wB,eACL3wB,KAAK4wB,iBACL5wB,KAAK6wB,UAAA,EACR7wB,KAAA8wB,oKAcD,SAAAvU,IAAAvc,KAAmB2wB,YAAUxuB,KAAMoa,yCASnC,SAAAA,IAAAvc,KAAmB0wB,WAAUvuB,KAAAoa,yGAaVnc,UAAKse,mBAIpB1e,KAAKkf,OACDlf,KAAC+wB,QAAa,IAElB/wB,KAAK+wB,OAAA,EACP/wB,KAAAgxB,QAAAtS,2GAIF1e,KAAA4wB,sCAKmBxwB,UAAM6wB,4EAKzBjxB,KAAA0wB,kCAKStwB,UAAiB8wB,8EAK1BlxB,KAAA2wB,mCAKmBvwB,UAAK6e,kBAIpBjf,KAAKkf,OACDlf,KAAC+wB,QAAa,mWAiCP3wB,UAAA8e,gBAIX,KAAIlf,KAAC+wB,QAAa,GAAlB,MAEIA,OAAK,EAEX/wB,KAAA+C,oFASY3C,UAAcye,gBAIxB7e,KAAKkf,OACPlf,KAAAmxB,oDAIFnxB,KAAAgxB,QAAAI,6BAKiBhxB,UAAQ0e,6BAKzB9e,KAAAgxB,QAAAlS,4BAKgB1e,UAAA4e,gCAKhBhf,KAAA6e,2BAKSze,UAAe2e,4DAMxB/e,KAAAgxB,QAAA/rB,4BAKmB7E,UAAIixB,4JA5LJ,+CAyMnBd,mBAAmBnwB,UAAEksB,yBAKnBnpB,sHAIFmuB,QAAA3wB,OAAmB,sBAKHP,UAAA+qB,6CAKRjM,0CAGmB,KAEhBqS,WAAAvxB,KAAA+wB,QAAA,EACN7wB,OAAAsB,KAAAxB,KAAAywB,cAAAhvB,QAAA,SAAAC,MACmB,UAAfA,OACPsG,OAAAtG,MAAA6vB,WAAAxjB,MAAA0iB,aAAA/uB,MAAAiJ,aAAAoD,MAAAhL,QAAArB,yDAjO6B,qBCVA,SAAA6Y,iBAEtBiX,kBAAWzuB,QAAAiF,QAChB,IAAA+F,MAAYwM,OAAC3Z,KAAAZ,OAAAA,KAKjB,OAJC+N,MAAAhL,QAAAA,kGAIDgL,uBAPUyjB,kBAAgBjX,0BAYbna,UAAa8e,gCAKnBlf,KAAAyxB,eAAAzxB,KAAA0xB,kBAEL1xB,KAAAyxB,eAAA,2GAIFlX,OAAAna,UAAkB8e,KAAAte,KAAUZ,0BAKdI,UAAAye,0BAIE7e,KACZA,KAAO0xB,kJAKXnX,OAAAna,UAAkBye,KAAAje,KAAUZ,0BAKdI,UAAAse,uBAIN3Q,MAAI/N,KACJA,KAAI0xB,yBAEHlwB,KAAAxB,KAAA0xB,iBAAAjwB,QAAA,SAAAC,UAEGoC,MAAoBiK,MAAqB,gBAAArM,MAC5CoC,MACFiK,MAAAhL,QAAA4C,MAAAgsB,YAAAjwB,KAAAoC,OAGLiK,MAAAhL,QAAA4C,MAAAisB,eAAAlwB,0FA1D6B,6DCK9B,qOAoBDmwB,mBAAmBzxB,UAAUmG,mFAa7BsrB,mBAAgBzxB,UAAQoG,+WAgDhBzD,QAAS2K,KAAApD,qDAKTwnB,IAAA,IAJJxnB,UAAUA,UAAQ9G,IAAA,SAAcnC,IAAA,OAAA8E,oBAAA9E,OAKzBI,QAAI,SAAUJ,IACjBywB,IAzFC,QA2FG1wB,OAASmG,WAAWlG,GAAC,qBACb,GAAIywB,IAAA,IAAA1wB,OAAA,aA5Ff,gBA8FWC,IAAAI,QAAO,SAAAC,gBAEHL,GAAAK,uBAEH,SACD,OACJ,IAAA,SAIL,YAHSoC,QACAiuB,aAAOD,IAAA,8BAAAhuB,MAAA,QAGnB,QAEW,YADZiuB,aAAA,GAAAD,IAAApwB,KAAA,KAAAoC,MAAA,UAIHiuB,aAAkBD,IAAA,QAEpBC,aAAA,8NA2BM,IAAAnrB,kBAA0BA,6CAE1B5G,KAAAgyB,8LAMGlrB,SAAAJ,QACNurB,2BAAAxwB,QAAA,SAAAY,0CAGGnC,OAAWsB,KAAGwG,QAAAvG,QAAA,SAA2BC,MAAS,OAAE6I,eAAA7I,MAAAsG,OAAAtG,UAKxD,IAAIwS,qBA6CoB5J,6CAGhB,SAEA1K,MAAAsI,QAAcoC,WAAeA,WAAEA,uBAChC,SAAAjJ,IACJnB,OAAAsB,KAAAH,IAAAI,QAAA,SAAAC,MACN,UAAAA,MAAA,UAAAA,OAEJwwB,cAAAxwB,MAAAL,GAAAK,gCAvDwBywB,gGAMb,OAAK,IAAGX,kBAAKzuB,QAAqBmR,aAGtC,IAAIsc,cAvKY,cAuK6BxwB,KAASoyB,SAEtDC,MAAOryB,KAAOsyB,qBAAAvvB,QAAAytB,cAAAlmB,WAChB9E,SAAAH,cAAA,QAAAktB,YAAAF,4GAIF,wFAAAhwB,2BAKgBjC,UAAK4xB,iCAIdhyB,KAAAwyB,iBACNC,QAAAC,KAAA,oGAAA,qIArLA,2BCPwB,oBAChBC,oBAAiB5vB,QAAAuH,UAAA6D,SACtBnO,KAAK+C,QAAAA,QACL/C,KAAKsK,UAAYA,UACjBtK,KAAKmO,QAASA,QACdnO,KAAK0wB,cACL1wB,KAAK2wB,eACL3wB,KAAK4wB,iBACL5wB,KAAK4yB,cAAe,EACpB5yB,KAAK6uB,WAAA,EACL7uB,KAAK6wB,UAAS,EACd7wB,KAAKiwB,YAAM,EACXjwB,KAAKoZ,KAAO,EACfpZ,KAAA8pB,aAAA,0FAID9pB,KAAAoZ,KAAApZ,KAAoBwuB,UAAUxuB,KAAAyuB,kCAKjBruB,UAAiByyB,qBAI5B7yB,KAAA6uB,0HASOzuB,UAAA8e,oCAKTlf,KAAA8yB,iDAKa1yB,UAAYoe,wBAIrB,IAAIzQ,MAAA/N,KACJ,IAAAA,KAAA4yB,aAAA,CAEA5yB,KAAK4yB,cAAc,EAErB,IAAAtoB,UAAAtK,KAAAsK,8JAIFtK,KAAA+yB,UAAmBC,iBAAW,SAAA,WAAyB,OAAAjlB,MAAA8kB,oCAKpCzyB,UAAE0yB,qCAKhB9yB,KAAAyuB,OACHzuB,KAAAizB,uNAkCF,SAAA1W,IAAAvc,KAAoB2wB,YAAUxuB,KAAMoa,0CASpC,SAAAA,IAAAvc,KAAoB0wB,WAAUvuB,KAAAoa,2GAahBnc,UAAcye,qBAIvBL,eACIxe,KAAAmxB,eACPnxB,KAAA2wB,YAAAlvB,QAAA,SAAA8a,IAAA,OAAAA,6CAIFvc,KAAA+yB,UAAmBlU,4BAKAze,UAAQ0e,6BAK3B9e,KAAA+yB,UAAmBjU,6BAKC1e,UAAC6e,+CAMrBjf,KAAA+yB,UAAmB9T,8BAKA7e,UAAS2e,kFAO5B/e,KAAA6wB,UAAoB,uBAKPzwB,UAAgB6yB,6FAWb7yB,UAAA4e,gCAKhBhf,KAAA6e,sGAYaze,UAAiBse,mBAItB1e,KAAKiwB,aACRjwB,KAAAiwB,YAAA,EACHjwB,KAAAizB,wOAkBK7yB,UAAA8yB,uBAGH,OAAclzB,KAAO+yB,UAAW5jB,YAAQnP,KAAUoZ,aAClDhC,eAAgBub,oBAAAvyB,UAAA,aAChBwD,gEAKJuqB,cAAA,qEASgBnuB,oBAGHmxB,qBACF3vB,KAAAxB,KAAAmzB,gBAAA1xB,QAAA,SAAAC,MACN,UAAAA,OACIsG,OAAAtG,MACPqM,MAAA8gB,UAAA9gB,MAAAolB,eAAAzxB,MAAAiJ,aAAAoD,MAAAhL,QAAArB,sCAYFixB,oBAAmBvyB,UAAEksB,yBAKnBnpB,WAEF,IAAAmuB,QAAA,SAAAnuB,UAAAnD,KAAA2wB,YAAA3wB,KAAA0wB,4FA9QyB,yMC0I7B,8GApHI0C,oBAAmBhzB,UAAUmG,mFAa7B6sB,oBAAoBhzB,UAAIoG,kdAiEhBzD,QAAWuH,UAACxD,SAAoBJ,MAAOC,OAAQC,gBAAaC,iCAC/D,IAAAD,kBAAAA,qBAEmBC,0BAAwB7G,KAAAqzB,cAExC,OAAArzB,KAAAszB,oBAA4BpH,QAAUnpB,QAAOuH,UAAaxD,SAAOJ,MAAAC,OAAAC,iBAGrE,IAEC2sB,eAAAzsB,SAAAA,SAAAJ,MAAAA,MAAA8sB,KAFW,GAAF9sB,MAAE,OAAA,qBAMR6sB,cAAA,OAAA5sB,0DAKgDC,gBAAS0N,OAAc,SAASjS,QAAW,OAAMA,kBAAAswB,4DAC9F7rB,SAAAJ,QACN+sB,4BAAAhyB,QAAA,SAAAY,QAED,IAAY2F,OAAA3F,OAAAyuB,gBACL5wB,OAAIsB,KAAAwG,QAAAvG,QAAoB,SAASC,MAAW,OAAA6I,eAAe7I,MAAAsG,OAAAtG,+DAGrE4I,UAAAA,UAAA9G,IAAA,SAAAwE,QAAA,OAAAG,WAAAH,QAAA,+EAWWorB,4DtBtIS,oBAAAM,aAAA,IAAAA,OAAAluB,gxBsB4IzB,MAA+B,mBAAtBmuB","file":"/mnt/c/Users/Sarun/dev/angular/dist/packages-dist/animations/bundles/animations-browser.umd.min.js.map","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nimport { AUTO_STYLE, NoopAnimationPlayer, ÉµAnimationGroupPlayer, ÉµPRE_STYLE as PRE_STYLE } from '@angular/animations';\n/**\n * @return {?}\n */\nexport function isBrowser() {\n    return (typeof window !== 'undefined' && typeof window.document !== 'undefined');\n}\n/**\n * @return {?}\n */\nexport function isNode() {\n    return (typeof process !== 'undefined');\n}\n/**\n * @param {?} players\n * @return {?}\n */\nexport function optimizeGroupPlayer(players) {\n    switch (players.length) {\n        case 0:\n            return new NoopAnimationPlayer();\n        case 1:\n            return players[0];\n        default:\n            return new ÉµAnimationGroupPlayer(players);\n    }\n}\n/**\n * @param {?} driver\n * @param {?} normalizer\n * @param {?} element\n * @param {?} keyframes\n * @param {?=} preStyles\n * @param {?=} postStyles\n * @return {?}\n */\nexport function normalizeKeyframes(driver, normalizer, element, keyframes, preStyles, postStyles) {\n    if (preStyles === void 0) { preStyles = {}; }\n    if (postStyles === void 0) { postStyles = {}; }\n    /** @type {?} */\n    var errors = [];\n    /** @type {?} */\n    var normalizedKeyframes = [];\n    /** @type {?} */\n    var previousOffset = -1;\n    /** @type {?} */\n    var previousKeyframe = null;\n    keyframes.forEach(function (kf) {\n        /** @type {?} */\n        var offset = /** @type {?} */ (kf['offset']);\n        /** @type {?} */\n        var isSameOffset = offset == previousOffset;\n        /** @type {?} */\n        var normalizedKeyframe = (isSameOffset && previousKeyframe) || {};\n        Object.keys(kf).forEach(function (prop) {\n            /** @type {?} */\n            var normalizedProp = prop;\n            /** @type {?} */\n            var normalizedValue = kf[prop];\n            if (prop !== 'offset') {\n                normalizedProp = normalizer.normalizePropertyName(normalizedProp, errors);\n                switch (normalizedValue) {\n                    case PRE_STYLE:\n                        normalizedValue = preStyles[prop];\n                        break;\n                    case AUTO_STYLE:\n                        normalizedValue = postStyles[prop];\n                        break;\n                    default:\n                        normalizedValue =\n                            normalizer.normalizeStyleValue(prop, normalizedProp, normalizedValue, errors);\n                        break;\n                }\n            }\n            normalizedKeyframe[normalizedProp] = normalizedValue;\n        });\n        if (!isSameOffset) {\n            normalizedKeyframes.push(normalizedKeyframe);\n        }\n        previousKeyframe = normalizedKeyframe;\n        previousOffset = offset;\n    });\n    if (errors.length) {\n        /** @type {?} */\n        var LINE_START = '\\n - ';\n        throw new Error(\"Unable to animate due to the following errors:\" + LINE_START + errors.join(LINE_START));\n    }\n    return normalizedKeyframes;\n}\n/**\n * @param {?} player\n * @param {?} eventName\n * @param {?} event\n * @param {?} callback\n * @return {?}\n */\nexport function listenOnPlayer(player, eventName, event, callback) {\n    switch (eventName) {\n        case 'start':\n            player.onStart(function () { return callback(event && copyAnimationEvent(event, 'start', player)); });\n            break;\n        case 'done':\n            player.onDone(function () { return callback(event && copyAnimationEvent(event, 'done', player)); });\n            break;\n        case 'destroy':\n            player.onDestroy(function () { return callback(event && copyAnimationEvent(event, 'destroy', player)); });\n            break;\n    }\n}\n/**\n * @param {?} e\n * @param {?} phaseName\n * @param {?} player\n * @return {?}\n */\nexport function copyAnimationEvent(e, phaseName, player) {\n    /** @type {?} */\n    var totalTime = player.totalTime;\n    /** @type {?} */\n    var disabled = (/** @type {?} */ (player)).disabled ? true : false;\n    /** @type {?} */\n    var event = makeAnimationEvent(e.element, e.triggerName, e.fromState, e.toState, phaseName || e.phaseName, totalTime == undefined ? e.totalTime : totalTime, disabled);\n    /** @type {?} */\n    var data = (/** @type {?} */ (e))['_data'];\n    if (data != null) {\n        (/** @type {?} */ (event))['_data'] = data;\n    }\n    return event;\n}\n/**\n * @param {?} element\n * @param {?} triggerName\n * @param {?} fromState\n * @param {?} toState\n * @param {?=} phaseName\n * @param {?=} totalTime\n * @param {?=} disabled\n * @return {?}\n */\nexport function makeAnimationEvent(element, triggerName, fromState, toState, phaseName, totalTime, disabled) {\n    if (phaseName === void 0) { phaseName = ''; }\n    if (totalTime === void 0) { totalTime = 0; }\n    return { element: element, triggerName: triggerName, fromState: fromState, toState: toState, phaseName: phaseName, totalTime: totalTime, disabled: !!disabled };\n}\n/**\n * @param {?} map\n * @param {?} key\n * @param {?} defaultValue\n * @return {?}\n */\nexport function getOrSetAsInMap(map, key, defaultValue) {\n    /** @type {?} */\n    var value;\n    if (map instanceof Map) {\n        value = map.get(key);\n        if (!value) {\n            map.set(key, value = defaultValue);\n        }\n    }\n    else {\n        value = map[key];\n        if (!value) {\n            value = map[key] = defaultValue;\n        }\n    }\n    return value;\n}\n/**\n * @param {?} command\n * @return {?}\n */\nexport function parseTimelineCommand(command) {\n    /** @type {?} */\n    var separatorPos = command.indexOf(':');\n    /** @type {?} */\n    var id = command.substring(1, separatorPos);\n    /** @type {?} */\n    var action = command.substr(separatorPos + 1);\n    return [id, action];\n}\n/** @type {?} */\nvar _contains = function (elm1, elm2) { return false; };\nvar Éµ0 = _contains;\n/** @type {?} */\nvar _matches = function (element, selector) {\n    return false;\n};\nvar Éµ1 = _matches;\n/** @type {?} */\nvar _query = function (element, selector, multi) {\n    return [];\n};\nvar Éµ2 = _query;\n/** @type {?} */\nvar _isNode = isNode();\nif (_isNode || typeof Element !== 'undefined') {\n    // this is well supported in all browsers\n    _contains = function (elm1, elm2) { return /** @type {?} */ (elm1.contains(elm2)); };\n    if (_isNode || Element.prototype.matches) {\n        _matches = function (element, selector) { return element.matches(selector); };\n    }\n    else {\n        /** @type {?} */\n        var proto = /** @type {?} */ (Element.prototype);\n        /** @type {?} */\n        var fn_1 = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector ||\n            proto.oMatchesSelector || proto.webkitMatchesSelector;\n        if (fn_1) {\n            _matches = function (element, selector) { return fn_1.apply(element, [selector]); };\n        }\n    }\n    _query = function (element, selector, multi) {\n        /** @type {?} */\n        var results = [];\n        if (multi) {\n            results.push.apply(results, element.querySelectorAll(selector));\n        }\n        else {\n            /** @type {?} */\n            var elm = element.querySelector(selector);\n            if (elm) {\n                results.push(elm);\n            }\n        }\n        return results;\n    };\n}\n/**\n * @param {?} prop\n * @return {?}\n */\nfunction containsVendorPrefix(prop) {\n    // Webkit is the only real popular vendor prefix nowadays\n    // cc: http://shouldiprefix.com/\n    return prop.substring(1, 6) == 'ebkit'; // webkit or Webkit\n}\n/** @type {?} */\nvar _CACHED_BODY = null;\n/** @type {?} */\nvar _IS_WEBKIT = false;\n/**\n * @param {?} prop\n * @return {?}\n */\nexport function validateStyleProperty(prop) {\n    if (!_CACHED_BODY) {\n        _CACHED_BODY = getBodyNode() || {};\n        _IS_WEBKIT = /** @type {?} */ ((_CACHED_BODY)).style ? ('WebkitAppearance' in /** @type {?} */ ((_CACHED_BODY)).style) : false;\n    }\n    /** @type {?} */\n    var result = true;\n    if (/** @type {?} */ ((_CACHED_BODY)).style && !containsVendorPrefix(prop)) {\n        result = prop in /** @type {?} */ ((_CACHED_BODY)).style;\n        if (!result && _IS_WEBKIT) {\n            /** @type {?} */\n            var camelProp = 'Webkit' + prop.charAt(0).toUpperCase() + prop.substr(1);\n            result = camelProp in /** @type {?} */ ((_CACHED_BODY)).style;\n        }\n    }\n    return result;\n}\n/**\n * @return {?}\n */\nexport function getBodyNode() {\n    if (typeof document != 'undefined') {\n        return document.body;\n    }\n    return null;\n}\n/** @type {?} */\nexport var matchesElement = _matches;\n/** @type {?} */\nexport var containsElement = _contains;\n/** @type {?} */\nexport var invokeQuery = _query;\n/**\n * @param {?} object\n * @return {?}\n */\nexport function hypenatePropsObject(object) {\n    /** @type {?} */\n    var newObj = {};\n    Object.keys(object).forEach(function (prop) {\n        /** @type {?} */\n        var newProp = prop.replace(/([a-z])([A-Z])/g, '$1-$2');\n        newObj[newProp] = object[prop];\n    });\n    return newObj;\n}\nexport { Éµ0, Éµ1, Éµ2 };\n//# sourceMappingURL=shared.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nimport { NoopAnimationPlayer } from '@angular/animations';\nimport { Injectable } from '@angular/core';\nimport { containsElement, invokeQuery, matchesElement, validateStyleProperty } from './shared';\n/**\n * \\@publicApi\n */\nvar NoopAnimationDriver = /** @class */ (function () {\n    function NoopAnimationDriver() {\n    }\n    /**\n     * @param {?} prop\n     * @return {?}\n     */\n    NoopAnimationDriver.prototype.validateStyleProperty = /**\n     * @param {?} prop\n     * @return {?}\n     */\n    function (prop) { return validateStyleProperty(prop); };\n    /**\n     * @param {?} element\n     * @param {?} selector\n     * @return {?}\n     */\n    NoopAnimationDriver.prototype.matchesElement = /**\n     * @param {?} element\n     * @param {?} selector\n     * @return {?}\n     */\n    function (element, selector) {\n        return matchesElement(element, selector);\n    };\n    /**\n     * @param {?} elm1\n     * @param {?} elm2\n     * @return {?}\n     */\n    NoopAnimationDriver.prototype.containsElement = /**\n     * @param {?} elm1\n     * @param {?} elm2\n     * @return {?}\n     */\n    function (elm1, elm2) { return containsElement(elm1, elm2); };\n    /**\n     * @param {?} element\n     * @param {?} selector\n     * @param {?} multi\n     * @return {?}\n     */\n    NoopAnimationDriver.prototype.query = /**\n     * @param {?} element\n     * @param {?} selector\n     * @param {?} multi\n     * @return {?}\n     */\n    function (element, selector, multi) {\n        return invokeQuery(element, selector, multi);\n    };\n    /**\n     * @param {?} element\n     * @param {?} prop\n     * @param {?=} defaultValue\n     * @return {?}\n     */\n    NoopAnimationDriver.prototype.computeStyle = /**\n     * @param {?} element\n     * @param {?} prop\n     * @param {?=} defaultValue\n     * @return {?}\n     */\n    function (element, prop, defaultValue) {\n        return defaultValue || '';\n    };\n    /**\n     * @param {?} element\n     * @param {?} keyframes\n     * @param {?} duration\n     * @param {?} delay\n     * @param {?} easing\n     * @param {?=} previousPlayers\n     * @param {?=} scrubberAccessRequested\n     * @return {?}\n     */\n    NoopAnimationDriver.prototype.animate = /**\n     * @param {?} element\n     * @param {?} keyframes\n     * @param {?} duration\n     * @param {?} delay\n     * @param {?} easing\n     * @param {?=} previousPlayers\n     * @param {?=} scrubberAccessRequested\n     * @return {?}\n     */\n    function (element, keyframes, duration, delay, easing, previousPlayers, scrubberAccessRequested) {\n        if (previousPlayers === void 0) { previousPlayers = []; }\n        return new NoopAnimationPlayer(duration, delay);\n    };\n    NoopAnimationDriver.decorators = [\n        { type: Injectable },\n    ];\n    return NoopAnimationDriver;\n}());\nexport { NoopAnimationDriver };\n/**\n * \\@publicApi\n * @abstract\n */\nvar AnimationDriver = /** @class */ (function () {\n    function AnimationDriver() {\n    }\n    AnimationDriver.NOOP = new NoopAnimationDriver();\n    return AnimationDriver;\n}());\nexport { AnimationDriver };\nif (false) {\n    /** @type {?} */\n    AnimationDriver.NOOP;\n    /**\n     * @abstract\n     * @param {?} prop\n     * @return {?}\n     */\n    AnimationDriver.prototype.validateStyleProperty = function (prop) { };\n    /**\n     * @abstract\n     * @param {?} element\n     * @param {?} selector\n     * @return {?}\n     */\n    AnimationDriver.prototype.matchesElement = function (element, selector) { };\n    /**\n     * @abstract\n     * @param {?} elm1\n     * @param {?} elm2\n     * @return {?}\n     */\n    AnimationDriver.prototype.containsElement = function (elm1, elm2) { };\n    /**\n     * @abstract\n     * @param {?} element\n     * @param {?} selector\n     * @param {?} multi\n     * @return {?}\n     */\n    AnimationDriver.prototype.query = function (element, selector, multi) { };\n    /**\n     * @abstract\n     * @param {?} element\n     * @param {?} prop\n     * @param {?=} defaultValue\n     * @return {?}\n     */\n    AnimationDriver.prototype.computeStyle = function (element, prop, defaultValue) { };\n    /**\n     * @abstract\n     * @param {?} element\n     * @param {?} keyframes\n     * @param {?} duration\n     * @param {?} delay\n     * @param {?=} easing\n     * @param {?=} previousPlayers\n     * @param {?=} scrubberAccessRequested\n     * @return {?}\n     */\n    AnimationDriver.prototype.animate = function (element, keyframes, duration, delay, easing, previousPlayers, scrubberAccessRequested) { };\n}\n//# sourceMappingURL=animation_driver.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nimport { sequence } from '@angular/animations';\nimport { isNode } from './render/shared';\n/** @type {?} */\nexport var ONE_SECOND = 1000;\n/** @type {?} */\nexport var SUBSTITUTION_EXPR_START = '{{';\n/** @type {?} */\nexport var SUBSTITUTION_EXPR_END = '}}';\n/** @type {?} */\nexport var ENTER_CLASSNAME = 'ng-enter';\n/** @type {?} */\nexport var LEAVE_CLASSNAME = 'ng-leave';\n/** @type {?} */\nexport var ENTER_SELECTOR = '.ng-enter';\n/** @type {?} */\nexport var LEAVE_SELECTOR = '.ng-leave';\n/** @type {?} */\nexport var NG_TRIGGER_CLASSNAME = 'ng-trigger';\n/** @type {?} */\nexport var NG_TRIGGER_SELECTOR = '.ng-trigger';\n/** @type {?} */\nexport var NG_ANIMATING_CLASSNAME = 'ng-animating';\n/** @type {?} */\nexport var NG_ANIMATING_SELECTOR = '.ng-animating';\n/**\n * @param {?} value\n * @return {?}\n */\nexport function resolveTimingValue(value) {\n    if (typeof value == 'number')\n        return value;\n    /** @type {?} */\n    var matches = (/** @type {?} */ (value)).match(/^(-?[\\.\\d]+)(m?s)/);\n    if (!matches || matches.length < 2)\n        return 0;\n    return _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);\n}\n/**\n * @param {?} value\n * @param {?} unit\n * @return {?}\n */\nfunction _convertTimeValueToMS(value, unit) {\n    switch (unit) {\n        case 's':\n            return value * ONE_SECOND;\n        default: // ms or something else\n            // ms or something else\n            return value;\n    }\n}\n/**\n * @param {?} timings\n * @param {?} errors\n * @param {?=} allowNegativeValues\n * @return {?}\n */\nexport function resolveTiming(timings, errors, allowNegativeValues) {\n    return timings.hasOwnProperty('duration') ? /** @type {?} */ (timings) :\n        parseTimeExpression(/** @type {?} */ (timings), errors, allowNegativeValues);\n}\n/**\n * @param {?} exp\n * @param {?} errors\n * @param {?=} allowNegativeValues\n * @return {?}\n */\nfunction parseTimeExpression(exp, errors, allowNegativeValues) {\n    /** @type {?} */\n    var regex = /^(-?[\\.\\d]+)(m?s)(?:\\s+(-?[\\.\\d]+)(m?s))?(?:\\s+([-a-z]+(?:\\(.+?\\))?))?$/i;\n    /** @type {?} */\n    var duration;\n    /** @type {?} */\n    var delay = 0;\n    /** @type {?} */\n    var easing = '';\n    if (typeof exp === 'string') {\n        /** @type {?} */\n        var matches = exp.match(regex);\n        if (matches === null) {\n            errors.push(\"The provided timing value \\\"\" + exp + \"\\\" is invalid.\");\n            return { duration: 0, delay: 0, easing: '' };\n        }\n        duration = _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);\n        /** @type {?} */\n        var delayMatch = matches[3];\n        if (delayMatch != null) {\n            delay = _convertTimeValueToMS(Math.floor(parseFloat(delayMatch)), matches[4]);\n        }\n        /** @type {?} */\n        var easingVal = matches[5];\n        if (easingVal) {\n            easing = easingVal;\n        }\n    }\n    else {\n        duration = /** @type {?} */ (exp);\n    }\n    if (!allowNegativeValues) {\n        /** @type {?} */\n        var containsErrors = false;\n        /** @type {?} */\n        var startIndex = errors.length;\n        if (duration < 0) {\n            errors.push(\"Duration values below 0 are not allowed for this animation step.\");\n            containsErrors = true;\n        }\n        if (delay < 0) {\n            errors.push(\"Delay values below 0 are not allowed for this animation step.\");\n            containsErrors = true;\n        }\n        if (containsErrors) {\n            errors.splice(startIndex, 0, \"The provided timing value \\\"\" + exp + \"\\\" is invalid.\");\n        }\n    }\n    return { duration: duration, delay: delay, easing: easing };\n}\n/**\n * @param {?} obj\n * @param {?=} destination\n * @return {?}\n */\nexport function copyObj(obj, destination) {\n    if (destination === void 0) { destination = {}; }\n    Object.keys(obj).forEach(function (prop) { destination[prop] = obj[prop]; });\n    return destination;\n}\n/**\n * @param {?} styles\n * @return {?}\n */\nexport function normalizeStyles(styles) {\n    /** @type {?} */\n    var normalizedStyles = {};\n    if (Array.isArray(styles)) {\n        styles.forEach(function (data) { return copyStyles(data, false, normalizedStyles); });\n    }\n    else {\n        copyStyles(styles, false, normalizedStyles);\n    }\n    return normalizedStyles;\n}\n/**\n * @param {?} styles\n * @param {?} readPrototype\n * @param {?=} destination\n * @return {?}\n */\nexport function copyStyles(styles, readPrototype, destination) {\n    if (destination === void 0) { destination = {}; }\n    if (readPrototype) {\n        // we make use of a for-in loop so that the\n        // prototypically inherited properties are\n        // revealed from the backFill map\n        for (var prop in styles) {\n            destination[prop] = styles[prop];\n        }\n    }\n    else {\n        copyObj(styles, destination);\n    }\n    return destination;\n}\n/**\n * @param {?} element\n * @param {?} key\n * @param {?} value\n * @return {?}\n */\nfunction getStyleAttributeString(element, key, value) {\n    // Return the key-value pair string to be added to the style attribute for the\n    // given CSS style key.\n    if (value) {\n        return key + ':' + value + ';';\n    }\n    else {\n        return '';\n    }\n}\n/**\n * @param {?} element\n * @return {?}\n */\nfunction writeStyleAttribute(element) {\n    /** @type {?} */\n    var styleAttrValue = '';\n    for (var i = 0; i < element.style.length; i++) {\n        /** @type {?} */\n        var key = element.style.item(i);\n        styleAttrValue += getStyleAttributeString(element, key, element.style.getPropertyValue(key));\n    }\n    for (var key in element.style) {\n        // Skip internal Domino properties that don't need to be reflected.\n        if (!element.style.hasOwnProperty(key) || key.startsWith('_')) {\n            continue;\n        }\n        /** @type {?} */\n        var dashKey = camelCaseToDashCase(key);\n        styleAttrValue += getStyleAttributeString(element, dashKey, element.style[key]);\n    }\n    element.setAttribute('style', styleAttrValue);\n}\n/**\n * @param {?} element\n * @param {?} styles\n * @return {?}\n */\nexport function setStyles(element, styles) {\n    if (element['style']) {\n        Object.keys(styles).forEach(function (prop) {\n            /** @type {?} */\n            var camelProp = dashCaseToCamelCase(prop);\n            element.style[camelProp] = styles[prop];\n        });\n        // On the server set the 'style' attribute since it's not automatically reflected.\n        if (isNode()) {\n            writeStyleAttribute(element);\n        }\n    }\n}\n/**\n * @param {?} element\n * @param {?} styles\n * @return {?}\n */\nexport function eraseStyles(element, styles) {\n    if (element['style']) {\n        Object.keys(styles).forEach(function (prop) {\n            /** @type {?} */\n            var camelProp = dashCaseToCamelCase(prop);\n            element.style[camelProp] = '';\n        });\n        // On the server set the 'style' attribute since it's not automatically reflected.\n        if (isNode()) {\n            writeStyleAttribute(element);\n        }\n    }\n}\n/**\n * @param {?} steps\n * @return {?}\n */\nexport function normalizeAnimationEntry(steps) {\n    if (Array.isArray(steps)) {\n        if (steps.length == 1)\n            return steps[0];\n        return sequence(steps);\n    }\n    return /** @type {?} */ (steps);\n}\n/**\n * @param {?} value\n * @param {?} options\n * @param {?} errors\n * @return {?}\n */\nexport function validateStyleParams(value, options, errors) {\n    /** @type {?} */\n    var params = options.params || {};\n    /** @type {?} */\n    var matches = extractStyleParams(value);\n    if (matches.length) {\n        matches.forEach(function (varName) {\n            if (!params.hasOwnProperty(varName)) {\n                errors.push(\"Unable to resolve the local animation param \" + varName + \" in the given list of values\");\n            }\n        });\n    }\n}\n/** @type {?} */\nvar PARAM_REGEX = new RegExp(SUBSTITUTION_EXPR_START + \"\\\\s*(.+?)\\\\s*\" + SUBSTITUTION_EXPR_END, 'g');\n/**\n * @param {?} value\n * @return {?}\n */\nexport function extractStyleParams(value) {\n    /** @type {?} */\n    var params = [];\n    if (typeof value === 'string') {\n        /** @type {?} */\n        var val = value.toString();\n        /** @type {?} */\n        var match = void 0;\n        while (match = PARAM_REGEX.exec(val)) {\n            params.push(/** @type {?} */ (match[1]));\n        }\n        PARAM_REGEX.lastIndex = 0;\n    }\n    return params;\n}\n/**\n * @param {?} value\n * @param {?} params\n * @param {?} errors\n * @return {?}\n */\nexport function interpolateParams(value, params, errors) {\n    /** @type {?} */\n    var original = value.toString();\n    /** @type {?} */\n    var str = original.replace(PARAM_REGEX, function (_, varName) {\n        /** @type {?} */\n        var localVal = params[varName];\n        // this means that the value was never overridden by the data passed in by the user\n        if (!params.hasOwnProperty(varName)) {\n            errors.push(\"Please provide a value for the animation param \" + varName);\n            localVal = '';\n        }\n        return localVal.toString();\n    });\n    // we do this to assert that numeric values stay as they are\n    return str == original ? value : str;\n}\n/**\n * @param {?} iterator\n * @return {?}\n */\nexport function iteratorToArray(iterator) {\n    /** @type {?} */\n    var arr = [];\n    /** @type {?} */\n    var item = iterator.next();\n    while (!item.done) {\n        arr.push(item.value);\n        item = iterator.next();\n    }\n    return arr;\n}\n/**\n * @param {?} source\n * @param {?} destination\n * @return {?}\n */\nexport function mergeAnimationOptions(source, destination) {\n    if (source.params) {\n        /** @type {?} */\n        var p0_1 = source.params;\n        if (!destination.params) {\n            destination.params = {};\n        }\n        /** @type {?} */\n        var p1_1 = destination.params;\n        Object.keys(p0_1).forEach(function (param) {\n            if (!p1_1.hasOwnProperty(param)) {\n                p1_1[param] = p0_1[param];\n            }\n        });\n    }\n    return destination;\n}\n/** @type {?} */\nvar DASH_CASE_REGEXP = /-+([a-z0-9])/g;\n/**\n * @param {?} input\n * @return {?}\n */\nexport function dashCaseToCamelCase(input) {\n    return input.replace(DASH_CASE_REGEXP, function () {\n        var m = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            m[_i] = arguments[_i];\n        }\n        return m[1].toUpperCase();\n    });\n}\n/**\n * @param {?} input\n * @return {?}\n */\nfunction camelCaseToDashCase(input) {\n    return input.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n}\n/**\n * @param {?} duration\n * @param {?} delay\n * @return {?}\n */\nexport function allowPreviousPlayerStylesMerge(duration, delay) {\n    return duration === 0 || delay === 0;\n}\n/**\n * @param {?} element\n * @param {?} keyframes\n * @param {?} previousStyles\n * @return {?}\n */\nexport function balancePreviousStylesIntoKeyframes(element, keyframes, previousStyles) {\n    /** @type {?} */\n    var previousStyleProps = Object.keys(previousStyles);\n    if (previousStyleProps.length && keyframes.length) {\n        /** @type {?} */\n        var startingKeyframe_1 = keyframes[0];\n        /** @type {?} */\n        var missingStyleProps_1 = [];\n        previousStyleProps.forEach(function (prop) {\n            if (!startingKeyframe_1.hasOwnProperty(prop)) {\n                missingStyleProps_1.push(prop);\n            }\n            startingKeyframe_1[prop] = previousStyles[prop];\n        });\n        if (missingStyleProps_1.length) {\n            var _loop_1 = function () {\n                /** @type {?} */\n                var kf = keyframes[i];\n                missingStyleProps_1.forEach(function (prop) { kf[prop] = computeStyle(element, prop); });\n            };\n            // tslint:disable-next-line\n            for (var i = 1; i < keyframes.length; i++) {\n                _loop_1();\n            }\n        }\n    }\n    return keyframes;\n}\n/**\n * @param {?} visitor\n * @param {?} node\n * @param {?} context\n * @return {?}\n */\nexport function visitDslNode(visitor, node, context) {\n    switch (node.type) {\n        case 7 /* Trigger */:\n            return visitor.visitTrigger(node, context);\n        case 0 /* State */:\n            return visitor.visitState(node, context);\n        case 1 /* Transition */:\n            return visitor.visitTransition(node, context);\n        case 2 /* Sequence */:\n            return visitor.visitSequence(node, context);\n        case 3 /* Group */:\n            return visitor.visitGroup(node, context);\n        case 4 /* Animate */:\n            return visitor.visitAnimate(node, context);\n        case 5 /* Keyframes */:\n            return visitor.visitKeyframes(node, context);\n        case 6 /* Style */:\n            return visitor.visitStyle(node, context);\n        case 8 /* Reference */:\n            return visitor.visitReference(node, context);\n        case 9 /* AnimateChild */:\n            return visitor.visitAnimateChild(node, context);\n        case 10 /* AnimateRef */:\n            return visitor.visitAnimateRef(node, context);\n        case 11 /* Query */:\n            return visitor.visitQuery(node, context);\n        case 12 /* Stagger */:\n            return visitor.visitStagger(node, context);\n        default:\n            throw new Error(\"Unable to resolve animation metadata node #\" + node.type);\n    }\n}\n/**\n * @param {?} element\n * @param {?} prop\n * @return {?}\n */\nexport function computeStyle(element, prop) {\n    return (/** @type {?} */ (window.getComputedStyle(element)))[prop];\n}\n//# sourceMappingURL=util.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** *\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n  @type {?} */\nexport var ANY_STATE = '*';\n/**\n * @param {?} transitionValue\n * @param {?} errors\n * @return {?}\n */\nexport function parseTransitionExpr(transitionValue, errors) {\n    /** @type {?} */\n    var expressions = [];\n    if (typeof transitionValue == 'string') {\n        (/** @type {?} */ (transitionValue))\n            .split(/\\s*,\\s*/)\n            .forEach(function (str) { return parseInnerTransitionStr(str, expressions, errors); });\n    }\n    else {\n        expressions.push(/** @type {?} */ (transitionValue));\n    }\n    return expressions;\n}\n/**\n * @param {?} eventStr\n * @param {?} expressions\n * @param {?} errors\n * @return {?}\n */\nfunction parseInnerTransitionStr(eventStr, expressions, errors) {\n    if (eventStr[0] == ':') {\n        /** @type {?} */\n        var result = parseAnimationAlias(eventStr, errors);\n        if (typeof result == 'function') {\n            expressions.push(result);\n            return;\n        }\n        eventStr = /** @type {?} */ (result);\n    }\n    /** @type {?} */\n    var match = eventStr.match(/^(\\*|[-\\w]+)\\s*(<?[=-]>)\\s*(\\*|[-\\w]+)$/);\n    if (match == null || match.length < 4) {\n        errors.push(\"The provided transition expression \\\"\" + eventStr + \"\\\" is not supported\");\n        return expressions;\n    }\n    /** @type {?} */\n    var fromState = match[1];\n    /** @type {?} */\n    var separator = match[2];\n    /** @type {?} */\n    var toState = match[3];\n    expressions.push(makeLambdaFromStates(fromState, toState));\n    /** @type {?} */\n    var isFullAnyStateExpr = fromState == ANY_STATE && toState == ANY_STATE;\n    if (separator[0] == '<' && !isFullAnyStateExpr) {\n        expressions.push(makeLambdaFromStates(toState, fromState));\n    }\n}\n/**\n * @param {?} alias\n * @param {?} errors\n * @return {?}\n */\nfunction parseAnimationAlias(alias, errors) {\n    switch (alias) {\n        case ':enter':\n            return 'void => *';\n        case ':leave':\n            return '* => void';\n        case ':increment':\n            return function (fromState, toState) { return parseFloat(toState) > parseFloat(fromState); };\n        case ':decrement':\n            return function (fromState, toState) { return parseFloat(toState) < parseFloat(fromState); };\n        default:\n            errors.push(\"The transition alias value \\\"\" + alias + \"\\\" is not supported\");\n            return '* => *';\n    }\n}\n/** @type {?} */\nvar TRUE_BOOLEAN_VALUES = new Set(['true', '1']);\n/** @type {?} */\nvar FALSE_BOOLEAN_VALUES = new Set(['false', '0']);\n/**\n * @param {?} lhs\n * @param {?} rhs\n * @return {?}\n */\nfunction makeLambdaFromStates(lhs, rhs) {\n    /** @type {?} */\n    var LHS_MATCH_BOOLEAN = TRUE_BOOLEAN_VALUES.has(lhs) || FALSE_BOOLEAN_VALUES.has(lhs);\n    /** @type {?} */\n    var RHS_MATCH_BOOLEAN = TRUE_BOOLEAN_VALUES.has(rhs) || FALSE_BOOLEAN_VALUES.has(rhs);\n    return function (fromState, toState) {\n        /** @type {?} */\n        var lhsMatch = lhs == ANY_STATE || lhs == fromState;\n        /** @type {?} */\n        var rhsMatch = rhs == ANY_STATE || rhs == toState;\n        if (!lhsMatch && LHS_MATCH_BOOLEAN && typeof fromState === 'boolean') {\n            lhsMatch = fromState ? TRUE_BOOLEAN_VALUES.has(lhs) : FALSE_BOOLEAN_VALUES.has(lhs);\n        }\n        if (!rhsMatch && RHS_MATCH_BOOLEAN && typeof toState === 'boolean') {\n            rhsMatch = toState ? TRUE_BOOLEAN_VALUES.has(rhs) : FALSE_BOOLEAN_VALUES.has(rhs);\n        }\n        return lhsMatch && rhsMatch;\n    };\n}\n//# sourceMappingURL=animation_transition_expr.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nimport { AUTO_STYLE, style } from '@angular/animations';\nimport { getOrSetAsInMap } from '../render/shared';\nimport { NG_ANIMATING_SELECTOR, NG_TRIGGER_SELECTOR, SUBSTITUTION_EXPR_START, copyObj, extractStyleParams, iteratorToArray, normalizeAnimationEntry, resolveTiming, validateStyleParams, visitDslNode } from '../util';\nimport { parseTransitionExpr } from './animation_transition_expr';\n/** @type {?} */\nvar SELF_TOKEN = ':self';\n/** @type {?} */\nvar SELF_TOKEN_REGEX = new RegExp(\"s*\" + SELF_TOKEN + \"s*,?\", 'g');\n/**\n * @param {?} driver\n * @param {?} metadata\n * @param {?} errors\n * @return {?}\n */\nexport function buildAnimationAst(driver, metadata, errors) {\n    return new AnimationAstBuilderVisitor(driver).build(metadata, errors);\n}\n/** @type {?} */\nvar ROOT_SELECTOR = '';\nvar AnimationAstBuilderVisitor = /** @class */ (function () {\n    function AnimationAstBuilderVisitor(_driver) {\n        this._driver = _driver;\n    }\n    /**\n     * @param {?} metadata\n     * @param {?} errors\n     * @return {?}\n     */\n    AnimationAstBuilderVisitor.prototype.build = /**\n     * @param {?} metadata\n     * @param {?} errors\n     * @return {?}\n     */\n    function (metadata, errors) {\n        /** @type {?} */\n        var context = new AnimationAstBuilderContext(errors);\n        this._resetContextStyleTimingState(context);\n        return /** @type {?} */ (visitDslNode(this, normalizeAnimationEntry(metadata), context));\n    };\n    /**\n     * @param {?} context\n     * @return {?}\n     */\n    AnimationAstBuilderVisitor.prototype._resetContextStyleTimingState = /**\n     * @param {?} context\n     * @return {?}\n     */\n    function (context) {\n        context.currentQuerySelector = ROOT_SELECTOR;\n        context.collectedStyles = {};\n        context.collectedStyles[ROOT_SELECTOR] = {};\n        context.currentTime = 0;\n    };\n    /**\n     * @param {?} metadata\n     * @param {?} context\n     * @return {?}\n     */\n    AnimationAstBuilderVisitor.prototype.visitTrigger = /**\n     * @param {?} metadata\n     * @param {?} context\n     * @return {?}\n     */\n    function (metadata, context) {\n        var _this = this;\n        /** @type {?} */\n        var queryCount = context.queryCount = 0;\n        /** @type {?} */\n        var depCount = context.depCount = 0;\n        /** @type {?} */\n        var states = [];\n        /** @type {?} */\n        var transitions = [];\n        if (metadata.name.charAt(0) == '@') {\n            context.errors.push('animation triggers cannot be prefixed with an `@` sign (e.g. trigger(\\'@foo\\', [...]))');\n        }\n        metadata.definitions.forEach(function (def) {\n            _this._resetContextStyleTimingState(context);\n            if (def.type == 0 /* State */) {\n                /** @type {?} */\n                var stateDef_1 = /** @type {?} */ (def);\n                /** @type {?} */\n                var name_1 = stateDef_1.name;\n                name_1.toString().split(/\\s*,\\s*/).forEach(function (n) {\n                    stateDef_1.name = n;\n                    states.push(_this.visitState(stateDef_1, context));\n                });\n                stateDef_1.name = name_1;\n            }\n            else if (def.type == 1 /* Transition */) {\n                /** @type {?} */\n                var transition = _this.visitTransition(/** @type {?} */ (def), context);\n                queryCount += transition.queryCount;\n                depCount += transition.depCount;\n                transitions.push(transition);\n            }\n            else {\n                context.errors.push('only state() and transition() definitions can sit inside of a trigger()');\n            }\n        });\n        return {\n            type: 7 /* Trigger */,\n            name: metadata.name, states: states, transitions: transitions, queryCount: queryCount, depCount: depCount,\n            options: null\n        };\n    };\n    /**\n     * @param {?} metadata\n     * @param {?} context\n     * @return {?}\n     */\n    AnimationAstBuilderVisitor.prototype.visitState = /**\n     * @param {?} metadata\n     * @param {?} context\n     * @return {?}\n     */\n    function (metadata, context) {\n        /** @type {?} */\n        var styleAst = this.visitStyle(metadata.styles, context);\n        /** @type {?} */\n        var astParams = (metadata.options && metadata.options.params) || null;\n        if (styleAst.containsDynamicStyles) {\n            /** @type {?} */\n            var missingSubs_1 = new Set();\n            /** @type {?} */\n            var params_1 = astParams || {};\n            styleAst.styles.forEach(function (value) {\n                if (isObject(value)) {\n                    /** @type {?} */\n                    var stylesObj_1 = /** @type {?} */ (value);\n                    Object.keys(stylesObj_1).forEach(function (prop) {\n                        extractStyleParams(stylesObj_1[prop]).forEach(function (sub) {\n                            if (!params_1.hasOwnProperty(sub)) {\n                                missingSubs_1.add(sub);\n                            }\n                        });\n                    });\n                }\n            });\n            if (missingSubs_1.size) {\n                /** @type {?} */\n                var missingSubsArr = iteratorToArray(missingSubs_1.values());\n                context.errors.push(\"state(\\\"\" + metadata.name + \"\\\", ...) must define default values for all the following style substitutions: \" + missingSubsArr.join(', '));\n            }\n        }\n        return {\n            type: 0 /* State */,\n            name: metadata.name,\n            style: styleAst,\n            options: astParams ? { params: astParams } : null\n        };\n    };\n    /**\n     * @param {?} metadata\n     * @param {?} context\n     * @return {?}\n     */\n    AnimationAstBuilderVisitor.prototype.visitTransition = /**\n     * @param {?} metadata\n     * @param {?} context\n     * @return {?}\n     */\n    function (metadata, context) {\n        context.queryCount = 0;\n        context.depCount = 0;\n        /** @type {?} */\n        var animation = visitDslNode(this, normalizeAnimationEntry(metadata.animation), context);\n        /** @type {?} */\n        var matchers = parseTransitionExpr(metadata.expr, context.errors);\n        return {\n            type: 1 /* Transition */,\n            matchers: matchers,\n            animation: animation,\n            queryCount: context.queryCount,\n            depCount: context.depCount,\n            options: normalizeAnimationOptions(metadata.options)\n        };\n    };\n    /**\n     * @param {?} metadata\n     * @param {?} context\n     * @return {?}\n     */\n    AnimationAstBuilderVisitor.prototype.visitSequence = /**\n     * @param {?} metadata\n     * @param {?} context\n     * @return {?}\n     */\n    function (metadata, context) {\n        var _this = this;\n        return {\n            type: 2 /* Sequence */,\n            steps: metadata.steps.map(function (s) { return visitDslNode(_this, s, context); }),\n            options: normalizeAnimationOptions(metadata.options)\n        };\n    };\n    /**\n     * @param {?} metadata\n     * @param {?} context\n     * @return {?}\n     */\n    AnimationAstBuilderVisitor.prototype.visitGroup = /**\n     * @param {?} metadata\n     * @param {?} context\n     * @return {?}\n     */\n    function (metadata, context) {\n        var _this = this;\n        /** @type {?} */\n        var currentTime = context.currentTime;\n        /** @type {?} */\n        var furthestTime = 0;\n        /** @type {?} */\n        var steps = metadata.steps.map(function (step) {\n            context.currentTime = currentTime;\n            /** @type {?} */\n            var innerAst = visitDslNode(_this, step, context);\n            furthestTime = Math.max(furthestTime, context.currentTime);\n            return innerAst;\n        });\n        context.currentTime = furthestTime;\n        return {\n            type: 3 /* Group */,\n            steps: steps,\n            options: normalizeAnimationOptions(metadata.options)\n        };\n    };\n    /**\n     * @param {?} metadata\n     * @param {?} context\n     * @return {?}\n     */\n    AnimationAstBuilderVisitor.prototype.visitAnimate = /**\n     * @param {?} metadata\n     * @param {?} context\n     * @return {?}\n     */\n    function (metadata, context) {\n        /** @type {?} */\n        var timingAst = constructTimingAst(metadata.timings, context.errors);\n        context.currentAnimateTimings = timingAst;\n        /** @type {?} */\n        var styleAst;\n        /** @type {?} */\n        var styleMetadata = metadata.styles ? metadata.styles : style({});\n        if (styleMetadata.type == 5 /* Keyframes */) {\n            styleAst = this.visitKeyframes(/** @type {?} */ (styleMetadata), context);\n        }\n        else {\n            /** @type {?} */\n            var styleMetadata_1 = /** @type {?} */ (metadata.styles);\n            /** @type {?} */\n            var isEmpty = false;\n            if (!styleMetadata_1) {\n                isEmpty = true;\n                /** @type {?} */\n                var newStyleData = {};\n                if (timingAst.easing) {\n                    newStyleData['easing'] = timingAst.easing;\n                }\n                styleMetadata_1 = style(newStyleData);\n            }\n            context.currentTime += timingAst.duration + timingAst.delay;\n            /** @type {?} */\n            var _styleAst = this.visitStyle(styleMetadata_1, context);\n            _styleAst.isEmptyStep = isEmpty;\n            styleAst = _styleAst;\n        }\n        context.currentAnimateTimings = null;\n        return {\n            type: 4 /* Animate */,\n            timings: timingAst,\n            style: styleAst,\n            options: null\n        };\n    };\n    /**\n     * @param {?} metadata\n     * @param {?} context\n     * @return {?}\n     */\n    AnimationAstBuilderVisitor.prototype.visitStyle = /**\n     * @param {?} metadata\n     * @param {?} context\n     * @return {?}\n     */\n    function (metadata, context) {\n        /** @type {?} */\n        var ast = this._makeStyleAst(metadata, context);\n        this._validateStyleAst(ast, context);\n        return ast;\n    };\n    /**\n     * @param {?} metadata\n     * @param {?} context\n     * @return {?}\n     */\n    AnimationAstBuilderVisitor.prototype._makeStyleAst = /**\n     * @param {?} metadata\n     * @param {?} context\n     * @return {?}\n     */\n    function (metadata, context) {\n        /** @type {?} */\n        var styles = [];\n        if (Array.isArray(metadata.styles)) {\n            (/** @type {?} */ (metadata.styles)).forEach(function (styleTuple) {\n                if (typeof styleTuple == 'string') {\n                    if (styleTuple == AUTO_STYLE) {\n                        styles.push(/** @type {?} */ (styleTuple));\n                    }\n                    else {\n                        context.errors.push(\"The provided style string value \" + styleTuple + \" is not allowed.\");\n                    }\n                }\n                else {\n                    styles.push(/** @type {?} */ (styleTuple));\n                }\n            });\n        }\n        else {\n            styles.push(metadata.styles);\n        }\n        /** @type {?} */\n        var containsDynamicStyles = false;\n        /** @type {?} */\n        var collectedEasing = null;\n        styles.forEach(function (styleData) {\n            if (isObject(styleData)) {\n                /** @type {?} */\n                var styleMap = /** @type {?} */ (styleData);\n                /** @type {?} */\n                var easing = styleMap['easing'];\n                if (easing) {\n                    collectedEasing = /** @type {?} */ (easing);\n                    delete styleMap['easing'];\n                }\n                if (!containsDynamicStyles) {\n                    for (var prop in styleMap) {\n                        /** @type {?} */\n                        var value = styleMap[prop];\n                        if (value.toString().indexOf(SUBSTITUTION_EXPR_START) >= 0) {\n                            containsDynamicStyles = true;\n                            break;\n                        }\n                    }\n                }\n            }\n        });\n        return {\n            type: 6 /* Style */,\n            styles: styles,\n            easing: collectedEasing,\n            offset: metadata.offset, containsDynamicStyles: containsDynamicStyles,\n            options: null\n        };\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AnimationAstBuilderVisitor.prototype._validateStyleAst = /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    function (ast, context) {\n        var _this = this;\n        /** @type {?} */\n        var timings = context.currentAnimateTimings;\n        /** @type {?} */\n        var endTime = context.currentTime;\n        /** @type {?} */\n        var startTime = context.currentTime;\n        if (timings && startTime > 0) {\n            startTime -= timings.duration + timings.delay;\n        }\n        ast.styles.forEach(function (tuple) {\n            if (typeof tuple == 'string')\n                return;\n            Object.keys(tuple).forEach(function (prop) {\n                if (!_this._driver.validateStyleProperty(prop)) {\n                    context.errors.push(\"The provided animation property \\\"\" + prop + \"\\\" is not a supported CSS property for animations\");\n                    return;\n                }\n                /** @type {?} */\n                var collectedStyles = context.collectedStyles[/** @type {?} */ ((context.currentQuerySelector))];\n                /** @type {?} */\n                var collectedEntry = collectedStyles[prop];\n                /** @type {?} */\n                var updateCollectedStyle = true;\n                if (collectedEntry) {\n                    if (startTime != endTime && startTime >= collectedEntry.startTime &&\n                        endTime <= collectedEntry.endTime) {\n                        context.errors.push(\"The CSS property \\\"\" + prop + \"\\\" that exists between the times of \\\"\" + collectedEntry.startTime + \"ms\\\" and \\\"\" + collectedEntry.endTime + \"ms\\\" is also being animated in a parallel animation between the times of \\\"\" + startTime + \"ms\\\" and \\\"\" + endTime + \"ms\\\"\");\n                        updateCollectedStyle = false;\n                    }\n                    // we always choose the smaller start time value since we\n                    // want to have a record of the entire animation window where\n                    // the style property is being animated in between\n                    startTime = collectedEntry.startTime;\n                }\n                if (updateCollectedStyle) {\n                    collectedStyles[prop] = { startTime: startTime, endTime: endTime };\n                }\n                if (context.options) {\n                    validateStyleParams(tuple[prop], context.options, context.errors);\n                }\n            });\n        });\n    };\n    /**\n     * @param {?} metadata\n     * @param {?} context\n     * @return {?}\n     */\n    AnimationAstBuilderVisitor.prototype.visitKeyframes = /**\n     * @param {?} metadata\n     * @param {?} context\n     * @return {?}\n     */\n    function (metadata, context) {\n        var _this = this;\n        /** @type {?} */\n        var ast = { type: 5 /* Keyframes */, styles: [], options: null };\n        if (!context.currentAnimateTimings) {\n            context.errors.push(\"keyframes() must be placed inside of a call to animate()\");\n            return ast;\n        }\n        /** @type {?} */\n        var MAX_KEYFRAME_OFFSET = 1;\n        /** @type {?} */\n        var totalKeyframesWithOffsets = 0;\n        /** @type {?} */\n        var offsets = [];\n        /** @type {?} */\n        var offsetsOutOfOrder = false;\n        /** @type {?} */\n        var keyframesOutOfRange = false;\n        /** @type {?} */\n        var previousOffset = 0;\n        /** @type {?} */\n        var keyframes = metadata.steps.map(function (styles) {\n            /** @type {?} */\n            var style = _this._makeStyleAst(styles, context);\n            /** @type {?} */\n            var offsetVal = style.offset != null ? style.offset : consumeOffset(style.styles);\n            /** @type {?} */\n            var offset = 0;\n            if (offsetVal != null) {\n                totalKeyframesWithOffsets++;\n                offset = style.offset = offsetVal;\n            }\n            keyframesOutOfRange = keyframesOutOfRange || offset < 0 || offset > 1;\n            offsetsOutOfOrder = offsetsOutOfOrder || offset < previousOffset;\n            previousOffset = offset;\n            offsets.push(offset);\n            return style;\n        });\n        if (keyframesOutOfRange) {\n            context.errors.push(\"Please ensure that all keyframe offsets are between 0 and 1\");\n        }\n        if (offsetsOutOfOrder) {\n            context.errors.push(\"Please ensure that all keyframe offsets are in order\");\n        }\n        /** @type {?} */\n        var length = metadata.steps.length;\n        /** @type {?} */\n        var generatedOffset = 0;\n        if (totalKeyframesWithOffsets > 0 && totalKeyframesWithOffsets < length) {\n            context.errors.push(\"Not all style() steps within the declared keyframes() contain offsets\");\n        }\n        else if (totalKeyframesWithOffsets == 0) {\n            generatedOffset = MAX_KEYFRAME_OFFSET / (length - 1);\n        }\n        /** @type {?} */\n        var limit = length - 1;\n        /** @type {?} */\n        var currentTime = context.currentTime;\n        /** @type {?} */\n        var currentAnimateTimings = /** @type {?} */ ((context.currentAnimateTimings));\n        /** @type {?} */\n        var animateDuration = currentAnimateTimings.duration;\n        keyframes.forEach(function (kf, i) {\n            /** @type {?} */\n            var offset = generatedOffset > 0 ? (i == limit ? 1 : (generatedOffset * i)) : offsets[i];\n            /** @type {?} */\n            var durationUpToThisFrame = offset * animateDuration;\n            context.currentTime = currentTime + currentAnimateTimings.delay + durationUpToThisFrame;\n            currentAnimateTimings.duration = durationUpToThisFrame;\n            _this._validateStyleAst(kf, context);\n            kf.offset = offset;\n            ast.styles.push(kf);\n        });\n        return ast;\n    };\n    /**\n     * @param {?} metadata\n     * @param {?} context\n     * @return {?}\n     */\n    AnimationAstBuilderVisitor.prototype.visitReference = /**\n     * @param {?} metadata\n     * @param {?} context\n     * @return {?}\n     */\n    function (metadata, context) {\n        return {\n            type: 8 /* Reference */,\n            animation: visitDslNode(this, normalizeAnimationEntry(metadata.animation), context),\n            options: normalizeAnimationOptions(metadata.options)\n        };\n    };\n    /**\n     * @param {?} metadata\n     * @param {?} context\n     * @return {?}\n     */\n    AnimationAstBuilderVisitor.prototype.visitAnimateChild = /**\n     * @param {?} metadata\n     * @param {?} context\n     * @return {?}\n     */\n    function (metadata, context) {\n        context.depCount++;\n        return {\n            type: 9 /* AnimateChild */,\n            options: normalizeAnimationOptions(metadata.options)\n        };\n    };\n    /**\n     * @param {?} metadata\n     * @param {?} context\n     * @return {?}\n     */\n    AnimationAstBuilderVisitor.prototype.visitAnimateRef = /**\n     * @param {?} metadata\n     * @param {?} context\n     * @return {?}\n     */\n    function (metadata, context) {\n        return {\n            type: 10 /* AnimateRef */,\n            animation: this.visitReference(metadata.animation, context),\n            options: normalizeAnimationOptions(metadata.options)\n        };\n    };\n    /**\n     * @param {?} metadata\n     * @param {?} context\n     * @return {?}\n     */\n    AnimationAstBuilderVisitor.prototype.visitQuery = /**\n     * @param {?} metadata\n     * @param {?} context\n     * @return {?}\n     */\n    function (metadata, context) {\n        /** @type {?} */\n        var parentSelector = /** @type {?} */ ((context.currentQuerySelector));\n        /** @type {?} */\n        var options = /** @type {?} */ ((metadata.options || {}));\n        context.queryCount++;\n        context.currentQuery = metadata;\n        var _a = normalizeSelector(metadata.selector), selector = _a[0], includeSelf = _a[1];\n        context.currentQuerySelector =\n            parentSelector.length ? (parentSelector + ' ' + selector) : selector;\n        getOrSetAsInMap(context.collectedStyles, context.currentQuerySelector, {});\n        /** @type {?} */\n        var animation = visitDslNode(this, normalizeAnimationEntry(metadata.animation), context);\n        context.currentQuery = null;\n        context.currentQuerySelector = parentSelector;\n        return {\n            type: 11 /* Query */,\n            selector: selector,\n            limit: options.limit || 0,\n            optional: !!options.optional, includeSelf: includeSelf, animation: animation,\n            originalSelector: metadata.selector,\n            options: normalizeAnimationOptions(metadata.options)\n        };\n    };\n    /**\n     * @param {?} metadata\n     * @param {?} context\n     * @return {?}\n     */\n    AnimationAstBuilderVisitor.prototype.visitStagger = /**\n     * @param {?} metadata\n     * @param {?} context\n     * @return {?}\n     */\n    function (metadata, context) {\n        if (!context.currentQuery) {\n            context.errors.push(\"stagger() can only be used inside of query()\");\n        }\n        /** @type {?} */\n        var timings = metadata.timings === 'full' ?\n            { duration: 0, delay: 0, easing: 'full' } :\n            resolveTiming(metadata.timings, context.errors, true);\n        return {\n            type: 12 /* Stagger */,\n            animation: visitDslNode(this, normalizeAnimationEntry(metadata.animation), context), timings: timings,\n            options: null\n        };\n    };\n    return AnimationAstBuilderVisitor;\n}());\nexport { AnimationAstBuilderVisitor };\nif (false) {\n    /** @type {?} */\n    AnimationAstBuilderVisitor.prototype._driver;\n}\n/**\n * @param {?} selector\n * @return {?}\n */\nfunction normalizeSelector(selector) {\n    /** @type {?} */\n    var hasAmpersand = selector.split(/\\s*,\\s*/).find(function (token) { return token == SELF_TOKEN; }) ? true : false;\n    if (hasAmpersand) {\n        selector = selector.replace(SELF_TOKEN_REGEX, '');\n    }\n    // the :enter and :leave selectors are filled in at runtime during timeline building\n    selector = selector.replace(/@\\*/g, NG_TRIGGER_SELECTOR)\n        .replace(/@\\w+/g, function (match) { return NG_TRIGGER_SELECTOR + '-' + match.substr(1); })\n        .replace(/:animating/g, NG_ANIMATING_SELECTOR);\n    return [selector, hasAmpersand];\n}\n/**\n * @param {?} obj\n * @return {?}\n */\nfunction normalizeParams(obj) {\n    return obj ? copyObj(obj) : null;\n}\n/** @typedef {?} */\nvar StyleTimeTuple;\nexport { StyleTimeTuple };\nvar AnimationAstBuilderContext = /** @class */ (function () {\n    function AnimationAstBuilderContext(errors) {\n        this.errors = errors;\n        this.queryCount = 0;\n        this.depCount = 0;\n        this.currentTransition = null;\n        this.currentQuery = null;\n        this.currentQuerySelector = null;\n        this.currentAnimateTimings = null;\n        this.currentTime = 0;\n        this.collectedStyles = {};\n        this.options = null;\n    }\n    return AnimationAstBuilderContext;\n}());\nexport { AnimationAstBuilderContext };\nif (false) {\n    /** @type {?} */\n    AnimationAstBuilderContext.prototype.queryCount;\n    /** @type {?} */\n    AnimationAstBuilderContext.prototype.depCount;\n    /** @type {?} */\n    AnimationAstBuilderContext.prototype.currentTransition;\n    /** @type {?} */\n    AnimationAstBuilderContext.prototype.currentQuery;\n    /** @type {?} */\n    AnimationAstBuilderContext.prototype.currentQuerySelector;\n    /** @type {?} */\n    AnimationAstBuilderContext.prototype.currentAnimateTimings;\n    /** @type {?} */\n    AnimationAstBuilderContext.prototype.currentTime;\n    /** @type {?} */\n    AnimationAstBuilderContext.prototype.collectedStyles;\n    /** @type {?} */\n    AnimationAstBuilderContext.prototype.options;\n    /** @type {?} */\n    AnimationAstBuilderContext.prototype.errors;\n}\n/**\n * @param {?} styles\n * @return {?}\n */\nfunction consumeOffset(styles) {\n    if (typeof styles == 'string')\n        return null;\n    /** @type {?} */\n    var offset = null;\n    if (Array.isArray(styles)) {\n        styles.forEach(function (styleTuple) {\n            if (isObject(styleTuple) && styleTuple.hasOwnProperty('offset')) {\n                /** @type {?} */\n                var obj = /** @type {?} */ (styleTuple);\n                offset = parseFloat(/** @type {?} */ (obj['offset']));\n                delete obj['offset'];\n            }\n        });\n    }\n    else if (isObject(styles) && styles.hasOwnProperty('offset')) {\n        /** @type {?} */\n        var obj = /** @type {?} */ (styles);\n        offset = parseFloat(/** @type {?} */ (obj['offset']));\n        delete obj['offset'];\n    }\n    return offset;\n}\n/**\n * @param {?} value\n * @return {?}\n */\nfunction isObject(value) {\n    return !Array.isArray(value) && typeof value == 'object';\n}\n/**\n * @param {?} value\n * @param {?} errors\n * @return {?}\n */\nfunction constructTimingAst(value, errors) {\n    /** @type {?} */\n    var timings = null;\n    if (value.hasOwnProperty('duration')) {\n        timings = /** @type {?} */ (value);\n    }\n    else if (typeof value == 'number') {\n        /** @type {?} */\n        var duration = resolveTiming(/** @type {?} */ (value), errors).duration;\n        return makeTimingAst(/** @type {?} */ (duration), 0, '');\n    }\n    /** @type {?} */\n    var strValue = /** @type {?} */ (value);\n    /** @type {?} */\n    var isDynamic = strValue.split(/\\s+/).some(function (v) { return v.charAt(0) == '{' && v.charAt(1) == '{'; });\n    if (isDynamic) {\n        /** @type {?} */\n        var ast = /** @type {?} */ (makeTimingAst(0, 0, ''));\n        ast.dynamic = true;\n        ast.strValue = strValue;\n        return /** @type {?} */ (ast);\n    }\n    timings = timings || resolveTiming(strValue, errors);\n    return makeTimingAst(timings.duration, timings.delay, timings.easing);\n}\n/**\n * @param {?} options\n * @return {?}\n */\nfunction normalizeAnimationOptions(options) {\n    if (options) {\n        options = copyObj(options);\n        if (options['params']) {\n            options['params'] = /** @type {?} */ ((normalizeParams(options['params'])));\n        }\n    }\n    else {\n        options = {};\n    }\n    return options;\n}\n/**\n * @param {?} duration\n * @param {?} delay\n * @param {?} easing\n * @return {?}\n */\nfunction makeTimingAst(duration, delay, easing) {\n    return { duration: duration, delay: delay, easing: easing };\n}\n//# sourceMappingURL=animation_ast_builder.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @record\n */\nexport function AnimationTimelineInstruction() { }\n/** @type {?} */\nAnimationTimelineInstruction.prototype.element;\n/** @type {?} */\nAnimationTimelineInstruction.prototype.keyframes;\n/** @type {?} */\nAnimationTimelineInstruction.prototype.preStyleProps;\n/** @type {?} */\nAnimationTimelineInstruction.prototype.postStyleProps;\n/** @type {?} */\nAnimationTimelineInstruction.prototype.duration;\n/** @type {?} */\nAnimationTimelineInstruction.prototype.delay;\n/** @type {?} */\nAnimationTimelineInstruction.prototype.totalTime;\n/** @type {?} */\nAnimationTimelineInstruction.prototype.easing;\n/** @type {?|undefined} */\nAnimationTimelineInstruction.prototype.stretchStartingKeyframe;\n/** @type {?} */\nAnimationTimelineInstruction.prototype.subTimeline;\n/**\n * @param {?} element\n * @param {?} keyframes\n * @param {?} preStyleProps\n * @param {?} postStyleProps\n * @param {?} duration\n * @param {?} delay\n * @param {?=} easing\n * @param {?=} subTimeline\n * @return {?}\n */\nexport function createTimelineInstruction(element, keyframes, preStyleProps, postStyleProps, duration, delay, easing, subTimeline) {\n    if (easing === void 0) { easing = null; }\n    if (subTimeline === void 0) { subTimeline = false; }\n    return {\n        type: 1 /* TimelineAnimation */,\n        element: element,\n        keyframes: keyframes,\n        preStyleProps: preStyleProps,\n        postStyleProps: postStyleProps,\n        duration: duration,\n        delay: delay,\n        totalTime: duration + delay, easing: easing, subTimeline: subTimeline\n    };\n}\n//# sourceMappingURL=animation_timeline_instruction.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar ElementInstructionMap = /** @class */ (function () {\n    function ElementInstructionMap() {\n        this._map = new Map();\n    }\n    /**\n     * @param {?} element\n     * @return {?}\n     */\n    ElementInstructionMap.prototype.consume = /**\n     * @param {?} element\n     * @return {?}\n     */\n    function (element) {\n        /** @type {?} */\n        var instructions = this._map.get(element);\n        if (instructions) {\n            this._map.delete(element);\n        }\n        else {\n            instructions = [];\n        }\n        return instructions;\n    };\n    /**\n     * @param {?} element\n     * @param {?} instructions\n     * @return {?}\n     */\n    ElementInstructionMap.prototype.append = /**\n     * @param {?} element\n     * @param {?} instructions\n     * @return {?}\n     */\n    function (element, instructions) {\n        /** @type {?} */\n        var existingInstructions = this._map.get(element);\n        if (!existingInstructions) {\n            this._map.set(element, existingInstructions = []);\n        }\n        existingInstructions.push.apply(existingInstructions, instructions);\n    };\n    /**\n     * @param {?} element\n     * @return {?}\n     */\n    ElementInstructionMap.prototype.has = /**\n     * @param {?} element\n     * @return {?}\n     */\n    function (element) { return this._map.has(element); };\n    /**\n     * @return {?}\n     */\n    ElementInstructionMap.prototype.clear = /**\n     * @return {?}\n     */\n    function () { this._map.clear(); };\n    return ElementInstructionMap;\n}());\nexport { ElementInstructionMap };\nif (false) {\n    /** @type {?} */\n    ElementInstructionMap.prototype._map;\n}\n//# sourceMappingURL=element_instruction_map.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nimport * as tslib_1 from \"tslib\";\nimport { AUTO_STYLE, ÉµPRE_STYLE as PRE_STYLE } from '@angular/animations';\nimport { copyObj, copyStyles, interpolateParams, iteratorToArray, resolveTiming, resolveTimingValue, visitDslNode } from '../util';\nimport { createTimelineInstruction } from './animation_timeline_instruction';\nimport { ElementInstructionMap } from './element_instruction_map';\n/** @type {?} */\nvar ONE_FRAME_IN_MILLISECONDS = 1;\n/** @type {?} */\nvar ENTER_TOKEN = ':enter';\n/** @type {?} */\nvar ENTER_TOKEN_REGEX = new RegExp(ENTER_TOKEN, 'g');\n/** @type {?} */\nvar LEAVE_TOKEN = ':leave';\n/** @type {?} */\nvar LEAVE_TOKEN_REGEX = new RegExp(LEAVE_TOKEN, 'g');\n/**\n * @param {?} driver\n * @param {?} rootElement\n * @param {?} ast\n * @param {?} enterClassName\n * @param {?} leaveClassName\n * @param {?=} startingStyles\n * @param {?=} finalStyles\n * @param {?=} options\n * @param {?=} subInstructions\n * @param {?=} errors\n * @return {?}\n */\nexport function buildAnimationTimelines(driver, rootElement, ast, enterClassName, leaveClassName, startingStyles, finalStyles, options, subInstructions, errors) {\n    if (startingStyles === void 0) { startingStyles = {}; }\n    if (finalStyles === void 0) { finalStyles = {}; }\n    if (errors === void 0) { errors = []; }\n    return new AnimationTimelineBuilderVisitor().buildKeyframes(driver, rootElement, ast, enterClassName, leaveClassName, startingStyles, finalStyles, options, subInstructions, errors);\n}\nvar AnimationTimelineBuilderVisitor = /** @class */ (function () {\n    function AnimationTimelineBuilderVisitor() {\n    }\n    /**\n     * @param {?} driver\n     * @param {?} rootElement\n     * @param {?} ast\n     * @param {?} enterClassName\n     * @param {?} leaveClassName\n     * @param {?} startingStyles\n     * @param {?} finalStyles\n     * @param {?} options\n     * @param {?=} subInstructions\n     * @param {?=} errors\n     * @return {?}\n     */\n    AnimationTimelineBuilderVisitor.prototype.buildKeyframes = /**\n     * @param {?} driver\n     * @param {?} rootElement\n     * @param {?} ast\n     * @param {?} enterClassName\n     * @param {?} leaveClassName\n     * @param {?} startingStyles\n     * @param {?} finalStyles\n     * @param {?} options\n     * @param {?=} subInstructions\n     * @param {?=} errors\n     * @return {?}\n     */\n    function (driver, rootElement, ast, enterClassName, leaveClassName, startingStyles, finalStyles, options, subInstructions, errors) {\n        if (errors === void 0) { errors = []; }\n        subInstructions = subInstructions || new ElementInstructionMap();\n        /** @type {?} */\n        var context = new AnimationTimelineContext(driver, rootElement, subInstructions, enterClassName, leaveClassName, errors, []);\n        context.options = options;\n        context.currentTimeline.setStyles([startingStyles], null, context.errors, options);\n        visitDslNode(this, ast, context);\n        /** @type {?} */\n        var timelines = context.timelines.filter(function (timeline) { return timeline.containsAnimation(); });\n        if (timelines.length && Object.keys(finalStyles).length) {\n            /** @type {?} */\n            var tl = timelines[timelines.length - 1];\n            if (!tl.allowOnlyTimelineStyles()) {\n                tl.setStyles([finalStyles], null, context.errors, options);\n            }\n        }\n        return timelines.length ? timelines.map(function (timeline) { return timeline.buildKeyframes(); }) :\n            [createTimelineInstruction(rootElement, [], [], [], 0, 0, '', false)];\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AnimationTimelineBuilderVisitor.prototype.visitTrigger = /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    function (ast, context) {\n        // these values are not visited in this AST\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AnimationTimelineBuilderVisitor.prototype.visitState = /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    function (ast, context) {\n        // these values are not visited in this AST\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AnimationTimelineBuilderVisitor.prototype.visitTransition = /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    function (ast, context) {\n        // these values are not visited in this AST\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AnimationTimelineBuilderVisitor.prototype.visitAnimateChild = /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    function (ast, context) {\n        /** @type {?} */\n        var elementInstructions = context.subInstructions.consume(context.element);\n        if (elementInstructions) {\n            /** @type {?} */\n            var innerContext = context.createSubContext(ast.options);\n            /** @type {?} */\n            var startTime = context.currentTimeline.currentTime;\n            /** @type {?} */\n            var endTime = this._visitSubInstructions(elementInstructions, innerContext, /** @type {?} */ (innerContext.options));\n            if (startTime != endTime) {\n                // we do this on the upper context because we created a sub context for\n                // the sub child animations\n                context.transformIntoNewTimeline(endTime);\n            }\n        }\n        context.previousNode = ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AnimationTimelineBuilderVisitor.prototype.visitAnimateRef = /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    function (ast, context) {\n        /** @type {?} */\n        var innerContext = context.createSubContext(ast.options);\n        innerContext.transformIntoNewTimeline();\n        this.visitReference(ast.animation, innerContext);\n        context.transformIntoNewTimeline(innerContext.currentTimeline.currentTime);\n        context.previousNode = ast;\n    };\n    /**\n     * @param {?} instructions\n     * @param {?} context\n     * @param {?} options\n     * @return {?}\n     */\n    AnimationTimelineBuilderVisitor.prototype._visitSubInstructions = /**\n     * @param {?} instructions\n     * @param {?} context\n     * @param {?} options\n     * @return {?}\n     */\n    function (instructions, context, options) {\n        /** @type {?} */\n        var startTime = context.currentTimeline.currentTime;\n        /** @type {?} */\n        var furthestTime = startTime;\n        /** @type {?} */\n        var duration = options.duration != null ? resolveTimingValue(options.duration) : null;\n        /** @type {?} */\n        var delay = options.delay != null ? resolveTimingValue(options.delay) : null;\n        if (duration !== 0) {\n            instructions.forEach(function (instruction) {\n                /** @type {?} */\n                var instructionTimings = context.appendInstructionToTimeline(instruction, duration, delay);\n                furthestTime =\n                    Math.max(furthestTime, instructionTimings.duration + instructionTimings.delay);\n            });\n        }\n        return furthestTime;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AnimationTimelineBuilderVisitor.prototype.visitReference = /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    function (ast, context) {\n        context.updateOptions(ast.options, true);\n        visitDslNode(this, ast.animation, context);\n        context.previousNode = ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AnimationTimelineBuilderVisitor.prototype.visitSequence = /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    function (ast, context) {\n        var _this = this;\n        /** @type {?} */\n        var subContextCount = context.subContextCount;\n        /** @type {?} */\n        var ctx = context;\n        /** @type {?} */\n        var options = ast.options;\n        if (options && (options.params || options.delay)) {\n            ctx = context.createSubContext(options);\n            ctx.transformIntoNewTimeline();\n            if (options.delay != null) {\n                if (ctx.previousNode.type == 6 /* Style */) {\n                    ctx.currentTimeline.snapshotCurrentStyles();\n                    ctx.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;\n                }\n                /** @type {?} */\n                var delay = resolveTimingValue(options.delay);\n                ctx.delayNextStep(delay);\n            }\n        }\n        if (ast.steps.length) {\n            ast.steps.forEach(function (s) { return visitDslNode(_this, s, ctx); });\n            // this is here just incase the inner steps only contain or end with a style() call\n            ctx.currentTimeline.applyStylesToKeyframe();\n            // this means that some animation function within the sequence\n            // ended up creating a sub timeline (which means the current\n            // timeline cannot overlap with the contents of the sequence)\n            if (ctx.subContextCount > subContextCount) {\n                ctx.transformIntoNewTimeline();\n            }\n        }\n        context.previousNode = ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AnimationTimelineBuilderVisitor.prototype.visitGroup = /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    function (ast, context) {\n        var _this = this;\n        /** @type {?} */\n        var innerTimelines = [];\n        /** @type {?} */\n        var furthestTime = context.currentTimeline.currentTime;\n        /** @type {?} */\n        var delay = ast.options && ast.options.delay ? resolveTimingValue(ast.options.delay) : 0;\n        ast.steps.forEach(function (s) {\n            /** @type {?} */\n            var innerContext = context.createSubContext(ast.options);\n            if (delay) {\n                innerContext.delayNextStep(delay);\n            }\n            visitDslNode(_this, s, innerContext);\n            furthestTime = Math.max(furthestTime, innerContext.currentTimeline.currentTime);\n            innerTimelines.push(innerContext.currentTimeline);\n        });\n        // this operation is run after the AST loop because otherwise\n        // if the parent timeline's collected styles were updated then\n        // it would pass in invalid data into the new-to-be forked items\n        innerTimelines.forEach(function (timeline) { return context.currentTimeline.mergeTimelineCollectedStyles(timeline); });\n        context.transformIntoNewTimeline(furthestTime);\n        context.previousNode = ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AnimationTimelineBuilderVisitor.prototype._visitTiming = /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    function (ast, context) {\n        if ((/** @type {?} */ (ast)).dynamic) {\n            /** @type {?} */\n            var strValue = (/** @type {?} */ (ast)).strValue;\n            /** @type {?} */\n            var timingValue = context.params ? interpolateParams(strValue, context.params, context.errors) : strValue;\n            return resolveTiming(timingValue, context.errors);\n        }\n        else {\n            return { duration: ast.duration, delay: ast.delay, easing: ast.easing };\n        }\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AnimationTimelineBuilderVisitor.prototype.visitAnimate = /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    function (ast, context) {\n        /** @type {?} */\n        var timings = context.currentAnimateTimings = this._visitTiming(ast.timings, context);\n        /** @type {?} */\n        var timeline = context.currentTimeline;\n        if (timings.delay) {\n            context.incrementTime(timings.delay);\n            timeline.snapshotCurrentStyles();\n        }\n        /** @type {?} */\n        var style = ast.style;\n        if (style.type == 5 /* Keyframes */) {\n            this.visitKeyframes(style, context);\n        }\n        else {\n            context.incrementTime(timings.duration);\n            this.visitStyle(/** @type {?} */ (style), context);\n            timeline.applyStylesToKeyframe();\n        }\n        context.currentAnimateTimings = null;\n        context.previousNode = ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AnimationTimelineBuilderVisitor.prototype.visitStyle = /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    function (ast, context) {\n        /** @type {?} */\n        var timeline = context.currentTimeline;\n        /** @type {?} */\n        var timings = /** @type {?} */ ((context.currentAnimateTimings));\n        // this is a special case for when a style() call\n        // directly follows  an animate() call (but not inside of an animate() call)\n        if (!timings && timeline.getCurrentStyleProperties().length) {\n            timeline.forwardFrame();\n        }\n        /** @type {?} */\n        var easing = (timings && timings.easing) || ast.easing;\n        if (ast.isEmptyStep) {\n            timeline.applyEmptyStep(easing);\n        }\n        else {\n            timeline.setStyles(ast.styles, easing, context.errors, context.options);\n        }\n        context.previousNode = ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AnimationTimelineBuilderVisitor.prototype.visitKeyframes = /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    function (ast, context) {\n        /** @type {?} */\n        var currentAnimateTimings = /** @type {?} */ ((context.currentAnimateTimings));\n        /** @type {?} */\n        var startTime = (/** @type {?} */ ((context.currentTimeline))).duration;\n        /** @type {?} */\n        var duration = currentAnimateTimings.duration;\n        /** @type {?} */\n        var innerContext = context.createSubContext();\n        /** @type {?} */\n        var innerTimeline = innerContext.currentTimeline;\n        innerTimeline.easing = currentAnimateTimings.easing;\n        ast.styles.forEach(function (step) {\n            /** @type {?} */\n            var offset = step.offset || 0;\n            innerTimeline.forwardTime(offset * duration);\n            innerTimeline.setStyles(step.styles, step.easing, context.errors, context.options);\n            innerTimeline.applyStylesToKeyframe();\n        });\n        // this will ensure that the parent timeline gets all the styles from\n        // the child even if the new timeline below is not used\n        context.currentTimeline.mergeTimelineCollectedStyles(innerTimeline);\n        // we do this because the window between this timeline and the sub timeline\n        // should ensure that the styles within are exactly the same as they were before\n        context.transformIntoNewTimeline(startTime + duration);\n        context.previousNode = ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AnimationTimelineBuilderVisitor.prototype.visitQuery = /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    function (ast, context) {\n        var _this = this;\n        /** @type {?} */\n        var startTime = context.currentTimeline.currentTime;\n        /** @type {?} */\n        var options = /** @type {?} */ ((ast.options || {}));\n        /** @type {?} */\n        var delay = options.delay ? resolveTimingValue(options.delay) : 0;\n        if (delay && (context.previousNode.type === 6 /* Style */ ||\n            (startTime == 0 && context.currentTimeline.getCurrentStyleProperties().length))) {\n            context.currentTimeline.snapshotCurrentStyles();\n            context.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;\n        }\n        /** @type {?} */\n        var furthestTime = startTime;\n        /** @type {?} */\n        var elms = context.invokeQuery(ast.selector, ast.originalSelector, ast.limit, ast.includeSelf, options.optional ? true : false, context.errors);\n        context.currentQueryTotal = elms.length;\n        /** @type {?} */\n        var sameElementTimeline = null;\n        elms.forEach(function (element, i) {\n            context.currentQueryIndex = i;\n            /** @type {?} */\n            var innerContext = context.createSubContext(ast.options, element);\n            if (delay) {\n                innerContext.delayNextStep(delay);\n            }\n            if (element === context.element) {\n                sameElementTimeline = innerContext.currentTimeline;\n            }\n            visitDslNode(_this, ast.animation, innerContext);\n            // this is here just incase the inner steps only contain or end\n            // with a style() call (which is here to signal that this is a preparatory\n            // call to style an element before it is animated again)\n            innerContext.currentTimeline.applyStylesToKeyframe();\n            /** @type {?} */\n            var endTime = innerContext.currentTimeline.currentTime;\n            furthestTime = Math.max(furthestTime, endTime);\n        });\n        context.currentQueryIndex = 0;\n        context.currentQueryTotal = 0;\n        context.transformIntoNewTimeline(furthestTime);\n        if (sameElementTimeline) {\n            context.currentTimeline.mergeTimelineCollectedStyles(sameElementTimeline);\n            context.currentTimeline.snapshotCurrentStyles();\n        }\n        context.previousNode = ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AnimationTimelineBuilderVisitor.prototype.visitStagger = /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    function (ast, context) {\n        /** @type {?} */\n        var parentContext = /** @type {?} */ ((context.parentContext));\n        /** @type {?} */\n        var tl = context.currentTimeline;\n        /** @type {?} */\n        var timings = ast.timings;\n        /** @type {?} */\n        var duration = Math.abs(timings.duration);\n        /** @type {?} */\n        var maxTime = duration * (context.currentQueryTotal - 1);\n        /** @type {?} */\n        var delay = duration * context.currentQueryIndex;\n        /** @type {?} */\n        var staggerTransformer = timings.duration < 0 ? 'reverse' : timings.easing;\n        switch (staggerTransformer) {\n            case 'reverse':\n                delay = maxTime - delay;\n                break;\n            case 'full':\n                delay = parentContext.currentStaggerTime;\n                break;\n        }\n        /** @type {?} */\n        var timeline = context.currentTimeline;\n        if (delay) {\n            timeline.delayNextStep(delay);\n        }\n        /** @type {?} */\n        var startingTime = timeline.currentTime;\n        visitDslNode(this, ast.animation, context);\n        context.previousNode = ast;\n        // time = duration + delay\n        // the reason why this computation is so complex is because\n        // the inner timeline may either have a delay value or a stretched\n        // keyframe depending on if a subtimeline is not used or is used.\n        parentContext.currentStaggerTime =\n            (tl.currentTime - startingTime) + (tl.startTime - parentContext.currentTimeline.startTime);\n    };\n    return AnimationTimelineBuilderVisitor;\n}());\nexport { AnimationTimelineBuilderVisitor };\n/** @type {?} */\nvar DEFAULT_NOOP_PREVIOUS_NODE = /** @type {?} */ ({});\nvar AnimationTimelineContext = /** @class */ (function () {\n    function AnimationTimelineContext(_driver, element, subInstructions, _enterClassName, _leaveClassName, errors, timelines, initialTimeline) {\n        this._driver = _driver;\n        this.element = element;\n        this.subInstructions = subInstructions;\n        this._enterClassName = _enterClassName;\n        this._leaveClassName = _leaveClassName;\n        this.errors = errors;\n        this.timelines = timelines;\n        this.parentContext = null;\n        this.currentAnimateTimings = null;\n        this.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;\n        this.subContextCount = 0;\n        this.options = {};\n        this.currentQueryIndex = 0;\n        this.currentQueryTotal = 0;\n        this.currentStaggerTime = 0;\n        this.currentTimeline = initialTimeline || new TimelineBuilder(this._driver, element, 0);\n        timelines.push(this.currentTimeline);\n    }\n    Object.defineProperty(AnimationTimelineContext.prototype, \"params\", {\n        get: /**\n         * @return {?}\n         */\n        function () { return this.options.params; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} options\n     * @param {?=} skipIfExists\n     * @return {?}\n     */\n    AnimationTimelineContext.prototype.updateOptions = /**\n     * @param {?} options\n     * @param {?=} skipIfExists\n     * @return {?}\n     */\n    function (options, skipIfExists) {\n        var _this = this;\n        if (!options)\n            return;\n        /** @type {?} */\n        var newOptions = /** @type {?} */ (options);\n        /** @type {?} */\n        var optionsToUpdate = this.options;\n        // NOTE: this will get patched up when other animation methods support duration overrides\n        if (newOptions.duration != null) {\n            (/** @type {?} */ (optionsToUpdate)).duration = resolveTimingValue(newOptions.duration);\n        }\n        if (newOptions.delay != null) {\n            optionsToUpdate.delay = resolveTimingValue(newOptions.delay);\n        }\n        /** @type {?} */\n        var newParams = newOptions.params;\n        if (newParams) {\n            /** @type {?} */\n            var paramsToUpdate_1 = /** @type {?} */ ((optionsToUpdate.params));\n            if (!paramsToUpdate_1) {\n                paramsToUpdate_1 = this.options.params = {};\n            }\n            Object.keys(newParams).forEach(function (name) {\n                if (!skipIfExists || !paramsToUpdate_1.hasOwnProperty(name)) {\n                    paramsToUpdate_1[name] = interpolateParams(newParams[name], paramsToUpdate_1, _this.errors);\n                }\n            });\n        }\n    };\n    /**\n     * @return {?}\n     */\n    AnimationTimelineContext.prototype._copyOptions = /**\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var options = {};\n        if (this.options) {\n            /** @type {?} */\n            var oldParams_1 = this.options.params;\n            if (oldParams_1) {\n                /** @type {?} */\n                var params_1 = options['params'] = {};\n                Object.keys(oldParams_1).forEach(function (name) { params_1[name] = oldParams_1[name]; });\n            }\n        }\n        return options;\n    };\n    /**\n     * @param {?=} options\n     * @param {?=} element\n     * @param {?=} newTime\n     * @return {?}\n     */\n    AnimationTimelineContext.prototype.createSubContext = /**\n     * @param {?=} options\n     * @param {?=} element\n     * @param {?=} newTime\n     * @return {?}\n     */\n    function (options, element, newTime) {\n        if (options === void 0) { options = null; }\n        /** @type {?} */\n        var target = element || this.element;\n        /** @type {?} */\n        var context = new AnimationTimelineContext(this._driver, target, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(target, newTime || 0));\n        context.previousNode = this.previousNode;\n        context.currentAnimateTimings = this.currentAnimateTimings;\n        context.options = this._copyOptions();\n        context.updateOptions(options);\n        context.currentQueryIndex = this.currentQueryIndex;\n        context.currentQueryTotal = this.currentQueryTotal;\n        context.parentContext = this;\n        this.subContextCount++;\n        return context;\n    };\n    /**\n     * @param {?=} newTime\n     * @return {?}\n     */\n    AnimationTimelineContext.prototype.transformIntoNewTimeline = /**\n     * @param {?=} newTime\n     * @return {?}\n     */\n    function (newTime) {\n        this.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;\n        this.currentTimeline = this.currentTimeline.fork(this.element, newTime);\n        this.timelines.push(this.currentTimeline);\n        return this.currentTimeline;\n    };\n    /**\n     * @param {?} instruction\n     * @param {?} duration\n     * @param {?} delay\n     * @return {?}\n     */\n    AnimationTimelineContext.prototype.appendInstructionToTimeline = /**\n     * @param {?} instruction\n     * @param {?} duration\n     * @param {?} delay\n     * @return {?}\n     */\n    function (instruction, duration, delay) {\n        /** @type {?} */\n        var updatedTimings = {\n            duration: duration != null ? duration : instruction.duration,\n            delay: this.currentTimeline.currentTime + (delay != null ? delay : 0) + instruction.delay,\n            easing: ''\n        };\n        /** @type {?} */\n        var builder = new SubTimelineBuilder(this._driver, instruction.element, instruction.keyframes, instruction.preStyleProps, instruction.postStyleProps, updatedTimings, instruction.stretchStartingKeyframe);\n        this.timelines.push(builder);\n        return updatedTimings;\n    };\n    /**\n     * @param {?} time\n     * @return {?}\n     */\n    AnimationTimelineContext.prototype.incrementTime = /**\n     * @param {?} time\n     * @return {?}\n     */\n    function (time) {\n        this.currentTimeline.forwardTime(this.currentTimeline.duration + time);\n    };\n    /**\n     * @param {?} delay\n     * @return {?}\n     */\n    AnimationTimelineContext.prototype.delayNextStep = /**\n     * @param {?} delay\n     * @return {?}\n     */\n    function (delay) {\n        // negative delays are not yet supported\n        if (delay > 0) {\n            this.currentTimeline.delayNextStep(delay);\n        }\n    };\n    /**\n     * @param {?} selector\n     * @param {?} originalSelector\n     * @param {?} limit\n     * @param {?} includeSelf\n     * @param {?} optional\n     * @param {?} errors\n     * @return {?}\n     */\n    AnimationTimelineContext.prototype.invokeQuery = /**\n     * @param {?} selector\n     * @param {?} originalSelector\n     * @param {?} limit\n     * @param {?} includeSelf\n     * @param {?} optional\n     * @param {?} errors\n     * @return {?}\n     */\n    function (selector, originalSelector, limit, includeSelf, optional, errors) {\n        /** @type {?} */\n        var results = [];\n        if (includeSelf) {\n            results.push(this.element);\n        }\n        if (selector.length > 0) { // if :self is only used then the selector is empty\n            // if :self is only used then the selector is empty\n            selector = selector.replace(ENTER_TOKEN_REGEX, '.' + this._enterClassName);\n            selector = selector.replace(LEAVE_TOKEN_REGEX, '.' + this._leaveClassName);\n            /** @type {?} */\n            var multi = limit != 1;\n            /** @type {?} */\n            var elements = this._driver.query(this.element, selector, multi);\n            if (limit !== 0) {\n                elements = limit < 0 ? elements.slice(elements.length + limit, elements.length) :\n                    elements.slice(0, limit);\n            }\n            results.push.apply(results, elements);\n        }\n        if (!optional && results.length == 0) {\n            errors.push(\"`query(\\\"\" + originalSelector + \"\\\")` returned zero elements. (Use `query(\\\"\" + originalSelector + \"\\\", { optional: true })` if you wish to allow this.)\");\n        }\n        return results;\n    };\n    return AnimationTimelineContext;\n}());\nexport { AnimationTimelineContext };\nif (false) {\n    /** @type {?} */\n    AnimationTimelineContext.prototype.parentContext;\n    /** @type {?} */\n    AnimationTimelineContext.prototype.currentTimeline;\n    /** @type {?} */\n    AnimationTimelineContext.prototype.currentAnimateTimings;\n    /** @type {?} */\n    AnimationTimelineContext.prototype.previousNode;\n    /** @type {?} */\n    AnimationTimelineContext.prototype.subContextCount;\n    /** @type {?} */\n    AnimationTimelineContext.prototype.options;\n    /** @type {?} */\n    AnimationTimelineContext.prototype.currentQueryIndex;\n    /** @type {?} */\n    AnimationTimelineContext.prototype.currentQueryTotal;\n    /** @type {?} */\n    AnimationTimelineContext.prototype.currentStaggerTime;\n    /** @type {?} */\n    AnimationTimelineContext.prototype._driver;\n    /** @type {?} */\n    AnimationTimelineContext.prototype.element;\n    /** @type {?} */\n    AnimationTimelineContext.prototype.subInstructions;\n    /** @type {?} */\n    AnimationTimelineContext.prototype._enterClassName;\n    /** @type {?} */\n    AnimationTimelineContext.prototype._leaveClassName;\n    /** @type {?} */\n    AnimationTimelineContext.prototype.errors;\n    /** @type {?} */\n    AnimationTimelineContext.prototype.timelines;\n}\nvar TimelineBuilder = /** @class */ (function () {\n    function TimelineBuilder(_driver, element, startTime, _elementTimelineStylesLookup) {\n        this._driver = _driver;\n        this.element = element;\n        this.startTime = startTime;\n        this._elementTimelineStylesLookup = _elementTimelineStylesLookup;\n        this.duration = 0;\n        this._previousKeyframe = {};\n        this._currentKeyframe = {};\n        this._keyframes = new Map();\n        this._styleSummary = {};\n        this._pendingStyles = {};\n        this._backFill = {};\n        this._currentEmptyStepKeyframe = null;\n        if (!this._elementTimelineStylesLookup) {\n            this._elementTimelineStylesLookup = new Map();\n        }\n        this._localTimelineStyles = Object.create(this._backFill, {});\n        this._globalTimelineStyles = /** @type {?} */ ((this._elementTimelineStylesLookup.get(element)));\n        if (!this._globalTimelineStyles) {\n            this._globalTimelineStyles = this._localTimelineStyles;\n            this._elementTimelineStylesLookup.set(element, this._localTimelineStyles);\n        }\n        this._loadKeyframe();\n    }\n    /**\n     * @return {?}\n     */\n    TimelineBuilder.prototype.containsAnimation = /**\n     * @return {?}\n     */\n    function () {\n        switch (this._keyframes.size) {\n            case 0:\n                return false;\n            case 1:\n                return this.getCurrentStyleProperties().length > 0;\n            default:\n                return true;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    TimelineBuilder.prototype.getCurrentStyleProperties = /**\n     * @return {?}\n     */\n    function () { return Object.keys(this._currentKeyframe); };\n    Object.defineProperty(TimelineBuilder.prototype, \"currentTime\", {\n        get: /**\n         * @return {?}\n         */\n        function () { return this.startTime + this.duration; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} delay\n     * @return {?}\n     */\n    TimelineBuilder.prototype.delayNextStep = /**\n     * @param {?} delay\n     * @return {?}\n     */\n    function (delay) {\n        /** @type {?} */\n        var hasPreStyleStep = this._keyframes.size == 1 && Object.keys(this._pendingStyles).length;\n        if (this.duration || hasPreStyleStep) {\n            this.forwardTime(this.currentTime + delay);\n            if (hasPreStyleStep) {\n                this.snapshotCurrentStyles();\n            }\n        }\n        else {\n            this.startTime += delay;\n        }\n    };\n    /**\n     * @param {?} element\n     * @param {?=} currentTime\n     * @return {?}\n     */\n    TimelineBuilder.prototype.fork = /**\n     * @param {?} element\n     * @param {?=} currentTime\n     * @return {?}\n     */\n    function (element, currentTime) {\n        this.applyStylesToKeyframe();\n        return new TimelineBuilder(this._driver, element, currentTime || this.currentTime, this._elementTimelineStylesLookup);\n    };\n    /**\n     * @return {?}\n     */\n    TimelineBuilder.prototype._loadKeyframe = /**\n     * @return {?}\n     */\n    function () {\n        if (this._currentKeyframe) {\n            this._previousKeyframe = this._currentKeyframe;\n        }\n        this._currentKeyframe = /** @type {?} */ ((this._keyframes.get(this.duration)));\n        if (!this._currentKeyframe) {\n            this._currentKeyframe = Object.create(this._backFill, {});\n            this._keyframes.set(this.duration, this._currentKeyframe);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    TimelineBuilder.prototype.forwardFrame = /**\n     * @return {?}\n     */\n    function () {\n        this.duration += ONE_FRAME_IN_MILLISECONDS;\n        this._loadKeyframe();\n    };\n    /**\n     * @param {?} time\n     * @return {?}\n     */\n    TimelineBuilder.prototype.forwardTime = /**\n     * @param {?} time\n     * @return {?}\n     */\n    function (time) {\n        this.applyStylesToKeyframe();\n        this.duration = time;\n        this._loadKeyframe();\n    };\n    /**\n     * @param {?} prop\n     * @param {?} value\n     * @return {?}\n     */\n    TimelineBuilder.prototype._updateStyle = /**\n     * @param {?} prop\n     * @param {?} value\n     * @return {?}\n     */\n    function (prop, value) {\n        this._localTimelineStyles[prop] = value;\n        this._globalTimelineStyles[prop] = value;\n        this._styleSummary[prop] = { time: this.currentTime, value: value };\n    };\n    /**\n     * @return {?}\n     */\n    TimelineBuilder.prototype.allowOnlyTimelineStyles = /**\n     * @return {?}\n     */\n    function () { return this._currentEmptyStepKeyframe !== this._currentKeyframe; };\n    /**\n     * @param {?} easing\n     * @return {?}\n     */\n    TimelineBuilder.prototype.applyEmptyStep = /**\n     * @param {?} easing\n     * @return {?}\n     */\n    function (easing) {\n        var _this = this;\n        if (easing) {\n            this._previousKeyframe['easing'] = easing;\n        }\n        // special case for animate(duration):\n        // all missing styles are filled with a `*` value then\n        // if any destination styles are filled in later on the same\n        // keyframe then they will override the overridden styles\n        // We use `_globalTimelineStyles` here because there may be\n        // styles in previous keyframes that are not present in this timeline\n        Object.keys(this._globalTimelineStyles).forEach(function (prop) {\n            _this._backFill[prop] = _this._globalTimelineStyles[prop] || AUTO_STYLE;\n            _this._currentKeyframe[prop] = AUTO_STYLE;\n        });\n        this._currentEmptyStepKeyframe = this._currentKeyframe;\n    };\n    /**\n     * @param {?} input\n     * @param {?} easing\n     * @param {?} errors\n     * @param {?=} options\n     * @return {?}\n     */\n    TimelineBuilder.prototype.setStyles = /**\n     * @param {?} input\n     * @param {?} easing\n     * @param {?} errors\n     * @param {?=} options\n     * @return {?}\n     */\n    function (input, easing, errors, options) {\n        var _this = this;\n        if (easing) {\n            this._previousKeyframe['easing'] = easing;\n        }\n        /** @type {?} */\n        var params = (options && options.params) || {};\n        /** @type {?} */\n        var styles = flattenStyles(input, this._globalTimelineStyles);\n        Object.keys(styles).forEach(function (prop) {\n            /** @type {?} */\n            var val = interpolateParams(styles[prop], params, errors);\n            _this._pendingStyles[prop] = val;\n            if (!_this._localTimelineStyles.hasOwnProperty(prop)) {\n                _this._backFill[prop] = _this._globalTimelineStyles.hasOwnProperty(prop) ?\n                    _this._globalTimelineStyles[prop] :\n                    AUTO_STYLE;\n            }\n            _this._updateStyle(prop, val);\n        });\n    };\n    /**\n     * @return {?}\n     */\n    TimelineBuilder.prototype.applyStylesToKeyframe = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        /** @type {?} */\n        var styles = this._pendingStyles;\n        /** @type {?} */\n        var props = Object.keys(styles);\n        if (props.length == 0)\n            return;\n        this._pendingStyles = {};\n        props.forEach(function (prop) {\n            /** @type {?} */\n            var val = styles[prop];\n            _this._currentKeyframe[prop] = val;\n        });\n        Object.keys(this._localTimelineStyles).forEach(function (prop) {\n            if (!_this._currentKeyframe.hasOwnProperty(prop)) {\n                _this._currentKeyframe[prop] = _this._localTimelineStyles[prop];\n            }\n        });\n    };\n    /**\n     * @return {?}\n     */\n    TimelineBuilder.prototype.snapshotCurrentStyles = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        Object.keys(this._localTimelineStyles).forEach(function (prop) {\n            /** @type {?} */\n            var val = _this._localTimelineStyles[prop];\n            _this._pendingStyles[prop] = val;\n            _this._updateStyle(prop, val);\n        });\n    };\n    /**\n     * @return {?}\n     */\n    TimelineBuilder.prototype.getFinalKeyframe = /**\n     * @return {?}\n     */\n    function () { return this._keyframes.get(this.duration); };\n    Object.defineProperty(TimelineBuilder.prototype, \"properties\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            /** @type {?} */\n            var properties = [];\n            for (var prop in this._currentKeyframe) {\n                properties.push(prop);\n            }\n            return properties;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} timeline\n     * @return {?}\n     */\n    TimelineBuilder.prototype.mergeTimelineCollectedStyles = /**\n     * @param {?} timeline\n     * @return {?}\n     */\n    function (timeline) {\n        var _this = this;\n        Object.keys(timeline._styleSummary).forEach(function (prop) {\n            /** @type {?} */\n            var details0 = _this._styleSummary[prop];\n            /** @type {?} */\n            var details1 = timeline._styleSummary[prop];\n            if (!details0 || details1.time > details0.time) {\n                _this._updateStyle(prop, details1.value);\n            }\n        });\n    };\n    /**\n     * @return {?}\n     */\n    TimelineBuilder.prototype.buildKeyframes = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this.applyStylesToKeyframe();\n        /** @type {?} */\n        var preStyleProps = new Set();\n        /** @type {?} */\n        var postStyleProps = new Set();\n        /** @type {?} */\n        var isEmpty = this._keyframes.size === 1 && this.duration === 0;\n        /** @type {?} */\n        var finalKeyframes = [];\n        this._keyframes.forEach(function (keyframe, time) {\n            /** @type {?} */\n            var finalKeyframe = copyStyles(keyframe, true);\n            Object.keys(finalKeyframe).forEach(function (prop) {\n                /** @type {?} */\n                var value = finalKeyframe[prop];\n                if (value == PRE_STYLE) {\n                    preStyleProps.add(prop);\n                }\n                else if (value == AUTO_STYLE) {\n                    postStyleProps.add(prop);\n                }\n            });\n            if (!isEmpty) {\n                finalKeyframe['offset'] = time / _this.duration;\n            }\n            finalKeyframes.push(finalKeyframe);\n        });\n        /** @type {?} */\n        var preProps = preStyleProps.size ? iteratorToArray(preStyleProps.values()) : [];\n        /** @type {?} */\n        var postProps = postStyleProps.size ? iteratorToArray(postStyleProps.values()) : [];\n        // special case for a 0-second animation (which is designed just to place styles onscreen)\n        if (isEmpty) {\n            /** @type {?} */\n            var kf0 = finalKeyframes[0];\n            /** @type {?} */\n            var kf1 = copyObj(kf0);\n            kf0['offset'] = 0;\n            kf1['offset'] = 1;\n            finalKeyframes = [kf0, kf1];\n        }\n        return createTimelineInstruction(this.element, finalKeyframes, preProps, postProps, this.duration, this.startTime, this.easing, false);\n    };\n    return TimelineBuilder;\n}());\nexport { TimelineBuilder };\nif (false) {\n    /** @type {?} */\n    TimelineBuilder.prototype.duration;\n    /** @type {?} */\n    TimelineBuilder.prototype.easing;\n    /** @type {?} */\n    TimelineBuilder.prototype._previousKeyframe;\n    /** @type {?} */\n    TimelineBuilder.prototype._currentKeyframe;\n    /** @type {?} */\n    TimelineBuilder.prototype._keyframes;\n    /** @type {?} */\n    TimelineBuilder.prototype._styleSummary;\n    /** @type {?} */\n    TimelineBuilder.prototype._localTimelineStyles;\n    /** @type {?} */\n    TimelineBuilder.prototype._globalTimelineStyles;\n    /** @type {?} */\n    TimelineBuilder.prototype._pendingStyles;\n    /** @type {?} */\n    TimelineBuilder.prototype._backFill;\n    /** @type {?} */\n    TimelineBuilder.prototype._currentEmptyStepKeyframe;\n    /** @type {?} */\n    TimelineBuilder.prototype._driver;\n    /** @type {?} */\n    TimelineBuilder.prototype.element;\n    /** @type {?} */\n    TimelineBuilder.prototype.startTime;\n    /** @type {?} */\n    TimelineBuilder.prototype._elementTimelineStylesLookup;\n}\nvar SubTimelineBuilder = /** @class */ (function (_super) {\n    tslib_1.__extends(SubTimelineBuilder, _super);\n    function SubTimelineBuilder(driver, element, keyframes, preStyleProps, postStyleProps, timings, _stretchStartingKeyframe) {\n        if (_stretchStartingKeyframe === void 0) { _stretchStartingKeyframe = false; }\n        var _this = _super.call(this, driver, element, timings.delay) || this;\n        _this.element = element;\n        _this.keyframes = keyframes;\n        _this.preStyleProps = preStyleProps;\n        _this.postStyleProps = postStyleProps;\n        _this._stretchStartingKeyframe = _stretchStartingKeyframe;\n        _this.timings = { duration: timings.duration, delay: timings.delay, easing: timings.easing };\n        return _this;\n    }\n    /**\n     * @return {?}\n     */\n    SubTimelineBuilder.prototype.containsAnimation = /**\n     * @return {?}\n     */\n    function () { return this.keyframes.length > 1; };\n    /**\n     * @return {?}\n     */\n    SubTimelineBuilder.prototype.buildKeyframes = /**\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var keyframes = this.keyframes;\n        var _a = this.timings, delay = _a.delay, duration = _a.duration, easing = _a.easing;\n        if (this._stretchStartingKeyframe && delay) {\n            /** @type {?} */\n            var newKeyframes = [];\n            /** @type {?} */\n            var totalTime = duration + delay;\n            /** @type {?} */\n            var startingGap = delay / totalTime;\n            /** @type {?} */\n            var newFirstKeyframe = copyStyles(keyframes[0], false);\n            newFirstKeyframe['offset'] = 0;\n            newKeyframes.push(newFirstKeyframe);\n            /** @type {?} */\n            var oldFirstKeyframe = copyStyles(keyframes[0], false);\n            oldFirstKeyframe['offset'] = roundOffset(startingGap);\n            newKeyframes.push(oldFirstKeyframe);\n            /** @type {?} */\n            var limit = keyframes.length - 1;\n            for (var i = 1; i <= limit; i++) {\n                /** @type {?} */\n                var kf = copyStyles(keyframes[i], false);\n                /** @type {?} */\n                var oldOffset = /** @type {?} */ (kf['offset']);\n                /** @type {?} */\n                var timeAtKeyframe = delay + oldOffset * duration;\n                kf['offset'] = roundOffset(timeAtKeyframe / totalTime);\n                newKeyframes.push(kf);\n            }\n            // the new starting keyframe should be added at the start\n            duration = totalTime;\n            delay = 0;\n            easing = '';\n            keyframes = newKeyframes;\n        }\n        return createTimelineInstruction(this.element, keyframes, this.preStyleProps, this.postStyleProps, duration, delay, easing, true);\n    };\n    return SubTimelineBuilder;\n}(TimelineBuilder));\nif (false) {\n    /** @type {?} */\n    SubTimelineBuilder.prototype.timings;\n    /** @type {?} */\n    SubTimelineBuilder.prototype.element;\n    /** @type {?} */\n    SubTimelineBuilder.prototype.keyframes;\n    /** @type {?} */\n    SubTimelineBuilder.prototype.preStyleProps;\n    /** @type {?} */\n    SubTimelineBuilder.prototype.postStyleProps;\n    /** @type {?} */\n    SubTimelineBuilder.prototype._stretchStartingKeyframe;\n}\n/**\n * @param {?} offset\n * @param {?=} decimalPoints\n * @return {?}\n */\nfunction roundOffset(offset, decimalPoints) {\n    if (decimalPoints === void 0) { decimalPoints = 3; }\n    /** @type {?} */\n    var mult = Math.pow(10, decimalPoints - 1);\n    return Math.round(offset * mult) / mult;\n}\n/**\n * @param {?} input\n * @param {?} allStyles\n * @return {?}\n */\nfunction flattenStyles(input, allStyles) {\n    /** @type {?} */\n    var styles = {};\n    /** @type {?} */\n    var allProperties;\n    input.forEach(function (token) {\n        if (token === '*') {\n            allProperties = allProperties || Object.keys(allStyles);\n            allProperties.forEach(function (prop) { styles[prop] = AUTO_STYLE; });\n        }\n        else {\n            copyStyles(/** @type {?} */ (token), false, styles);\n        }\n    });\n    return styles;\n}\n//# sourceMappingURL=animation_timeline_builder.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nimport * as tslib_1 from \"tslib\";\nimport { dashCaseToCamelCase } from '../../util';\nimport { AnimationStyleNormalizer } from './animation_style_normalizer';\nvar WebAnimationsStyleNormalizer = /** @class */ (function (_super) {\n    tslib_1.__extends(WebAnimationsStyleNormalizer, _super);\n    function WebAnimationsStyleNormalizer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {?} propertyName\n     * @param {?} errors\n     * @return {?}\n     */\n    WebAnimationsStyleNormalizer.prototype.normalizePropertyName = /**\n     * @param {?} propertyName\n     * @param {?} errors\n     * @return {?}\n     */\n    function (propertyName, errors) {\n        return dashCaseToCamelCase(propertyName);\n    };\n    /**\n     * @param {?} userProvidedProperty\n     * @param {?} normalizedProperty\n     * @param {?} value\n     * @param {?} errors\n     * @return {?}\n     */\n    WebAnimationsStyleNormalizer.prototype.normalizeStyleValue = /**\n     * @param {?} userProvidedProperty\n     * @param {?} normalizedProperty\n     * @param {?} value\n     * @param {?} errors\n     * @return {?}\n     */\n    function (userProvidedProperty, normalizedProperty, value, errors) {\n        /** @type {?} */\n        var unit = '';\n        /** @type {?} */\n        var strVal = value.toString().trim();\n        if (DIMENSIONAL_PROP_MAP[normalizedProperty] && value !== 0 && value !== '0') {\n            if (typeof value === 'number') {\n                unit = 'px';\n            }\n            else {\n                /** @type {?} */\n                var valAndSuffixMatch = value.match(/^[+-]?[\\d\\.]+([a-z]*)$/);\n                if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {\n                    errors.push(\"Please provide a CSS unit value for \" + userProvidedProperty + \":\" + value);\n                }\n            }\n        }\n        return strVal + unit;\n    };\n    return WebAnimationsStyleNormalizer;\n}(AnimationStyleNormalizer));\nexport { WebAnimationsStyleNormalizer };\n/** @type {?} */\nvar DIMENSIONAL_PROP_MAP = makeBooleanMap('width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective'\n    .split(','));\n/**\n * @param {?} keys\n * @return {?}\n */\nfunction makeBooleanMap(keys) {\n    /** @type {?} */\n    var map = {};\n    keys.forEach(function (key) { return map[key] = true; });\n    return map;\n}\n//# sourceMappingURL=web_animations_style_normalizer.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nimport { ENTER_CLASSNAME, LEAVE_CLASSNAME, normalizeStyles } from '../util';\nimport { buildAnimationAst } from './animation_ast_builder';\nimport { buildAnimationTimelines } from './animation_timeline_builder';\nimport { ElementInstructionMap } from './element_instruction_map';\nvar Animation = /** @class */ (function () {\n    function Animation(_driver, input) {\n        this._driver = _driver;\n        /** @type {?} */\n        var errors = [];\n        /** @type {?} */\n        var ast = buildAnimationAst(_driver, input, errors);\n        if (errors.length) {\n            /** @type {?} */\n            var errorMessage = \"animation validation failed:\\n\" + errors.join(\"\\n\");\n            throw new Error(errorMessage);\n        }\n        this._animationAst = ast;\n    }\n    /**\n     * @param {?} element\n     * @param {?} startingStyles\n     * @param {?} destinationStyles\n     * @param {?} options\n     * @param {?=} subInstructions\n     * @return {?}\n     */\n    Animation.prototype.buildTimelines = /**\n     * @param {?} element\n     * @param {?} startingStyles\n     * @param {?} destinationStyles\n     * @param {?} options\n     * @param {?=} subInstructions\n     * @return {?}\n     */\n    function (element, startingStyles, destinationStyles, options, subInstructions) {\n        /** @type {?} */\n        var start = Array.isArray(startingStyles) ? normalizeStyles(startingStyles) : /** @type {?} */ (startingStyles);\n        /** @type {?} */\n        var dest = Array.isArray(destinationStyles) ? normalizeStyles(destinationStyles) : /** @type {?} */ (destinationStyles);\n        /** @type {?} */\n        var errors = [];\n        subInstructions = subInstructions || new ElementInstructionMap();\n        /** @type {?} */\n        var result = buildAnimationTimelines(this._driver, element, this._animationAst, ENTER_CLASSNAME, LEAVE_CLASSNAME, start, dest, options, subInstructions, errors);\n        if (errors.length) {\n            /** @type {?} */\n            var errorMessage = \"animation building failed:\\n\" + errors.join(\"\\n\");\n            throw new Error(errorMessage);\n        }\n        return result;\n    };\n    return Animation;\n}());\nexport { Animation };\nif (false) {\n    /** @type {?} */\n    Animation.prototype._animationAst;\n    /** @type {?} */\n    Animation.prototype._driver;\n}\n//# sourceMappingURL=animation.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * \\@publicApi\n * @abstract\n */\nvar /**\n * \\@publicApi\n * @abstract\n */\nAnimationStyleNormalizer = /** @class */ (function () {\n    function AnimationStyleNormalizer() {\n    }\n    return AnimationStyleNormalizer;\n}());\n/**\n * \\@publicApi\n * @abstract\n */\nexport { AnimationStyleNormalizer };\nif (false) {\n    /**\n     * @abstract\n     * @param {?} propertyName\n     * @param {?} errors\n     * @return {?}\n     */\n    AnimationStyleNormalizer.prototype.normalizePropertyName = function (propertyName, errors) { };\n    /**\n     * @abstract\n     * @param {?} userProvidedProperty\n     * @param {?} normalizedProperty\n     * @param {?} value\n     * @param {?} errors\n     * @return {?}\n     */\n    AnimationStyleNormalizer.prototype.normalizeStyleValue = function (userProvidedProperty, normalizedProperty, value, errors) { };\n}\n/**\n * \\@publicApi\n */\nvar /**\n * \\@publicApi\n */\nNoopAnimationStyleNormalizer = /** @class */ (function () {\n    function NoopAnimationStyleNormalizer() {\n    }\n    /**\n     * @param {?} propertyName\n     * @param {?} errors\n     * @return {?}\n     */\n    NoopAnimationStyleNormalizer.prototype.normalizePropertyName = /**\n     * @param {?} propertyName\n     * @param {?} errors\n     * @return {?}\n     */\n    function (propertyName, errors) { return propertyName; };\n    /**\n     * @param {?} userProvidedProperty\n     * @param {?} normalizedProperty\n     * @param {?} value\n     * @param {?} errors\n     * @return {?}\n     */\n    NoopAnimationStyleNormalizer.prototype.normalizeStyleValue = /**\n     * @param {?} userProvidedProperty\n     * @param {?} normalizedProperty\n     * @param {?} value\n     * @param {?} errors\n     * @return {?}\n     */\n    function (userProvidedProperty, normalizedProperty, value, errors) {\n        return /** @type {?} */ (value);\n    };\n    return NoopAnimationStyleNormalizer;\n}());\n/**\n * \\@publicApi\n */\nexport { NoopAnimationStyleNormalizer };\n//# sourceMappingURL=animation_style_normalizer.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @record\n */\nexport function AnimationTransitionInstruction() { }\n/** @type {?} */\nAnimationTransitionInstruction.prototype.element;\n/** @type {?} */\nAnimationTransitionInstruction.prototype.triggerName;\n/** @type {?} */\nAnimationTransitionInstruction.prototype.isRemovalTransition;\n/** @type {?} */\nAnimationTransitionInstruction.prototype.fromState;\n/** @type {?} */\nAnimationTransitionInstruction.prototype.fromStyles;\n/** @type {?} */\nAnimationTransitionInstruction.prototype.toState;\n/** @type {?} */\nAnimationTransitionInstruction.prototype.toStyles;\n/** @type {?} */\nAnimationTransitionInstruction.prototype.timelines;\n/** @type {?} */\nAnimationTransitionInstruction.prototype.queriedElements;\n/** @type {?} */\nAnimationTransitionInstruction.prototype.preStyleProps;\n/** @type {?} */\nAnimationTransitionInstruction.prototype.postStyleProps;\n/** @type {?} */\nAnimationTransitionInstruction.prototype.totalTime;\n/** @type {?|undefined} */\nAnimationTransitionInstruction.prototype.errors;\n/**\n * @param {?} element\n * @param {?} triggerName\n * @param {?} fromState\n * @param {?} toState\n * @param {?} isRemovalTransition\n * @param {?} fromStyles\n * @param {?} toStyles\n * @param {?} timelines\n * @param {?} queriedElements\n * @param {?} preStyleProps\n * @param {?} postStyleProps\n * @param {?} totalTime\n * @param {?=} errors\n * @return {?}\n */\nexport function createTransitionInstruction(element, triggerName, fromState, toState, isRemovalTransition, fromStyles, toStyles, timelines, queriedElements, preStyleProps, postStyleProps, totalTime, errors) {\n    return {\n        type: 0 /* TransitionAnimation */,\n        element: element,\n        triggerName: triggerName,\n        isRemovalTransition: isRemovalTransition,\n        fromState: fromState,\n        fromStyles: fromStyles,\n        toState: toState,\n        toStyles: toStyles,\n        timelines: timelines,\n        queriedElements: queriedElements,\n        preStyleProps: preStyleProps,\n        postStyleProps: postStyleProps,\n        totalTime: totalTime,\n        errors: errors\n    };\n}\n//# sourceMappingURL=animation_transition_instruction.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nimport * as tslib_1 from \"tslib\";\nimport { getOrSetAsInMap } from '../render/shared';\nimport { copyObj, interpolateParams, iteratorToArray } from '../util';\nimport { buildAnimationTimelines } from './animation_timeline_builder';\nimport { createTransitionInstruction } from './animation_transition_instruction';\n/** @type {?} */\nvar EMPTY_OBJECT = {};\nvar AnimationTransitionFactory = /** @class */ (function () {\n    function AnimationTransitionFactory(_triggerName, ast, _stateStyles) {\n        this._triggerName = _triggerName;\n        this.ast = ast;\n        this._stateStyles = _stateStyles;\n    }\n    /**\n     * @param {?} currentState\n     * @param {?} nextState\n     * @param {?} element\n     * @param {?} params\n     * @return {?}\n     */\n    AnimationTransitionFactory.prototype.match = /**\n     * @param {?} currentState\n     * @param {?} nextState\n     * @param {?} element\n     * @param {?} params\n     * @return {?}\n     */\n    function (currentState, nextState, element, params) {\n        return oneOrMoreTransitionsMatch(this.ast.matchers, currentState, nextState, element, params);\n    };\n    /**\n     * @param {?} stateName\n     * @param {?} params\n     * @param {?} errors\n     * @return {?}\n     */\n    AnimationTransitionFactory.prototype.buildStyles = /**\n     * @param {?} stateName\n     * @param {?} params\n     * @param {?} errors\n     * @return {?}\n     */\n    function (stateName, params, errors) {\n        /** @type {?} */\n        var backupStateStyler = this._stateStyles['*'];\n        /** @type {?} */\n        var stateStyler = this._stateStyles[stateName];\n        /** @type {?} */\n        var backupStyles = backupStateStyler ? backupStateStyler.buildStyles(params, errors) : {};\n        return stateStyler ? stateStyler.buildStyles(params, errors) : backupStyles;\n    };\n    /**\n     * @param {?} driver\n     * @param {?} element\n     * @param {?} currentState\n     * @param {?} nextState\n     * @param {?} enterClassName\n     * @param {?} leaveClassName\n     * @param {?=} currentOptions\n     * @param {?=} nextOptions\n     * @param {?=} subInstructions\n     * @param {?=} skipAstBuild\n     * @return {?}\n     */\n    AnimationTransitionFactory.prototype.build = /**\n     * @param {?} driver\n     * @param {?} element\n     * @param {?} currentState\n     * @param {?} nextState\n     * @param {?} enterClassName\n     * @param {?} leaveClassName\n     * @param {?=} currentOptions\n     * @param {?=} nextOptions\n     * @param {?=} subInstructions\n     * @param {?=} skipAstBuild\n     * @return {?}\n     */\n    function (driver, element, currentState, nextState, enterClassName, leaveClassName, currentOptions, nextOptions, subInstructions, skipAstBuild) {\n        /** @type {?} */\n        var errors = [];\n        /** @type {?} */\n        var transitionAnimationParams = this.ast.options && this.ast.options.params || EMPTY_OBJECT;\n        /** @type {?} */\n        var currentAnimationParams = currentOptions && currentOptions.params || EMPTY_OBJECT;\n        /** @type {?} */\n        var currentStateStyles = this.buildStyles(currentState, currentAnimationParams, errors);\n        /** @type {?} */\n        var nextAnimationParams = nextOptions && nextOptions.params || EMPTY_OBJECT;\n        /** @type {?} */\n        var nextStateStyles = this.buildStyles(nextState, nextAnimationParams, errors);\n        /** @type {?} */\n        var queriedElements = new Set();\n        /** @type {?} */\n        var preStyleMap = new Map();\n        /** @type {?} */\n        var postStyleMap = new Map();\n        /** @type {?} */\n        var isRemoval = nextState === 'void';\n        /** @type {?} */\n        var animationOptions = { params: tslib_1.__assign({}, transitionAnimationParams, nextAnimationParams) };\n        /** @type {?} */\n        var timelines = skipAstBuild ? [] : buildAnimationTimelines(driver, element, this.ast.animation, enterClassName, leaveClassName, currentStateStyles, nextStateStyles, animationOptions, subInstructions, errors);\n        /** @type {?} */\n        var totalTime = 0;\n        timelines.forEach(function (tl) { totalTime = Math.max(tl.duration + tl.delay, totalTime); });\n        if (errors.length) {\n            return createTransitionInstruction(element, this._triggerName, currentState, nextState, isRemoval, currentStateStyles, nextStateStyles, [], [], preStyleMap, postStyleMap, totalTime, errors);\n        }\n        timelines.forEach(function (tl) {\n            /** @type {?} */\n            var elm = tl.element;\n            /** @type {?} */\n            var preProps = getOrSetAsInMap(preStyleMap, elm, {});\n            tl.preStyleProps.forEach(function (prop) { return preProps[prop] = true; });\n            /** @type {?} */\n            var postProps = getOrSetAsInMap(postStyleMap, elm, {});\n            tl.postStyleProps.forEach(function (prop) { return postProps[prop] = true; });\n            if (elm !== element) {\n                queriedElements.add(elm);\n            }\n        });\n        /** @type {?} */\n        var queriedElementsList = iteratorToArray(queriedElements.values());\n        return createTransitionInstruction(element, this._triggerName, currentState, nextState, isRemoval, currentStateStyles, nextStateStyles, timelines, queriedElementsList, preStyleMap, postStyleMap, totalTime);\n    };\n    return AnimationTransitionFactory;\n}());\nexport { AnimationTransitionFactory };\nif (false) {\n    /** @type {?} */\n    AnimationTransitionFactory.prototype._triggerName;\n    /** @type {?} */\n    AnimationTransitionFactory.prototype.ast;\n    /** @type {?} */\n    AnimationTransitionFactory.prototype._stateStyles;\n}\n/**\n * @param {?} matchFns\n * @param {?} currentState\n * @param {?} nextState\n * @param {?} element\n * @param {?} params\n * @return {?}\n */\nfunction oneOrMoreTransitionsMatch(matchFns, currentState, nextState, element, params) {\n    return matchFns.some(function (fn) { return fn(currentState, nextState, element, params); });\n}\nvar AnimationStateStyles = /** @class */ (function () {\n    function AnimationStateStyles(styles, defaultParams) {\n        this.styles = styles;\n        this.defaultParams = defaultParams;\n    }\n    /**\n     * @param {?} params\n     * @param {?} errors\n     * @return {?}\n     */\n    AnimationStateStyles.prototype.buildStyles = /**\n     * @param {?} params\n     * @param {?} errors\n     * @return {?}\n     */\n    function (params, errors) {\n        /** @type {?} */\n        var finalStyles = {};\n        /** @type {?} */\n        var combinedParams = copyObj(this.defaultParams);\n        Object.keys(params).forEach(function (key) {\n            /** @type {?} */\n            var value = params[key];\n            if (value != null) {\n                combinedParams[key] = value;\n            }\n        });\n        this.styles.styles.forEach(function (value) {\n            if (typeof value !== 'string') {\n                /** @type {?} */\n                var styleObj_1 = /** @type {?} */ (value);\n                Object.keys(styleObj_1).forEach(function (prop) {\n                    /** @type {?} */\n                    var val = styleObj_1[prop];\n                    if (val.length > 1) {\n                        val = interpolateParams(val, combinedParams, errors);\n                    }\n                    finalStyles[prop] = val;\n                });\n            }\n        });\n        return finalStyles;\n    };\n    return AnimationStateStyles;\n}());\nexport { AnimationStateStyles };\nif (false) {\n    /** @type {?} */\n    AnimationStateStyles.prototype.styles;\n    /** @type {?} */\n    AnimationStateStyles.prototype.defaultParams;\n}\n//# sourceMappingURL=animation_transition_factory.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nimport { AnimationStateStyles, AnimationTransitionFactory } from './animation_transition_factory';\n/**\n * \\@publicApi\n * @param {?} name\n * @param {?} ast\n * @return {?}\n */\nexport function buildTrigger(name, ast) {\n    return new AnimationTrigger(name, ast);\n}\n/**\n * \\@publicApi\n */\nvar /**\n * \\@publicApi\n */\nAnimationTrigger = /** @class */ (function () {\n    function AnimationTrigger(name, ast) {\n        var _this = this;\n        this.name = name;\n        this.ast = ast;\n        this.transitionFactories = [];\n        this.states = {};\n        ast.states.forEach(function (ast) {\n            /** @type {?} */\n            var defaultParams = (ast.options && ast.options.params) || {};\n            _this.states[ast.name] = new AnimationStateStyles(ast.style, defaultParams);\n        });\n        balanceProperties(this.states, 'true', '1');\n        balanceProperties(this.states, 'false', '0');\n        ast.transitions.forEach(function (ast) {\n            _this.transitionFactories.push(new AnimationTransitionFactory(name, ast, _this.states));\n        });\n        this.fallbackTransition = createFallbackTransition(name, this.states);\n    }\n    Object.defineProperty(AnimationTrigger.prototype, \"containsQueries\", {\n        get: /**\n         * @return {?}\n         */\n        function () { return this.ast.queryCount > 0; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} currentState\n     * @param {?} nextState\n     * @param {?} element\n     * @param {?} params\n     * @return {?}\n     */\n    AnimationTrigger.prototype.matchTransition = /**\n     * @param {?} currentState\n     * @param {?} nextState\n     * @param {?} element\n     * @param {?} params\n     * @return {?}\n     */\n    function (currentState, nextState, element, params) {\n        /** @type {?} */\n        var entry = this.transitionFactories.find(function (f) { return f.match(currentState, nextState, element, params); });\n        return entry || null;\n    };\n    /**\n     * @param {?} currentState\n     * @param {?} params\n     * @param {?} errors\n     * @return {?}\n     */\n    AnimationTrigger.prototype.matchStyles = /**\n     * @param {?} currentState\n     * @param {?} params\n     * @param {?} errors\n     * @return {?}\n     */\n    function (currentState, params, errors) {\n        return this.fallbackTransition.buildStyles(currentState, params, errors);\n    };\n    return AnimationTrigger;\n}());\n/**\n * \\@publicApi\n */\nexport { AnimationTrigger };\nif (false) {\n    /** @type {?} */\n    AnimationTrigger.prototype.transitionFactories;\n    /** @type {?} */\n    AnimationTrigger.prototype.fallbackTransition;\n    /** @type {?} */\n    AnimationTrigger.prototype.states;\n    /** @type {?} */\n    AnimationTrigger.prototype.name;\n    /** @type {?} */\n    AnimationTrigger.prototype.ast;\n}\n/**\n * @param {?} triggerName\n * @param {?} states\n * @return {?}\n */\nfunction createFallbackTransition(triggerName, states) {\n    /** @type {?} */\n    var matchers = [function (fromState, toState) { return true; }];\n    /** @type {?} */\n    var animation = { type: 2 /* Sequence */, steps: [], options: null };\n    /** @type {?} */\n    var transition = {\n        type: 1 /* Transition */,\n        animation: animation,\n        matchers: matchers,\n        options: null,\n        queryCount: 0,\n        depCount: 0\n    };\n    return new AnimationTransitionFactory(triggerName, transition, states);\n}\n/**\n * @param {?} obj\n * @param {?} key1\n * @param {?} key2\n * @return {?}\n */\nfunction balanceProperties(obj, key1, key2) {\n    if (obj.hasOwnProperty(key1)) {\n        if (!obj.hasOwnProperty(key2)) {\n            obj[key2] = obj[key1];\n        }\n    }\n    else if (obj.hasOwnProperty(key2)) {\n        obj[key1] = obj[key2];\n    }\n}\n//# sourceMappingURL=animation_trigger.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nimport { AUTO_STYLE } from '@angular/animations';\nimport { buildAnimationAst } from '../dsl/animation_ast_builder';\nimport { buildAnimationTimelines } from '../dsl/animation_timeline_builder';\nimport { ElementInstructionMap } from '../dsl/element_instruction_map';\nimport { ENTER_CLASSNAME, LEAVE_CLASSNAME } from '../util';\nimport { getOrSetAsInMap, listenOnPlayer, makeAnimationEvent, normalizeKeyframes, optimizeGroupPlayer } from './shared';\n/** @type {?} */\nvar EMPTY_INSTRUCTION_MAP = new ElementInstructionMap();\nvar TimelineAnimationEngine = /** @class */ (function () {\n    function TimelineAnimationEngine(bodyNode, _driver, _normalizer) {\n        this.bodyNode = bodyNode;\n        this._driver = _driver;\n        this._normalizer = _normalizer;\n        this._animations = {};\n        this._playersById = {};\n        this.players = [];\n    }\n    /**\n     * @param {?} id\n     * @param {?} metadata\n     * @return {?}\n     */\n    TimelineAnimationEngine.prototype.register = /**\n     * @param {?} id\n     * @param {?} metadata\n     * @return {?}\n     */\n    function (id, metadata) {\n        /** @type {?} */\n        var errors = [];\n        /** @type {?} */\n        var ast = buildAnimationAst(this._driver, metadata, errors);\n        if (errors.length) {\n            throw new Error(\"Unable to build the animation due to the following errors: \" + errors.join(\"\\n\"));\n        }\n        else {\n            this._animations[id] = ast;\n        }\n    };\n    /**\n     * @param {?} i\n     * @param {?} preStyles\n     * @param {?=} postStyles\n     * @return {?}\n     */\n    TimelineAnimationEngine.prototype._buildPlayer = /**\n     * @param {?} i\n     * @param {?} preStyles\n     * @param {?=} postStyles\n     * @return {?}\n     */\n    function (i, preStyles, postStyles) {\n        /** @type {?} */\n        var element = i.element;\n        /** @type {?} */\n        var keyframes = normalizeKeyframes(this._driver, this._normalizer, element, i.keyframes, preStyles, postStyles);\n        return this._driver.animate(element, keyframes, i.duration, i.delay, i.easing, [], true);\n    };\n    /**\n     * @param {?} id\n     * @param {?} element\n     * @param {?=} options\n     * @return {?}\n     */\n    TimelineAnimationEngine.prototype.create = /**\n     * @param {?} id\n     * @param {?} element\n     * @param {?=} options\n     * @return {?}\n     */\n    function (id, element, options) {\n        var _this = this;\n        if (options === void 0) { options = {}; }\n        /** @type {?} */\n        var errors = [];\n        /** @type {?} */\n        var ast = this._animations[id];\n        /** @type {?} */\n        var instructions;\n        /** @type {?} */\n        var autoStylesMap = new Map();\n        if (ast) {\n            instructions = buildAnimationTimelines(this._driver, element, ast, ENTER_CLASSNAME, LEAVE_CLASSNAME, {}, {}, options, EMPTY_INSTRUCTION_MAP, errors);\n            instructions.forEach(function (inst) {\n                /** @type {?} */\n                var styles = getOrSetAsInMap(autoStylesMap, inst.element, {});\n                inst.postStyleProps.forEach(function (prop) { return styles[prop] = null; });\n            });\n        }\n        else {\n            errors.push('The requested animation doesn\\'t exist or has already been destroyed');\n            instructions = [];\n        }\n        if (errors.length) {\n            throw new Error(\"Unable to create the animation due to the following errors: \" + errors.join(\"\\n\"));\n        }\n        autoStylesMap.forEach(function (styles, element) {\n            Object.keys(styles).forEach(function (prop) { styles[prop] = _this._driver.computeStyle(element, prop, AUTO_STYLE); });\n        });\n        /** @type {?} */\n        var players = instructions.map(function (i) {\n            /** @type {?} */\n            var styles = autoStylesMap.get(i.element);\n            return _this._buildPlayer(i, {}, styles);\n        });\n        /** @type {?} */\n        var player = optimizeGroupPlayer(players);\n        this._playersById[id] = player;\n        player.onDestroy(function () { return _this.destroy(id); });\n        this.players.push(player);\n        return player;\n    };\n    /**\n     * @param {?} id\n     * @return {?}\n     */\n    TimelineAnimationEngine.prototype.destroy = /**\n     * @param {?} id\n     * @return {?}\n     */\n    function (id) {\n        /** @type {?} */\n        var player = this._getPlayer(id);\n        player.destroy();\n        delete this._playersById[id];\n        /** @type {?} */\n        var index = this.players.indexOf(player);\n        if (index >= 0) {\n            this.players.splice(index, 1);\n        }\n    };\n    /**\n     * @param {?} id\n     * @return {?}\n     */\n    TimelineAnimationEngine.prototype._getPlayer = /**\n     * @param {?} id\n     * @return {?}\n     */\n    function (id) {\n        /** @type {?} */\n        var player = this._playersById[id];\n        if (!player) {\n            throw new Error(\"Unable to find the timeline player referenced by \" + id);\n        }\n        return player;\n    };\n    /**\n     * @param {?} id\n     * @param {?} element\n     * @param {?} eventName\n     * @param {?} callback\n     * @return {?}\n     */\n    TimelineAnimationEngine.prototype.listen = /**\n     * @param {?} id\n     * @param {?} element\n     * @param {?} eventName\n     * @param {?} callback\n     * @return {?}\n     */\n    function (id, element, eventName, callback) {\n        /** @type {?} */\n        var baseEvent = makeAnimationEvent(element, '', '', '');\n        listenOnPlayer(this._getPlayer(id), eventName, baseEvent, callback);\n        return function () { };\n    };\n    /**\n     * @param {?} id\n     * @param {?} element\n     * @param {?} command\n     * @param {?} args\n     * @return {?}\n     */\n    TimelineAnimationEngine.prototype.command = /**\n     * @param {?} id\n     * @param {?} element\n     * @param {?} command\n     * @param {?} args\n     * @return {?}\n     */\n    function (id, element, command, args) {\n        if (command == 'register') {\n            this.register(id, /** @type {?} */ (args[0]));\n            return;\n        }\n        if (command == 'create') {\n            /** @type {?} */\n            var options = /** @type {?} */ ((args[0] || {}));\n            this.create(id, element, options);\n            return;\n        }\n        /** @type {?} */\n        var player = this._getPlayer(id);\n        switch (command) {\n            case 'play':\n                player.play();\n                break;\n            case 'pause':\n                player.pause();\n                break;\n            case 'reset':\n                player.reset();\n                break;\n            case 'restart':\n                player.restart();\n                break;\n            case 'finish':\n                player.finish();\n                break;\n            case 'init':\n                player.init();\n                break;\n            case 'setPosition':\n                player.setPosition(parseFloat(/** @type {?} */ (args[0])));\n                break;\n            case 'destroy':\n                this.destroy(id);\n                break;\n        }\n    };\n    return TimelineAnimationEngine;\n}());\nexport { TimelineAnimationEngine };\nif (false) {\n    /** @type {?} */\n    TimelineAnimationEngine.prototype._animations;\n    /** @type {?} */\n    TimelineAnimationEngine.prototype._playersById;\n    /** @type {?} */\n    TimelineAnimationEngine.prototype.players;\n    /** @type {?} */\n    TimelineAnimationEngine.prototype.bodyNode;\n    /** @type {?} */\n    TimelineAnimationEngine.prototype._driver;\n    /** @type {?} */\n    TimelineAnimationEngine.prototype._normalizer;\n}\n//# sourceMappingURL=timeline_animation_engine.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nimport * as tslib_1 from \"tslib\";\nimport { AUTO_STYLE, NoopAnimationPlayer, ÉµAnimationGroupPlayer as AnimationGroupPlayer, ÉµPRE_STYLE as PRE_STYLE } from '@angular/animations';\nimport { ElementInstructionMap } from '../dsl/element_instruction_map';\nimport { ENTER_CLASSNAME, LEAVE_CLASSNAME, NG_ANIMATING_CLASSNAME, NG_ANIMATING_SELECTOR, NG_TRIGGER_CLASSNAME, NG_TRIGGER_SELECTOR, copyObj, eraseStyles, setStyles } from '../util';\nimport { getOrSetAsInMap, listenOnPlayer, makeAnimationEvent, normalizeKeyframes, optimizeGroupPlayer } from './shared';\n/** @type {?} */\nvar QUEUED_CLASSNAME = 'ng-animate-queued';\n/** @type {?} */\nvar QUEUED_SELECTOR = '.ng-animate-queued';\n/** @type {?} */\nvar DISABLED_CLASSNAME = 'ng-animate-disabled';\n/** @type {?} */\nvar DISABLED_SELECTOR = '.ng-animate-disabled';\n/** @type {?} */\nvar STAR_CLASSNAME = 'ng-star-inserted';\n/** @type {?} */\nvar STAR_SELECTOR = '.ng-star-inserted';\n/** @type {?} */\nvar EMPTY_PLAYER_ARRAY = [];\n/** @type {?} */\nvar NULL_REMOVAL_STATE = {\n    namespaceId: '',\n    setForRemoval: false,\n    setForMove: false,\n    hasAnimation: false,\n    removedBeforeQueried: false\n};\n/** @type {?} */\nvar NULL_REMOVED_QUERIED_STATE = {\n    namespaceId: '',\n    setForMove: false,\n    setForRemoval: false,\n    hasAnimation: false,\n    removedBeforeQueried: true\n};\n/**\n * @record\n */\nfunction TriggerListener() { }\n/** @type {?} */\nTriggerListener.prototype.name;\n/** @type {?} */\nTriggerListener.prototype.phase;\n/** @type {?} */\nTriggerListener.prototype.callback;\n/**\n * @record\n */\nexport function QueueInstruction() { }\n/** @type {?} */\nQueueInstruction.prototype.element;\n/** @type {?} */\nQueueInstruction.prototype.triggerName;\n/** @type {?} */\nQueueInstruction.prototype.fromState;\n/** @type {?} */\nQueueInstruction.prototype.toState;\n/** @type {?} */\nQueueInstruction.prototype.transition;\n/** @type {?} */\nQueueInstruction.prototype.player;\n/** @type {?} */\nQueueInstruction.prototype.isFallbackTransition;\n/** @type {?} */\nexport var REMOVAL_FLAG = '__ng_removed';\n/**\n * @record\n */\nexport function ElementAnimationState() { }\n/** @type {?} */\nElementAnimationState.prototype.setForRemoval;\n/** @type {?} */\nElementAnimationState.prototype.setForMove;\n/** @type {?} */\nElementAnimationState.prototype.hasAnimation;\n/** @type {?} */\nElementAnimationState.prototype.namespaceId;\n/** @type {?} */\nElementAnimationState.prototype.removedBeforeQueried;\nvar StateValue = /** @class */ (function () {\n    function StateValue(input, namespaceId) {\n        if (namespaceId === void 0) { namespaceId = ''; }\n        this.namespaceId = namespaceId;\n        /** @type {?} */\n        var isObj = input && input.hasOwnProperty('value');\n        /** @type {?} */\n        var value = isObj ? input['value'] : input;\n        this.value = normalizeTriggerValue(value);\n        if (isObj) {\n            /** @type {?} */\n            var options = copyObj(/** @type {?} */ (input));\n            delete options['value'];\n            this.options = /** @type {?} */ (options);\n        }\n        else {\n            this.options = {};\n        }\n        if (!this.options.params) {\n            this.options.params = {};\n        }\n    }\n    Object.defineProperty(StateValue.prototype, \"params\", {\n        get: /**\n         * @return {?}\n         */\n        function () { return /** @type {?} */ (this.options.params); },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n    StateValue.prototype.absorbOptions = /**\n     * @param {?} options\n     * @return {?}\n     */\n    function (options) {\n        /** @type {?} */\n        var newParams = options.params;\n        if (newParams) {\n            /** @type {?} */\n            var oldParams_1 = /** @type {?} */ ((this.options.params));\n            Object.keys(newParams).forEach(function (prop) {\n                if (oldParams_1[prop] == null) {\n                    oldParams_1[prop] = newParams[prop];\n                }\n            });\n        }\n    };\n    return StateValue;\n}());\nexport { StateValue };\nif (false) {\n    /** @type {?} */\n    StateValue.prototype.value;\n    /** @type {?} */\n    StateValue.prototype.options;\n    /** @type {?} */\n    StateValue.prototype.namespaceId;\n}\n/** @type {?} */\nexport var VOID_VALUE = 'void';\n/** @type {?} */\nexport var DEFAULT_STATE_VALUE = new StateValue(VOID_VALUE);\nvar AnimationTransitionNamespace = /** @class */ (function () {\n    function AnimationTransitionNamespace(id, hostElement, _engine) {\n        this.id = id;\n        this.hostElement = hostElement;\n        this._engine = _engine;\n        this.players = [];\n        this._triggers = {};\n        this._queue = [];\n        this._elementListeners = new Map();\n        this._hostClassName = 'ng-tns-' + id;\n        addClass(hostElement, this._hostClassName);\n    }\n    /**\n     * @param {?} element\n     * @param {?} name\n     * @param {?} phase\n     * @param {?} callback\n     * @return {?}\n     */\n    AnimationTransitionNamespace.prototype.listen = /**\n     * @param {?} element\n     * @param {?} name\n     * @param {?} phase\n     * @param {?} callback\n     * @return {?}\n     */\n    function (element, name, phase, callback) {\n        var _this = this;\n        if (!this._triggers.hasOwnProperty(name)) {\n            throw new Error(\"Unable to listen on the animation trigger event \\\"\" + phase + \"\\\" because the animation trigger \\\"\" + name + \"\\\" doesn't exist!\");\n        }\n        if (phase == null || phase.length == 0) {\n            throw new Error(\"Unable to listen on the animation trigger \\\"\" + name + \"\\\" because the provided event is undefined!\");\n        }\n        if (!isTriggerEventValid(phase)) {\n            throw new Error(\"The provided animation trigger event \\\"\" + phase + \"\\\" for the animation trigger \\\"\" + name + \"\\\" is not supported!\");\n        }\n        /** @type {?} */\n        var listeners = getOrSetAsInMap(this._elementListeners, element, []);\n        /** @type {?} */\n        var data = { name: name, phase: phase, callback: callback };\n        listeners.push(data);\n        /** @type {?} */\n        var triggersWithStates = getOrSetAsInMap(this._engine.statesByElement, element, {});\n        if (!triggersWithStates.hasOwnProperty(name)) {\n            addClass(element, NG_TRIGGER_CLASSNAME);\n            addClass(element, NG_TRIGGER_CLASSNAME + '-' + name);\n            triggersWithStates[name] = DEFAULT_STATE_VALUE;\n        }\n        return function () {\n            // the event listener is removed AFTER the flush has occurred such\n            // that leave animations callbacks can fire (otherwise if the node\n            // is removed in between then the listeners would be deregistered)\n            _this._engine.afterFlush(function () {\n                /** @type {?} */\n                var index = listeners.indexOf(data);\n                if (index >= 0) {\n                    listeners.splice(index, 1);\n                }\n                if (!_this._triggers[name]) {\n                    delete triggersWithStates[name];\n                }\n            });\n        };\n    };\n    /**\n     * @param {?} name\n     * @param {?} ast\n     * @return {?}\n     */\n    AnimationTransitionNamespace.prototype.register = /**\n     * @param {?} name\n     * @param {?} ast\n     * @return {?}\n     */\n    function (name, ast) {\n        if (this._triggers[name]) {\n            // throw\n            return false;\n        }\n        else {\n            this._triggers[name] = ast;\n            return true;\n        }\n    };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    AnimationTransitionNamespace.prototype._getTrigger = /**\n     * @param {?} name\n     * @return {?}\n     */\n    function (name) {\n        /** @type {?} */\n        var trigger = this._triggers[name];\n        if (!trigger) {\n            throw new Error(\"The provided animation trigger \\\"\" + name + \"\\\" has not been registered!\");\n        }\n        return trigger;\n    };\n    /**\n     * @param {?} element\n     * @param {?} triggerName\n     * @param {?} value\n     * @param {?=} defaultToFallback\n     * @return {?}\n     */\n    AnimationTransitionNamespace.prototype.trigger = /**\n     * @param {?} element\n     * @param {?} triggerName\n     * @param {?} value\n     * @param {?=} defaultToFallback\n     * @return {?}\n     */\n    function (element, triggerName, value, defaultToFallback) {\n        var _this = this;\n        if (defaultToFallback === void 0) { defaultToFallback = true; }\n        /** @type {?} */\n        var trigger = this._getTrigger(triggerName);\n        /** @type {?} */\n        var player = new TransitionAnimationPlayer(this.id, triggerName, element);\n        /** @type {?} */\n        var triggersWithStates = this._engine.statesByElement.get(element);\n        if (!triggersWithStates) {\n            addClass(element, NG_TRIGGER_CLASSNAME);\n            addClass(element, NG_TRIGGER_CLASSNAME + '-' + triggerName);\n            this._engine.statesByElement.set(element, triggersWithStates = {});\n        }\n        /** @type {?} */\n        var fromState = triggersWithStates[triggerName];\n        /** @type {?} */\n        var toState = new StateValue(value, this.id);\n        /** @type {?} */\n        var isObj = value && value.hasOwnProperty('value');\n        if (!isObj && fromState) {\n            toState.absorbOptions(fromState.options);\n        }\n        triggersWithStates[triggerName] = toState;\n        if (!fromState) {\n            fromState = DEFAULT_STATE_VALUE;\n        }\n        /** @type {?} */\n        var isRemoval = toState.value === VOID_VALUE;\n        // normally this isn't reached by here, however, if an object expression\n        // is passed in then it may be a new object each time. Comparing the value\n        // is important since that will stay the same despite there being a new object.\n        // The removal arc here is special cased because the same element is triggered\n        // twice in the event that it contains animations on the outer/inner portions\n        // of the host container\n        if (!isRemoval && fromState.value === toState.value) {\n            // this means that despite the value not changing, some inner params\n            // have changed which means that the animation final styles need to be applied\n            if (!objEquals(fromState.params, toState.params)) {\n                /** @type {?} */\n                var errors = [];\n                /** @type {?} */\n                var fromStyles_1 = trigger.matchStyles(fromState.value, fromState.params, errors);\n                /** @type {?} */\n                var toStyles_1 = trigger.matchStyles(toState.value, toState.params, errors);\n                if (errors.length) {\n                    this._engine.reportError(errors);\n                }\n                else {\n                    this._engine.afterFlush(function () {\n                        eraseStyles(element, fromStyles_1);\n                        setStyles(element, toStyles_1);\n                    });\n                }\n            }\n            return;\n        }\n        /** @type {?} */\n        var playersOnElement = getOrSetAsInMap(this._engine.playersByElement, element, []);\n        playersOnElement.forEach(function (player) {\n            // only remove the player if it is queued on the EXACT same trigger/namespace\n            // we only also deal with queued players here because if the animation has\n            // started then we want to keep the player alive until the flush happens\n            // (which is where the previousPlayers are passed into the new palyer)\n            if (player.namespaceId == _this.id && player.triggerName == triggerName && player.queued) {\n                player.destroy();\n            }\n        });\n        /** @type {?} */\n        var transition = trigger.matchTransition(fromState.value, toState.value, element, toState.params);\n        /** @type {?} */\n        var isFallbackTransition = false;\n        if (!transition) {\n            if (!defaultToFallback)\n                return;\n            transition = trigger.fallbackTransition;\n            isFallbackTransition = true;\n        }\n        this._engine.totalQueuedPlayers++;\n        this._queue.push({ element: element, triggerName: triggerName, transition: transition, fromState: fromState, toState: toState, player: player, isFallbackTransition: isFallbackTransition });\n        if (!isFallbackTransition) {\n            addClass(element, QUEUED_CLASSNAME);\n            player.onStart(function () { removeClass(element, QUEUED_CLASSNAME); });\n        }\n        player.onDone(function () {\n            /** @type {?} */\n            var index = _this.players.indexOf(player);\n            if (index >= 0) {\n                _this.players.splice(index, 1);\n            }\n            /** @type {?} */\n            var players = _this._engine.playersByElement.get(element);\n            if (players) {\n                /** @type {?} */\n                var index_1 = players.indexOf(player);\n                if (index_1 >= 0) {\n                    players.splice(index_1, 1);\n                }\n            }\n        });\n        this.players.push(player);\n        playersOnElement.push(player);\n        return player;\n    };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    AnimationTransitionNamespace.prototype.deregister = /**\n     * @param {?} name\n     * @return {?}\n     */\n    function (name) {\n        var _this = this;\n        delete this._triggers[name];\n        this._engine.statesByElement.forEach(function (stateMap, element) { delete stateMap[name]; });\n        this._elementListeners.forEach(function (listeners, element) {\n            _this._elementListeners.set(element, listeners.filter(function (entry) { return entry.name != name; }));\n        });\n    };\n    /**\n     * @param {?} element\n     * @return {?}\n     */\n    AnimationTransitionNamespace.prototype.clearElementCache = /**\n     * @param {?} element\n     * @return {?}\n     */\n    function (element) {\n        this._engine.statesByElement.delete(element);\n        this._elementListeners.delete(element);\n        /** @type {?} */\n        var elementPlayers = this._engine.playersByElement.get(element);\n        if (elementPlayers) {\n            elementPlayers.forEach(function (player) { return player.destroy(); });\n            this._engine.playersByElement.delete(element);\n        }\n    };\n    /**\n     * @param {?} rootElement\n     * @param {?} context\n     * @param {?=} animate\n     * @return {?}\n     */\n    AnimationTransitionNamespace.prototype._signalRemovalForInnerTriggers = /**\n     * @param {?} rootElement\n     * @param {?} context\n     * @param {?=} animate\n     * @return {?}\n     */\n    function (rootElement, context, animate) {\n        var _this = this;\n        if (animate === void 0) { animate = false; }\n        // emulate a leave animation for all inner nodes within this node.\n        // If there are no animations found for any of the nodes then clear the cache\n        // for the element.\n        this._engine.driver.query(rootElement, NG_TRIGGER_SELECTOR, true).forEach(function (elm) {\n            // this means that an inner remove() operation has already kicked off\n            // the animation on this element...\n            if (elm[REMOVAL_FLAG])\n                return;\n            /** @type {?} */\n            var namespaces = _this._engine.fetchNamespacesByElement(elm);\n            if (namespaces.size) {\n                namespaces.forEach(function (ns) { return ns.triggerLeaveAnimation(elm, context, false, true); });\n            }\n            else {\n                _this.clearElementCache(elm);\n            }\n        });\n    };\n    /**\n     * @param {?} element\n     * @param {?} context\n     * @param {?=} destroyAfterComplete\n     * @param {?=} defaultToFallback\n     * @return {?}\n     */\n    AnimationTransitionNamespace.prototype.triggerLeaveAnimation = /**\n     * @param {?} element\n     * @param {?} context\n     * @param {?=} destroyAfterComplete\n     * @param {?=} defaultToFallback\n     * @return {?}\n     */\n    function (element, context, destroyAfterComplete, defaultToFallback) {\n        var _this = this;\n        /** @type {?} */\n        var triggerStates = this._engine.statesByElement.get(element);\n        if (triggerStates) {\n            /** @type {?} */\n            var players_1 = [];\n            Object.keys(triggerStates).forEach(function (triggerName) {\n                // this check is here in the event that an element is removed\n                // twice (both on the host level and the component level)\n                if (_this._triggers[triggerName]) {\n                    /** @type {?} */\n                    var player = _this.trigger(element, triggerName, VOID_VALUE, defaultToFallback);\n                    if (player) {\n                        players_1.push(player);\n                    }\n                }\n            });\n            if (players_1.length) {\n                this._engine.markElementAsRemoved(this.id, element, true, context);\n                if (destroyAfterComplete) {\n                    optimizeGroupPlayer(players_1).onDone(function () { return _this._engine.processLeaveNode(element); });\n                }\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * @param {?} element\n     * @return {?}\n     */\n    AnimationTransitionNamespace.prototype.prepareLeaveAnimationListeners = /**\n     * @param {?} element\n     * @return {?}\n     */\n    function (element) {\n        var _this = this;\n        /** @type {?} */\n        var listeners = this._elementListeners.get(element);\n        if (listeners) {\n            /** @type {?} */\n            var visitedTriggers_1 = new Set();\n            listeners.forEach(function (listener) {\n                /** @type {?} */\n                var triggerName = listener.name;\n                if (visitedTriggers_1.has(triggerName))\n                    return;\n                visitedTriggers_1.add(triggerName);\n                /** @type {?} */\n                var trigger = _this._triggers[triggerName];\n                /** @type {?} */\n                var transition = trigger.fallbackTransition;\n                /** @type {?} */\n                var elementStates = /** @type {?} */ ((_this._engine.statesByElement.get(element)));\n                /** @type {?} */\n                var fromState = elementStates[triggerName] || DEFAULT_STATE_VALUE;\n                /** @type {?} */\n                var toState = new StateValue(VOID_VALUE);\n                /** @type {?} */\n                var player = new TransitionAnimationPlayer(_this.id, triggerName, element);\n                _this._engine.totalQueuedPlayers++;\n                _this._queue.push({\n                    element: element,\n                    triggerName: triggerName,\n                    transition: transition,\n                    fromState: fromState,\n                    toState: toState,\n                    player: player,\n                    isFallbackTransition: true\n                });\n            });\n        }\n    };\n    /**\n     * @param {?} element\n     * @param {?} context\n     * @return {?}\n     */\n    AnimationTransitionNamespace.prototype.removeNode = /**\n     * @param {?} element\n     * @param {?} context\n     * @return {?}\n     */\n    function (element, context) {\n        var _this = this;\n        /** @type {?} */\n        var engine = this._engine;\n        if (element.childElementCount) {\n            this._signalRemovalForInnerTriggers(element, context, true);\n        }\n        // this means that a * => VOID animation was detected and kicked off\n        if (this.triggerLeaveAnimation(element, context, true))\n            return;\n        /** @type {?} */\n        var containsPotentialParentTransition = false;\n        if (engine.totalAnimations) {\n            /** @type {?} */\n            var currentPlayers = engine.players.length ? engine.playersByQueriedElement.get(element) : [];\n            // when this `if statement` does not continue forward it means that\n            // a previous animation query has selected the current element and\n            // is animating it. In this situation want to continue forwards and\n            // allow the element to be queued up for animation later.\n            if (currentPlayers && currentPlayers.length) {\n                containsPotentialParentTransition = true;\n            }\n            else {\n                /** @type {?} */\n                var parent_1 = element;\n                while (parent_1 = parent_1.parentNode) {\n                    /** @type {?} */\n                    var triggers = engine.statesByElement.get(parent_1);\n                    if (triggers) {\n                        containsPotentialParentTransition = true;\n                        break;\n                    }\n                }\n            }\n        }\n        // at this stage we know that the element will either get removed\n        // during flush or will be picked up by a parent query. Either way\n        // we need to fire the listeners for this element when it DOES get\n        // removed (once the query parent animation is done or after flush)\n        this.prepareLeaveAnimationListeners(element);\n        // whether or not a parent has an animation we need to delay the deferral of the leave\n        // operation until we have more information (which we do after flush() has been called)\n        if (containsPotentialParentTransition) {\n            engine.markElementAsRemoved(this.id, element, false, context);\n        }\n        else {\n            // we do this after the flush has occurred such\n            // that the callbacks can be fired\n            engine.afterFlush(function () { return _this.clearElementCache(element); });\n            engine.destroyInnerAnimations(element);\n            engine._onRemovalComplete(element, context);\n        }\n    };\n    /**\n     * @param {?} element\n     * @param {?} parent\n     * @return {?}\n     */\n    AnimationTransitionNamespace.prototype.insertNode = /**\n     * @param {?} element\n     * @param {?} parent\n     * @return {?}\n     */\n    function (element, parent) { addClass(element, this._hostClassName); };\n    /**\n     * @param {?} microtaskId\n     * @return {?}\n     */\n    AnimationTransitionNamespace.prototype.drainQueuedTransitions = /**\n     * @param {?} microtaskId\n     * @return {?}\n     */\n    function (microtaskId) {\n        var _this = this;\n        /** @type {?} */\n        var instructions = [];\n        this._queue.forEach(function (entry) {\n            /** @type {?} */\n            var player = entry.player;\n            if (player.destroyed)\n                return;\n            /** @type {?} */\n            var element = entry.element;\n            /** @type {?} */\n            var listeners = _this._elementListeners.get(element);\n            if (listeners) {\n                listeners.forEach(function (listener) {\n                    if (listener.name == entry.triggerName) {\n                        /** @type {?} */\n                        var baseEvent = makeAnimationEvent(element, entry.triggerName, entry.fromState.value, entry.toState.value);\n                        (/** @type {?} */ (baseEvent))['_data'] = microtaskId;\n                        listenOnPlayer(entry.player, listener.phase, baseEvent, listener.callback);\n                    }\n                });\n            }\n            if (player.markedForDestroy) {\n                _this._engine.afterFlush(function () {\n                    // now we can destroy the element properly since the event listeners have\n                    // been bound to the player\n                    player.destroy();\n                });\n            }\n            else {\n                instructions.push(entry);\n            }\n        });\n        this._queue = [];\n        return instructions.sort(function (a, b) {\n            /** @type {?} */\n            var d0 = a.transition.ast.depCount;\n            /** @type {?} */\n            var d1 = b.transition.ast.depCount;\n            if (d0 == 0 || d1 == 0) {\n                return d0 - d1;\n            }\n            return _this._engine.driver.containsElement(a.element, b.element) ? 1 : -1;\n        });\n    };\n    /**\n     * @param {?} context\n     * @return {?}\n     */\n    AnimationTransitionNamespace.prototype.destroy = /**\n     * @param {?} context\n     * @return {?}\n     */\n    function (context) {\n        this.players.forEach(function (p) { return p.destroy(); });\n        this._signalRemovalForInnerTriggers(this.hostElement, context);\n    };\n    /**\n     * @param {?} element\n     * @return {?}\n     */\n    AnimationTransitionNamespace.prototype.elementContainsData = /**\n     * @param {?} element\n     * @return {?}\n     */\n    function (element) {\n        /** @type {?} */\n        var containsData = false;\n        if (this._elementListeners.has(element))\n            containsData = true;\n        containsData =\n            (this._queue.find(function (entry) { return entry.element === element; }) ? true : false) || containsData;\n        return containsData;\n    };\n    return AnimationTransitionNamespace;\n}());\nexport { AnimationTransitionNamespace };\nif (false) {\n    /** @type {?} */\n    AnimationTransitionNamespace.prototype.players;\n    /** @type {?} */\n    AnimationTransitionNamespace.prototype._triggers;\n    /** @type {?} */\n    AnimationTransitionNamespace.prototype._queue;\n    /** @type {?} */\n    AnimationTransitionNamespace.prototype._elementListeners;\n    /** @type {?} */\n    AnimationTransitionNamespace.prototype._hostClassName;\n    /** @type {?} */\n    AnimationTransitionNamespace.prototype.id;\n    /** @type {?} */\n    AnimationTransitionNamespace.prototype.hostElement;\n    /** @type {?} */\n    AnimationTransitionNamespace.prototype._engine;\n}\n/**\n * @record\n */\nexport function QueuedTransition() { }\n/** @type {?} */\nQueuedTransition.prototype.element;\n/** @type {?} */\nQueuedTransition.prototype.instruction;\n/** @type {?} */\nQueuedTransition.prototype.player;\nvar TransitionAnimationEngine = /** @class */ (function () {\n    function TransitionAnimationEngine(bodyNode, driver, _normalizer) {\n        this.bodyNode = bodyNode;\n        this.driver = driver;\n        this._normalizer = _normalizer;\n        this.players = [];\n        this.newHostElements = new Map();\n        this.playersByElement = new Map();\n        this.playersByQueriedElement = new Map();\n        this.statesByElement = new Map();\n        this.disabledNodes = new Set();\n        this.totalAnimations = 0;\n        this.totalQueuedPlayers = 0;\n        this._namespaceLookup = {};\n        this._namespaceList = [];\n        this._flushFns = [];\n        this._whenQuietFns = [];\n        this.namespacesByHostElement = new Map();\n        this.collectedEnterElements = [];\n        this.collectedLeaveElements = [];\n        this.onRemovalComplete = function (element, context) { };\n    }\n    /** @internal */\n    /**\n     * \\@internal\n     * @param {?} element\n     * @param {?} context\n     * @return {?}\n     */\n    TransitionAnimationEngine.prototype._onRemovalComplete = /**\n     * \\@internal\n     * @param {?} element\n     * @param {?} context\n     * @return {?}\n     */\n    function (element, context) { this.onRemovalComplete(element, context); };\n    Object.defineProperty(TransitionAnimationEngine.prototype, \"queuedPlayers\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            /** @type {?} */\n            var players = [];\n            this._namespaceList.forEach(function (ns) {\n                ns.players.forEach(function (player) {\n                    if (player.queued) {\n                        players.push(player);\n                    }\n                });\n            });\n            return players;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} namespaceId\n     * @param {?} hostElement\n     * @return {?}\n     */\n    TransitionAnimationEngine.prototype.createNamespace = /**\n     * @param {?} namespaceId\n     * @param {?} hostElement\n     * @return {?}\n     */\n    function (namespaceId, hostElement) {\n        /** @type {?} */\n        var ns = new AnimationTransitionNamespace(namespaceId, hostElement, this);\n        if (hostElement.parentNode) {\n            this._balanceNamespaceList(ns, hostElement);\n        }\n        else {\n            // defer this later until flush during when the host element has\n            // been inserted so that we know exactly where to place it in\n            // the namespace list\n            this.newHostElements.set(hostElement, ns);\n            // given that this host element is apart of the animation code, it\n            // may or may not be inserted by a parent node that is an of an\n            // animation renderer type. If this happens then we can still have\n            // access to this item when we query for :enter nodes. If the parent\n            // is a renderer then the set data-structure will normalize the entry\n            this.collectEnterElement(hostElement);\n        }\n        return this._namespaceLookup[namespaceId] = ns;\n    };\n    /**\n     * @param {?} ns\n     * @param {?} hostElement\n     * @return {?}\n     */\n    TransitionAnimationEngine.prototype._balanceNamespaceList = /**\n     * @param {?} ns\n     * @param {?} hostElement\n     * @return {?}\n     */\n    function (ns, hostElement) {\n        /** @type {?} */\n        var limit = this._namespaceList.length - 1;\n        if (limit >= 0) {\n            /** @type {?} */\n            var found = false;\n            for (var i = limit; i >= 0; i--) {\n                /** @type {?} */\n                var nextNamespace = this._namespaceList[i];\n                if (this.driver.containsElement(nextNamespace.hostElement, hostElement)) {\n                    this._namespaceList.splice(i + 1, 0, ns);\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                this._namespaceList.splice(0, 0, ns);\n            }\n        }\n        else {\n            this._namespaceList.push(ns);\n        }\n        this.namespacesByHostElement.set(hostElement, ns);\n        return ns;\n    };\n    /**\n     * @param {?} namespaceId\n     * @param {?} hostElement\n     * @return {?}\n     */\n    TransitionAnimationEngine.prototype.register = /**\n     * @param {?} namespaceId\n     * @param {?} hostElement\n     * @return {?}\n     */\n    function (namespaceId, hostElement) {\n        /** @type {?} */\n        var ns = this._namespaceLookup[namespaceId];\n        if (!ns) {\n            ns = this.createNamespace(namespaceId, hostElement);\n        }\n        return ns;\n    };\n    /**\n     * @param {?} namespaceId\n     * @param {?} name\n     * @param {?} trigger\n     * @return {?}\n     */\n    TransitionAnimationEngine.prototype.registerTrigger = /**\n     * @param {?} namespaceId\n     * @param {?} name\n     * @param {?} trigger\n     * @return {?}\n     */\n    function (namespaceId, name, trigger) {\n        /** @type {?} */\n        var ns = this._namespaceLookup[namespaceId];\n        if (ns && ns.register(name, trigger)) {\n            this.totalAnimations++;\n        }\n    };\n    /**\n     * @param {?} namespaceId\n     * @param {?} context\n     * @return {?}\n     */\n    TransitionAnimationEngine.prototype.destroy = /**\n     * @param {?} namespaceId\n     * @param {?} context\n     * @return {?}\n     */\n    function (namespaceId, context) {\n        var _this = this;\n        if (!namespaceId)\n            return;\n        /** @type {?} */\n        var ns = this._fetchNamespace(namespaceId);\n        this.afterFlush(function () {\n            _this.namespacesByHostElement.delete(ns.hostElement);\n            delete _this._namespaceLookup[namespaceId];\n            /** @type {?} */\n            var index = _this._namespaceList.indexOf(ns);\n            if (index >= 0) {\n                _this._namespaceList.splice(index, 1);\n            }\n        });\n        this.afterFlushAnimationsDone(function () { return ns.destroy(context); });\n    };\n    /**\n     * @param {?} id\n     * @return {?}\n     */\n    TransitionAnimationEngine.prototype._fetchNamespace = /**\n     * @param {?} id\n     * @return {?}\n     */\n    function (id) { return this._namespaceLookup[id]; };\n    /**\n     * @param {?} element\n     * @return {?}\n     */\n    TransitionAnimationEngine.prototype.fetchNamespacesByElement = /**\n     * @param {?} element\n     * @return {?}\n     */\n    function (element) {\n        /** @type {?} */\n        var namespaces = new Set();\n        /** @type {?} */\n        var elementStates = this.statesByElement.get(element);\n        if (elementStates) {\n            /** @type {?} */\n            var keys = Object.keys(elementStates);\n            for (var i = 0; i < keys.length; i++) {\n                /** @type {?} */\n                var nsId = elementStates[keys[i]].namespaceId;\n                if (nsId) {\n                    /** @type {?} */\n                    var ns = this._fetchNamespace(nsId);\n                    if (ns) {\n                        namespaces.add(ns);\n                    }\n                }\n            }\n        }\n        return namespaces;\n    };\n    /**\n     * @param {?} namespaceId\n     * @param {?} element\n     * @param {?} name\n     * @param {?} value\n     * @return {?}\n     */\n    TransitionAnimationEngine.prototype.trigger = /**\n     * @param {?} namespaceId\n     * @param {?} element\n     * @param {?} name\n     * @param {?} value\n     * @return {?}\n     */\n    function (namespaceId, element, name, value) {\n        if (isElementNode(element)) {\n            /** @type {?} */\n            var ns = this._fetchNamespace(namespaceId);\n            if (ns) {\n                ns.trigger(element, name, value);\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * @param {?} namespaceId\n     * @param {?} element\n     * @param {?} parent\n     * @param {?} insertBefore\n     * @return {?}\n     */\n    TransitionAnimationEngine.prototype.insertNode = /**\n     * @param {?} namespaceId\n     * @param {?} element\n     * @param {?} parent\n     * @param {?} insertBefore\n     * @return {?}\n     */\n    function (namespaceId, element, parent, insertBefore) {\n        if (!isElementNode(element))\n            return;\n        /** @type {?} */\n        var details = /** @type {?} */ (element[REMOVAL_FLAG]);\n        if (details && details.setForRemoval) {\n            details.setForRemoval = false;\n            details.setForMove = true;\n            /** @type {?} */\n            var index = this.collectedLeaveElements.indexOf(element);\n            if (index >= 0) {\n                this.collectedLeaveElements.splice(index, 1);\n            }\n        }\n        // in the event that the namespaceId is blank then the caller\n        // code does not contain any animation code in it, but it is\n        // just being called so that the node is marked as being inserted\n        if (namespaceId) {\n            /** @type {?} */\n            var ns = this._fetchNamespace(namespaceId);\n            // This if-statement is a workaround for router issue #21947.\n            // The router sometimes hits a race condition where while a route\n            // is being instantiated a new navigation arrives, triggering leave\n            // animation of DOM that has not been fully initialized, until this\n            // is resolved, we need to handle the scenario when DOM is not in a\n            // consistent state during the animation.\n            if (ns) {\n                ns.insertNode(element, parent);\n            }\n        }\n        // only *directives and host elements are inserted before\n        if (insertBefore) {\n            this.collectEnterElement(element);\n        }\n    };\n    /**\n     * @param {?} element\n     * @return {?}\n     */\n    TransitionAnimationEngine.prototype.collectEnterElement = /**\n     * @param {?} element\n     * @return {?}\n     */\n    function (element) { this.collectedEnterElements.push(element); };\n    /**\n     * @param {?} element\n     * @param {?} value\n     * @return {?}\n     */\n    TransitionAnimationEngine.prototype.markElementAsDisabled = /**\n     * @param {?} element\n     * @param {?} value\n     * @return {?}\n     */\n    function (element, value) {\n        if (value) {\n            if (!this.disabledNodes.has(element)) {\n                this.disabledNodes.add(element);\n                addClass(element, DISABLED_CLASSNAME);\n            }\n        }\n        else if (this.disabledNodes.has(element)) {\n            this.disabledNodes.delete(element);\n            removeClass(element, DISABLED_CLASSNAME);\n        }\n    };\n    /**\n     * @param {?} namespaceId\n     * @param {?} element\n     * @param {?} context\n     * @return {?}\n     */\n    TransitionAnimationEngine.prototype.removeNode = /**\n     * @param {?} namespaceId\n     * @param {?} element\n     * @param {?} context\n     * @return {?}\n     */\n    function (namespaceId, element, context) {\n        if (!isElementNode(element)) {\n            this._onRemovalComplete(element, context);\n            return;\n        }\n        /** @type {?} */\n        var ns = namespaceId ? this._fetchNamespace(namespaceId) : null;\n        if (ns) {\n            ns.removeNode(element, context);\n        }\n        else {\n            this.markElementAsRemoved(namespaceId, element, false, context);\n        }\n    };\n    /**\n     * @param {?} namespaceId\n     * @param {?} element\n     * @param {?=} hasAnimation\n     * @param {?=} context\n     * @return {?}\n     */\n    TransitionAnimationEngine.prototype.markElementAsRemoved = /**\n     * @param {?} namespaceId\n     * @param {?} element\n     * @param {?=} hasAnimation\n     * @param {?=} context\n     * @return {?}\n     */\n    function (namespaceId, element, hasAnimation, context) {\n        this.collectedLeaveElements.push(element);\n        element[REMOVAL_FLAG] = {\n            namespaceId: namespaceId,\n            setForRemoval: context, hasAnimation: hasAnimation,\n            removedBeforeQueried: false\n        };\n    };\n    /**\n     * @param {?} namespaceId\n     * @param {?} element\n     * @param {?} name\n     * @param {?} phase\n     * @param {?} callback\n     * @return {?}\n     */\n    TransitionAnimationEngine.prototype.listen = /**\n     * @param {?} namespaceId\n     * @param {?} element\n     * @param {?} name\n     * @param {?} phase\n     * @param {?} callback\n     * @return {?}\n     */\n    function (namespaceId, element, name, phase, callback) {\n        if (isElementNode(element)) {\n            return this._fetchNamespace(namespaceId).listen(element, name, phase, callback);\n        }\n        return function () { };\n    };\n    /**\n     * @param {?} entry\n     * @param {?} subTimelines\n     * @param {?} enterClassName\n     * @param {?} leaveClassName\n     * @param {?=} skipBuildAst\n     * @return {?}\n     */\n    TransitionAnimationEngine.prototype._buildInstruction = /**\n     * @param {?} entry\n     * @param {?} subTimelines\n     * @param {?} enterClassName\n     * @param {?} leaveClassName\n     * @param {?=} skipBuildAst\n     * @return {?}\n     */\n    function (entry, subTimelines, enterClassName, leaveClassName, skipBuildAst) {\n        return entry.transition.build(this.driver, entry.element, entry.fromState.value, entry.toState.value, enterClassName, leaveClassName, entry.fromState.options, entry.toState.options, subTimelines, skipBuildAst);\n    };\n    /**\n     * @param {?} containerElement\n     * @return {?}\n     */\n    TransitionAnimationEngine.prototype.destroyInnerAnimations = /**\n     * @param {?} containerElement\n     * @return {?}\n     */\n    function (containerElement) {\n        var _this = this;\n        /** @type {?} */\n        var elements = this.driver.query(containerElement, NG_TRIGGER_SELECTOR, true);\n        elements.forEach(function (element) { return _this.destroyActiveAnimationsForElement(element); });\n        if (this.playersByQueriedElement.size == 0)\n            return;\n        elements = this.driver.query(containerElement, NG_ANIMATING_SELECTOR, true);\n        elements.forEach(function (element) { return _this.finishActiveQueriedAnimationOnElement(element); });\n    };\n    /**\n     * @param {?} element\n     * @return {?}\n     */\n    TransitionAnimationEngine.prototype.destroyActiveAnimationsForElement = /**\n     * @param {?} element\n     * @return {?}\n     */\n    function (element) {\n        /** @type {?} */\n        var players = this.playersByElement.get(element);\n        if (players) {\n            players.forEach(function (player) {\n                // special case for when an element is set for destruction, but hasn't started.\n                // in this situation we want to delay the destruction until the flush occurs\n                // so that any event listeners attached to the player are triggered.\n                if (player.queued) {\n                    player.markedForDestroy = true;\n                }\n                else {\n                    player.destroy();\n                }\n            });\n        }\n    };\n    /**\n     * @param {?} element\n     * @return {?}\n     */\n    TransitionAnimationEngine.prototype.finishActiveQueriedAnimationOnElement = /**\n     * @param {?} element\n     * @return {?}\n     */\n    function (element) {\n        /** @type {?} */\n        var players = this.playersByQueriedElement.get(element);\n        if (players) {\n            players.forEach(function (player) { return player.finish(); });\n        }\n    };\n    /**\n     * @return {?}\n     */\n    TransitionAnimationEngine.prototype.whenRenderingDone = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            if (_this.players.length) {\n                return optimizeGroupPlayer(_this.players).onDone(function () { return resolve(); });\n            }\n            else {\n                resolve();\n            }\n        });\n    };\n    /**\n     * @param {?} element\n     * @return {?}\n     */\n    TransitionAnimationEngine.prototype.processLeaveNode = /**\n     * @param {?} element\n     * @return {?}\n     */\n    function (element) {\n        var _this = this;\n        /** @type {?} */\n        var details = /** @type {?} */ (element[REMOVAL_FLAG]);\n        if (details && details.setForRemoval) {\n            // this will prevent it from removing it twice\n            element[REMOVAL_FLAG] = NULL_REMOVAL_STATE;\n            if (details.namespaceId) {\n                this.destroyInnerAnimations(element);\n                /** @type {?} */\n                var ns = this._fetchNamespace(details.namespaceId);\n                if (ns) {\n                    ns.clearElementCache(element);\n                }\n            }\n            this._onRemovalComplete(element, details.setForRemoval);\n        }\n        if (this.driver.matchesElement(element, DISABLED_SELECTOR)) {\n            this.markElementAsDisabled(element, false);\n        }\n        this.driver.query(element, DISABLED_SELECTOR, true).forEach(function (node) {\n            _this.markElementAsDisabled(element, false);\n        });\n    };\n    /**\n     * @param {?=} microtaskId\n     * @return {?}\n     */\n    TransitionAnimationEngine.prototype.flush = /**\n     * @param {?=} microtaskId\n     * @return {?}\n     */\n    function (microtaskId) {\n        var _this = this;\n        if (microtaskId === void 0) { microtaskId = -1; }\n        /** @type {?} */\n        var players = [];\n        if (this.newHostElements.size) {\n            this.newHostElements.forEach(function (ns, element) { return _this._balanceNamespaceList(ns, element); });\n            this.newHostElements.clear();\n        }\n        if (this.totalAnimations && this.collectedEnterElements.length) {\n            for (var i = 0; i < this.collectedEnterElements.length; i++) {\n                /** @type {?} */\n                var elm = this.collectedEnterElements[i];\n                addClass(elm, STAR_CLASSNAME);\n            }\n        }\n        if (this._namespaceList.length &&\n            (this.totalQueuedPlayers || this.collectedLeaveElements.length)) {\n            /** @type {?} */\n            var cleanupFns = [];\n            try {\n                players = this._flushAnimations(cleanupFns, microtaskId);\n            }\n            finally {\n                for (var i = 0; i < cleanupFns.length; i++) {\n                    cleanupFns[i]();\n                }\n            }\n        }\n        else {\n            for (var i = 0; i < this.collectedLeaveElements.length; i++) {\n                /** @type {?} */\n                var element = this.collectedLeaveElements[i];\n                this.processLeaveNode(element);\n            }\n        }\n        this.totalQueuedPlayers = 0;\n        this.collectedEnterElements.length = 0;\n        this.collectedLeaveElements.length = 0;\n        this._flushFns.forEach(function (fn) { return fn(); });\n        this._flushFns = [];\n        if (this._whenQuietFns.length) {\n            /** @type {?} */\n            var quietFns_1 = this._whenQuietFns;\n            this._whenQuietFns = [];\n            if (players.length) {\n                optimizeGroupPlayer(players).onDone(function () { quietFns_1.forEach(function (fn) { return fn(); }); });\n            }\n            else {\n                quietFns_1.forEach(function (fn) { return fn(); });\n            }\n        }\n    };\n    /**\n     * @param {?} errors\n     * @return {?}\n     */\n    TransitionAnimationEngine.prototype.reportError = /**\n     * @param {?} errors\n     * @return {?}\n     */\n    function (errors) {\n        throw new Error(\"Unable to process animations due to the following failed trigger transitions\\n \" + errors.join('\\n'));\n    };\n    /**\n     * @param {?} cleanupFns\n     * @param {?} microtaskId\n     * @return {?}\n     */\n    TransitionAnimationEngine.prototype._flushAnimations = /**\n     * @param {?} cleanupFns\n     * @param {?} microtaskId\n     * @return {?}\n     */\n    function (cleanupFns, microtaskId) {\n        var _this = this;\n        /** @type {?} */\n        var subTimelines = new ElementInstructionMap();\n        /** @type {?} */\n        var skippedPlayers = [];\n        /** @type {?} */\n        var skippedPlayersMap = new Map();\n        /** @type {?} */\n        var queuedInstructions = [];\n        /** @type {?} */\n        var queriedElements = new Map();\n        /** @type {?} */\n        var allPreStyleElements = new Map();\n        /** @type {?} */\n        var allPostStyleElements = new Map();\n        /** @type {?} */\n        var disabledElementsSet = new Set();\n        this.disabledNodes.forEach(function (node) {\n            disabledElementsSet.add(node);\n            /** @type {?} */\n            var nodesThatAreDisabled = _this.driver.query(node, QUEUED_SELECTOR, true);\n            for (var i_1 = 0; i_1 < nodesThatAreDisabled.length; i_1++) {\n                disabledElementsSet.add(nodesThatAreDisabled[i_1]);\n            }\n        });\n        /** @type {?} */\n        var bodyNode = this.bodyNode;\n        /** @type {?} */\n        var allTriggerElements = Array.from(this.statesByElement.keys());\n        /** @type {?} */\n        var enterNodeMap = buildRootMap(allTriggerElements, this.collectedEnterElements);\n        /** @type {?} */\n        var enterNodeMapIds = new Map();\n        /** @type {?} */\n        var i = 0;\n        enterNodeMap.forEach(function (nodes, root) {\n            /** @type {?} */\n            var className = ENTER_CLASSNAME + i++;\n            enterNodeMapIds.set(root, className);\n            nodes.forEach(function (node) { return addClass(node, className); });\n        });\n        /** @type {?} */\n        var allLeaveNodes = [];\n        /** @type {?} */\n        var mergedLeaveNodes = new Set();\n        /** @type {?} */\n        var leaveNodesWithoutAnimations = new Set();\n        for (var i_2 = 0; i_2 < this.collectedLeaveElements.length; i_2++) {\n            /** @type {?} */\n            var element = this.collectedLeaveElements[i_2];\n            /** @type {?} */\n            var details = /** @type {?} */ (element[REMOVAL_FLAG]);\n            if (details && details.setForRemoval) {\n                allLeaveNodes.push(element);\n                mergedLeaveNodes.add(element);\n                if (details.hasAnimation) {\n                    this.driver.query(element, STAR_SELECTOR, true).forEach(function (elm) { return mergedLeaveNodes.add(elm); });\n                }\n                else {\n                    leaveNodesWithoutAnimations.add(element);\n                }\n            }\n        }\n        /** @type {?} */\n        var leaveNodeMapIds = new Map();\n        /** @type {?} */\n        var leaveNodeMap = buildRootMap(allTriggerElements, Array.from(mergedLeaveNodes));\n        leaveNodeMap.forEach(function (nodes, root) {\n            /** @type {?} */\n            var className = LEAVE_CLASSNAME + i++;\n            leaveNodeMapIds.set(root, className);\n            nodes.forEach(function (node) { return addClass(node, className); });\n        });\n        cleanupFns.push(function () {\n            enterNodeMap.forEach(function (nodes, root) {\n                /** @type {?} */\n                var className = /** @type {?} */ ((enterNodeMapIds.get(root)));\n                nodes.forEach(function (node) { return removeClass(node, className); });\n            });\n            leaveNodeMap.forEach(function (nodes, root) {\n                /** @type {?} */\n                var className = /** @type {?} */ ((leaveNodeMapIds.get(root)));\n                nodes.forEach(function (node) { return removeClass(node, className); });\n            });\n            allLeaveNodes.forEach(function (element) { _this.processLeaveNode(element); });\n        });\n        /** @type {?} */\n        var allPlayers = [];\n        /** @type {?} */\n        var erroneousTransitions = [];\n        for (var i_3 = this._namespaceList.length - 1; i_3 >= 0; i_3--) {\n            /** @type {?} */\n            var ns = this._namespaceList[i_3];\n            ns.drainQueuedTransitions(microtaskId).forEach(function (entry) {\n                /** @type {?} */\n                var player = entry.player;\n                /** @type {?} */\n                var element = entry.element;\n                allPlayers.push(player);\n                if (_this.collectedEnterElements.length) {\n                    /** @type {?} */\n                    var details = /** @type {?} */ (element[REMOVAL_FLAG]);\n                    // move animations are currently not supported...\n                    if (details && details.setForMove) {\n                        player.destroy();\n                        return;\n                    }\n                }\n                /** @type {?} */\n                var nodeIsOrphaned = !bodyNode || !_this.driver.containsElement(bodyNode, element);\n                /** @type {?} */\n                var leaveClassName = /** @type {?} */ ((leaveNodeMapIds.get(element)));\n                /** @type {?} */\n                var enterClassName = /** @type {?} */ ((enterNodeMapIds.get(element)));\n                /** @type {?} */\n                var instruction = /** @type {?} */ ((_this._buildInstruction(entry, subTimelines, enterClassName, leaveClassName, nodeIsOrphaned)));\n                if (instruction.errors && instruction.errors.length) {\n                    erroneousTransitions.push(instruction);\n                    return;\n                }\n                // even though the element may not be apart of the DOM, it may\n                // still be added at a later point (due to the mechanics of content\n                // projection and/or dynamic component insertion) therefore it's\n                // important we still style the element.\n                if (nodeIsOrphaned) {\n                    player.onStart(function () { return eraseStyles(element, instruction.fromStyles); });\n                    player.onDestroy(function () { return setStyles(element, instruction.toStyles); });\n                    skippedPlayers.push(player);\n                    return;\n                }\n                // if a unmatched transition is queued to go then it SHOULD NOT render\n                // an animation and cancel the previously running animations.\n                if (entry.isFallbackTransition) {\n                    player.onStart(function () { return eraseStyles(element, instruction.fromStyles); });\n                    player.onDestroy(function () { return setStyles(element, instruction.toStyles); });\n                    skippedPlayers.push(player);\n                    return;\n                }\n                // this means that if a parent animation uses this animation as a sub trigger\n                // then it will instruct the timeline builder to not add a player delay, but\n                // instead stretch the first keyframe gap up until the animation starts. The\n                // reason this is important is to prevent extra initialization styles from being\n                // required by the user in the animation.\n                instruction.timelines.forEach(function (tl) { return tl.stretchStartingKeyframe = true; });\n                subTimelines.append(element, instruction.timelines);\n                /** @type {?} */\n                var tuple = { instruction: instruction, player: player, element: element };\n                queuedInstructions.push(tuple);\n                instruction.queriedElements.forEach(function (element) { return getOrSetAsInMap(queriedElements, element, []).push(player); });\n                instruction.preStyleProps.forEach(function (stringMap, element) {\n                    /** @type {?} */\n                    var props = Object.keys(stringMap);\n                    if (props.length) {\n                        /** @type {?} */\n                        var setVal_1 = /** @type {?} */ ((allPreStyleElements.get(element)));\n                        if (!setVal_1) {\n                            allPreStyleElements.set(element, setVal_1 = new Set());\n                        }\n                        props.forEach(function (prop) { return setVal_1.add(prop); });\n                    }\n                });\n                instruction.postStyleProps.forEach(function (stringMap, element) {\n                    /** @type {?} */\n                    var props = Object.keys(stringMap);\n                    /** @type {?} */\n                    var setVal = /** @type {?} */ ((allPostStyleElements.get(element)));\n                    if (!setVal) {\n                        allPostStyleElements.set(element, setVal = new Set());\n                    }\n                    props.forEach(function (prop) { return setVal.add(prop); });\n                });\n            });\n        }\n        if (erroneousTransitions.length) {\n            /** @type {?} */\n            var errors_1 = [];\n            erroneousTransitions.forEach(function (instruction) {\n                errors_1.push(\"@\" + instruction.triggerName + \" has failed due to:\\n\"); /** @type {?} */\n                ((instruction.errors)).forEach(function (error) { return errors_1.push(\"- \" + error + \"\\n\"); });\n            });\n            allPlayers.forEach(function (player) { return player.destroy(); });\n            this.reportError(errors_1);\n        }\n        /** @type {?} */\n        var allPreviousPlayersMap = new Map();\n        /** @type {?} */\n        var animationElementMap = new Map();\n        queuedInstructions.forEach(function (entry) {\n            /** @type {?} */\n            var element = entry.element;\n            if (subTimelines.has(element)) {\n                animationElementMap.set(element, element);\n                _this._beforeAnimationBuild(entry.player.namespaceId, entry.instruction, allPreviousPlayersMap);\n            }\n        });\n        skippedPlayers.forEach(function (player) {\n            /** @type {?} */\n            var element = player.element;\n            /** @type {?} */\n            var previousPlayers = _this._getPreviousPlayers(element, false, player.namespaceId, player.triggerName, null);\n            previousPlayers.forEach(function (prevPlayer) {\n                getOrSetAsInMap(allPreviousPlayersMap, element, []).push(prevPlayer);\n                prevPlayer.destroy();\n            });\n        });\n        /** @type {?} */\n        var replaceNodes = allLeaveNodes.filter(function (node) {\n            return replacePostStylesAsPre(node, allPreStyleElements, allPostStyleElements);\n        });\n        /** @type {?} */\n        var postStylesMap = new Map();\n        /** @type {?} */\n        var allLeaveQueriedNodes = cloakAndComputeStyles(postStylesMap, this.driver, leaveNodesWithoutAnimations, allPostStyleElements, AUTO_STYLE);\n        allLeaveQueriedNodes.forEach(function (node) {\n            if (replacePostStylesAsPre(node, allPreStyleElements, allPostStyleElements)) {\n                replaceNodes.push(node);\n            }\n        });\n        /** @type {?} */\n        var preStylesMap = new Map();\n        enterNodeMap.forEach(function (nodes, root) {\n            cloakAndComputeStyles(preStylesMap, _this.driver, new Set(nodes), allPreStyleElements, PRE_STYLE);\n        });\n        replaceNodes.forEach(function (node) {\n            /** @type {?} */\n            var post = postStylesMap.get(node);\n            /** @type {?} */\n            var pre = preStylesMap.get(node);\n            postStylesMap.set(node, /** @type {?} */ (tslib_1.__assign({}, post, pre)));\n        });\n        /** @type {?} */\n        var rootPlayers = [];\n        /** @type {?} */\n        var subPlayers = [];\n        /** @type {?} */\n        var NO_PARENT_ANIMATION_ELEMENT_DETECTED = {};\n        queuedInstructions.forEach(function (entry) {\n            var element = entry.element, player = entry.player, instruction = entry.instruction;\n            // this means that it was never consumed by a parent animation which\n            // means that it is independent and therefore should be set for animation\n            if (subTimelines.has(element)) {\n                if (disabledElementsSet.has(element)) {\n                    player.onDestroy(function () { return setStyles(element, instruction.toStyles); });\n                    player.disabled = true;\n                    player.overrideTotalTime(instruction.totalTime);\n                    skippedPlayers.push(player);\n                    return;\n                }\n                /** @type {?} */\n                var parentWithAnimation_1 = NO_PARENT_ANIMATION_ELEMENT_DETECTED;\n                if (animationElementMap.size > 1) {\n                    /** @type {?} */\n                    var elm = element;\n                    /** @type {?} */\n                    var parentsToAdd = [];\n                    while (elm = elm.parentNode) {\n                        /** @type {?} */\n                        var detectedParent = animationElementMap.get(elm);\n                        if (detectedParent) {\n                            parentWithAnimation_1 = detectedParent;\n                            break;\n                        }\n                        parentsToAdd.push(elm);\n                    }\n                    parentsToAdd.forEach(function (parent) { return animationElementMap.set(parent, parentWithAnimation_1); });\n                }\n                /** @type {?} */\n                var innerPlayer = _this._buildAnimation(player.namespaceId, instruction, allPreviousPlayersMap, skippedPlayersMap, preStylesMap, postStylesMap);\n                player.setRealPlayer(innerPlayer);\n                if (parentWithAnimation_1 === NO_PARENT_ANIMATION_ELEMENT_DETECTED) {\n                    rootPlayers.push(player);\n                }\n                else {\n                    /** @type {?} */\n                    var parentPlayers = _this.playersByElement.get(parentWithAnimation_1);\n                    if (parentPlayers && parentPlayers.length) {\n                        player.parentPlayer = optimizeGroupPlayer(parentPlayers);\n                    }\n                    skippedPlayers.push(player);\n                }\n            }\n            else {\n                eraseStyles(element, instruction.fromStyles);\n                player.onDestroy(function () { return setStyles(element, instruction.toStyles); });\n                // there still might be a ancestor player animating this\n                // element therefore we will still add it as a sub player\n                // even if its animation may be disabled\n                subPlayers.push(player);\n                if (disabledElementsSet.has(element)) {\n                    skippedPlayers.push(player);\n                }\n            }\n        });\n        // find all of the sub players' corresponding inner animation player\n        subPlayers.forEach(function (player) {\n            /** @type {?} */\n            var playersForElement = skippedPlayersMap.get(player.element);\n            if (playersForElement && playersForElement.length) {\n                /** @type {?} */\n                var innerPlayer = optimizeGroupPlayer(playersForElement);\n                player.setRealPlayer(innerPlayer);\n            }\n        });\n        // the reason why we don't actually play the animation is\n        // because all that a skipped player is designed to do is to\n        // fire the start/done transition callback events\n        skippedPlayers.forEach(function (player) {\n            if (player.parentPlayer) {\n                player.syncPlayerEvents(player.parentPlayer);\n            }\n            else {\n                player.destroy();\n            }\n        });\n        // run through all of the queued removals and see if they\n        // were picked up by a query. If not then perform the removal\n        // operation right away unless a parent animation is ongoing.\n        for (var i_4 = 0; i_4 < allLeaveNodes.length; i_4++) {\n            /** @type {?} */\n            var element = allLeaveNodes[i_4];\n            /** @type {?} */\n            var details = /** @type {?} */ (element[REMOVAL_FLAG]);\n            removeClass(element, LEAVE_CLASSNAME);\n            // this means the element has a removal animation that is being\n            // taken care of and therefore the inner elements will hang around\n            // until that animation is over (or the parent queried animation)\n            if (details && details.hasAnimation)\n                continue;\n            /** @type {?} */\n            var players = [];\n            // if this element is queried or if it contains queried children\n            // then we want for the element not to be removed from the page\n            // until the queried animations have finished\n            if (queriedElements.size) {\n                /** @type {?} */\n                var queriedPlayerResults = queriedElements.get(element);\n                if (queriedPlayerResults && queriedPlayerResults.length) {\n                    players.push.apply(players, queriedPlayerResults);\n                }\n                /** @type {?} */\n                var queriedInnerElements = this.driver.query(element, NG_ANIMATING_SELECTOR, true);\n                for (var j = 0; j < queriedInnerElements.length; j++) {\n                    /** @type {?} */\n                    var queriedPlayers = queriedElements.get(queriedInnerElements[j]);\n                    if (queriedPlayers && queriedPlayers.length) {\n                        players.push.apply(players, queriedPlayers);\n                    }\n                }\n            }\n            /** @type {?} */\n            var activePlayers = players.filter(function (p) { return !p.destroyed; });\n            if (activePlayers.length) {\n                removeNodesAfterAnimationDone(this, element, activePlayers);\n            }\n            else {\n                this.processLeaveNode(element);\n            }\n        }\n        // this is required so the cleanup method doesn't remove them\n        allLeaveNodes.length = 0;\n        rootPlayers.forEach(function (player) {\n            _this.players.push(player);\n            player.onDone(function () {\n                player.destroy();\n                /** @type {?} */\n                var index = _this.players.indexOf(player);\n                _this.players.splice(index, 1);\n            });\n            player.play();\n        });\n        return rootPlayers;\n    };\n    /**\n     * @param {?} namespaceId\n     * @param {?} element\n     * @return {?}\n     */\n    TransitionAnimationEngine.prototype.elementContainsData = /**\n     * @param {?} namespaceId\n     * @param {?} element\n     * @return {?}\n     */\n    function (namespaceId, element) {\n        /** @type {?} */\n        var containsData = false;\n        /** @type {?} */\n        var details = /** @type {?} */ (element[REMOVAL_FLAG]);\n        if (details && details.setForRemoval)\n            containsData = true;\n        if (this.playersByElement.has(element))\n            containsData = true;\n        if (this.playersByQueriedElement.has(element))\n            containsData = true;\n        if (this.statesByElement.has(element))\n            containsData = true;\n        return this._fetchNamespace(namespaceId).elementContainsData(element) || containsData;\n    };\n    /**\n     * @param {?} callback\n     * @return {?}\n     */\n    TransitionAnimationEngine.prototype.afterFlush = /**\n     * @param {?} callback\n     * @return {?}\n     */\n    function (callback) { this._flushFns.push(callback); };\n    /**\n     * @param {?} callback\n     * @return {?}\n     */\n    TransitionAnimationEngine.prototype.afterFlushAnimationsDone = /**\n     * @param {?} callback\n     * @return {?}\n     */\n    function (callback) { this._whenQuietFns.push(callback); };\n    /**\n     * @param {?} element\n     * @param {?} isQueriedElement\n     * @param {?=} namespaceId\n     * @param {?=} triggerName\n     * @param {?=} toStateValue\n     * @return {?}\n     */\n    TransitionAnimationEngine.prototype._getPreviousPlayers = /**\n     * @param {?} element\n     * @param {?} isQueriedElement\n     * @param {?=} namespaceId\n     * @param {?=} triggerName\n     * @param {?=} toStateValue\n     * @return {?}\n     */\n    function (element, isQueriedElement, namespaceId, triggerName, toStateValue) {\n        /** @type {?} */\n        var players = [];\n        if (isQueriedElement) {\n            /** @type {?} */\n            var queriedElementPlayers = this.playersByQueriedElement.get(element);\n            if (queriedElementPlayers) {\n                players = queriedElementPlayers;\n            }\n        }\n        else {\n            /** @type {?} */\n            var elementPlayers = this.playersByElement.get(element);\n            if (elementPlayers) {\n                /** @type {?} */\n                var isRemovalAnimation_1 = !toStateValue || toStateValue == VOID_VALUE;\n                elementPlayers.forEach(function (player) {\n                    if (player.queued)\n                        return;\n                    if (!isRemovalAnimation_1 && player.triggerName != triggerName)\n                        return;\n                    players.push(player);\n                });\n            }\n        }\n        if (namespaceId || triggerName) {\n            players = players.filter(function (player) {\n                if (namespaceId && namespaceId != player.namespaceId)\n                    return false;\n                if (triggerName && triggerName != player.triggerName)\n                    return false;\n                return true;\n            });\n        }\n        return players;\n    };\n    /**\n     * @param {?} namespaceId\n     * @param {?} instruction\n     * @param {?} allPreviousPlayersMap\n     * @return {?}\n     */\n    TransitionAnimationEngine.prototype._beforeAnimationBuild = /**\n     * @param {?} namespaceId\n     * @param {?} instruction\n     * @param {?} allPreviousPlayersMap\n     * @return {?}\n     */\n    function (namespaceId, instruction, allPreviousPlayersMap) {\n        /** @type {?} */\n        var triggerName = instruction.triggerName;\n        /** @type {?} */\n        var rootElement = instruction.element;\n        /** @type {?} */\n        var targetNameSpaceId = instruction.isRemovalTransition ? undefined : namespaceId;\n        /** @type {?} */\n        var targetTriggerName = instruction.isRemovalTransition ? undefined : triggerName;\n        var _loop_1 = function (timelineInstruction) {\n            /** @type {?} */\n            var element = timelineInstruction.element;\n            /** @type {?} */\n            var isQueriedElement = element !== rootElement;\n            /** @type {?} */\n            var players = getOrSetAsInMap(allPreviousPlayersMap, element, []);\n            /** @type {?} */\n            var previousPlayers = this_1._getPreviousPlayers(element, isQueriedElement, targetNameSpaceId, targetTriggerName, instruction.toState);\n            previousPlayers.forEach(function (player) {\n                /** @type {?} */\n                var realPlayer = /** @type {?} */ (player.getRealPlayer());\n                if (realPlayer.beforeDestroy) {\n                    realPlayer.beforeDestroy();\n                }\n                player.destroy();\n                players.push(player);\n            });\n        };\n        var this_1 = this;\n        for (var _i = 0, _a = instruction.timelines; _i < _a.length; _i++) {\n            var timelineInstruction = _a[_i];\n            _loop_1(timelineInstruction);\n        }\n        // this needs to be done so that the PRE/POST styles can be\n        // computed properly without interfering with the previous animation\n        eraseStyles(rootElement, instruction.fromStyles);\n    };\n    /**\n     * @param {?} namespaceId\n     * @param {?} instruction\n     * @param {?} allPreviousPlayersMap\n     * @param {?} skippedPlayersMap\n     * @param {?} preStylesMap\n     * @param {?} postStylesMap\n     * @return {?}\n     */\n    TransitionAnimationEngine.prototype._buildAnimation = /**\n     * @param {?} namespaceId\n     * @param {?} instruction\n     * @param {?} allPreviousPlayersMap\n     * @param {?} skippedPlayersMap\n     * @param {?} preStylesMap\n     * @param {?} postStylesMap\n     * @return {?}\n     */\n    function (namespaceId, instruction, allPreviousPlayersMap, skippedPlayersMap, preStylesMap, postStylesMap) {\n        var _this = this;\n        /** @type {?} */\n        var triggerName = instruction.triggerName;\n        /** @type {?} */\n        var rootElement = instruction.element;\n        /** @type {?} */\n        var allQueriedPlayers = [];\n        /** @type {?} */\n        var allConsumedElements = new Set();\n        /** @type {?} */\n        var allSubElements = new Set();\n        /** @type {?} */\n        var allNewPlayers = instruction.timelines.map(function (timelineInstruction) {\n            /** @type {?} */\n            var element = timelineInstruction.element;\n            allConsumedElements.add(element);\n            /** @type {?} */\n            var details = element[REMOVAL_FLAG];\n            if (details && details.removedBeforeQueried)\n                return new NoopAnimationPlayer(timelineInstruction.duration, timelineInstruction.delay);\n            /** @type {?} */\n            var isQueriedElement = element !== rootElement;\n            /** @type {?} */\n            var previousPlayers = flattenGroupPlayers((allPreviousPlayersMap.get(element) || EMPTY_PLAYER_ARRAY)\n                .map(function (p) { return p.getRealPlayer(); }))\n                .filter(function (p) {\n                /** @type {?} */\n                var pp = /** @type {?} */ (p);\n                return pp.element ? pp.element === element : false;\n            });\n            /** @type {?} */\n            var preStyles = preStylesMap.get(element);\n            /** @type {?} */\n            var postStyles = postStylesMap.get(element);\n            /** @type {?} */\n            var keyframes = normalizeKeyframes(_this.driver, _this._normalizer, element, timelineInstruction.keyframes, preStyles, postStyles);\n            /** @type {?} */\n            var player = _this._buildPlayer(timelineInstruction, keyframes, previousPlayers);\n            // this means that this particular player belongs to a sub trigger. It is\n            // important that we match this player up with the corresponding (@trigger.listener)\n            if (timelineInstruction.subTimeline && skippedPlayersMap) {\n                allSubElements.add(element);\n            }\n            if (isQueriedElement) {\n                /** @type {?} */\n                var wrappedPlayer = new TransitionAnimationPlayer(namespaceId, triggerName, element);\n                wrappedPlayer.setRealPlayer(player);\n                allQueriedPlayers.push(wrappedPlayer);\n            }\n            return player;\n        });\n        allQueriedPlayers.forEach(function (player) {\n            getOrSetAsInMap(_this.playersByQueriedElement, player.element, []).push(player);\n            player.onDone(function () { return deleteOrUnsetInMap(_this.playersByQueriedElement, player.element, player); });\n        });\n        allConsumedElements.forEach(function (element) { return addClass(element, NG_ANIMATING_CLASSNAME); });\n        /** @type {?} */\n        var player = optimizeGroupPlayer(allNewPlayers);\n        player.onDestroy(function () {\n            allConsumedElements.forEach(function (element) { return removeClass(element, NG_ANIMATING_CLASSNAME); });\n            setStyles(rootElement, instruction.toStyles);\n        });\n        // this basically makes all of the callbacks for sub element animations\n        // be dependent on the upper players for when they finish\n        allSubElements.forEach(function (element) { getOrSetAsInMap(skippedPlayersMap, element, []).push(player); });\n        return player;\n    };\n    /**\n     * @param {?} instruction\n     * @param {?} keyframes\n     * @param {?} previousPlayers\n     * @return {?}\n     */\n    TransitionAnimationEngine.prototype._buildPlayer = /**\n     * @param {?} instruction\n     * @param {?} keyframes\n     * @param {?} previousPlayers\n     * @return {?}\n     */\n    function (instruction, keyframes, previousPlayers) {\n        if (keyframes.length > 0) {\n            return this.driver.animate(instruction.element, keyframes, instruction.duration, instruction.delay, instruction.easing, previousPlayers);\n        }\n        // special case for when an empty transition|definition is provided\n        // ... there is no point in rendering an empty animation\n        return new NoopAnimationPlayer(instruction.duration, instruction.delay);\n    };\n    return TransitionAnimationEngine;\n}());\nexport { TransitionAnimationEngine };\nif (false) {\n    /** @type {?} */\n    TransitionAnimationEngine.prototype.players;\n    /** @type {?} */\n    TransitionAnimationEngine.prototype.newHostElements;\n    /** @type {?} */\n    TransitionAnimationEngine.prototype.playersByElement;\n    /** @type {?} */\n    TransitionAnimationEngine.prototype.playersByQueriedElement;\n    /** @type {?} */\n    TransitionAnimationEngine.prototype.statesByElement;\n    /** @type {?} */\n    TransitionAnimationEngine.prototype.disabledNodes;\n    /** @type {?} */\n    TransitionAnimationEngine.prototype.totalAnimations;\n    /** @type {?} */\n    TransitionAnimationEngine.prototype.totalQueuedPlayers;\n    /** @type {?} */\n    TransitionAnimationEngine.prototype._namespaceLookup;\n    /** @type {?} */\n    TransitionAnimationEngine.prototype._namespaceList;\n    /** @type {?} */\n    TransitionAnimationEngine.prototype._flushFns;\n    /** @type {?} */\n    TransitionAnimationEngine.prototype._whenQuietFns;\n    /** @type {?} */\n    TransitionAnimationEngine.prototype.namespacesByHostElement;\n    /** @type {?} */\n    TransitionAnimationEngine.prototype.collectedEnterElements;\n    /** @type {?} */\n    TransitionAnimationEngine.prototype.collectedLeaveElements;\n    /** @type {?} */\n    TransitionAnimationEngine.prototype.onRemovalComplete;\n    /** @type {?} */\n    TransitionAnimationEngine.prototype.bodyNode;\n    /** @type {?} */\n    TransitionAnimationEngine.prototype.driver;\n    /** @type {?} */\n    TransitionAnimationEngine.prototype._normalizer;\n}\nvar TransitionAnimationPlayer = /** @class */ (function () {\n    function TransitionAnimationPlayer(namespaceId, triggerName, element) {\n        this.namespaceId = namespaceId;\n        this.triggerName = triggerName;\n        this.element = element;\n        this._player = new NoopAnimationPlayer();\n        this._containsRealPlayer = false;\n        this._queuedCallbacks = {};\n        this.destroyed = false;\n        this.markedForDestroy = false;\n        this.disabled = false;\n        this.queued = true;\n        this.totalTime = 0;\n    }\n    /**\n     * @param {?} player\n     * @return {?}\n     */\n    TransitionAnimationPlayer.prototype.setRealPlayer = /**\n     * @param {?} player\n     * @return {?}\n     */\n    function (player) {\n        var _this = this;\n        if (this._containsRealPlayer)\n            return;\n        this._player = player;\n        Object.keys(this._queuedCallbacks).forEach(function (phase) {\n            _this._queuedCallbacks[phase].forEach(function (callback) { return listenOnPlayer(player, phase, undefined, callback); });\n        });\n        this._queuedCallbacks = {};\n        this._containsRealPlayer = true;\n        this.overrideTotalTime(player.totalTime);\n        (/** @type {?} */ (this)).queued = false;\n    };\n    /**\n     * @return {?}\n     */\n    TransitionAnimationPlayer.prototype.getRealPlayer = /**\n     * @return {?}\n     */\n    function () { return this._player; };\n    /**\n     * @param {?} totalTime\n     * @return {?}\n     */\n    TransitionAnimationPlayer.prototype.overrideTotalTime = /**\n     * @param {?} totalTime\n     * @return {?}\n     */\n    function (totalTime) { (/** @type {?} */ (this)).totalTime = totalTime; };\n    /**\n     * @param {?} player\n     * @return {?}\n     */\n    TransitionAnimationPlayer.prototype.syncPlayerEvents = /**\n     * @param {?} player\n     * @return {?}\n     */\n    function (player) {\n        var _this = this;\n        /** @type {?} */\n        var p = /** @type {?} */ (this._player);\n        if (p.triggerCallback) {\n            player.onStart(function () { return ((p.triggerCallback))('start'); });\n        }\n        player.onDone(function () { return _this.finish(); });\n        player.onDestroy(function () { return _this.destroy(); });\n    };\n    /**\n     * @param {?} name\n     * @param {?} callback\n     * @return {?}\n     */\n    TransitionAnimationPlayer.prototype._queueEvent = /**\n     * @param {?} name\n     * @param {?} callback\n     * @return {?}\n     */\n    function (name, callback) {\n        getOrSetAsInMap(this._queuedCallbacks, name, []).push(callback);\n    };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    TransitionAnimationPlayer.prototype.onDone = /**\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) {\n        if (this.queued) {\n            this._queueEvent('done', fn);\n        }\n        this._player.onDone(fn);\n    };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    TransitionAnimationPlayer.prototype.onStart = /**\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) {\n        if (this.queued) {\n            this._queueEvent('start', fn);\n        }\n        this._player.onStart(fn);\n    };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    TransitionAnimationPlayer.prototype.onDestroy = /**\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) {\n        if (this.queued) {\n            this._queueEvent('destroy', fn);\n        }\n        this._player.onDestroy(fn);\n    };\n    /**\n     * @return {?}\n     */\n    TransitionAnimationPlayer.prototype.init = /**\n     * @return {?}\n     */\n    function () { this._player.init(); };\n    /**\n     * @return {?}\n     */\n    TransitionAnimationPlayer.prototype.hasStarted = /**\n     * @return {?}\n     */\n    function () { return this.queued ? false : this._player.hasStarted(); };\n    /**\n     * @return {?}\n     */\n    TransitionAnimationPlayer.prototype.play = /**\n     * @return {?}\n     */\n    function () { !this.queued && this._player.play(); };\n    /**\n     * @return {?}\n     */\n    TransitionAnimationPlayer.prototype.pause = /**\n     * @return {?}\n     */\n    function () { !this.queued && this._player.pause(); };\n    /**\n     * @return {?}\n     */\n    TransitionAnimationPlayer.prototype.restart = /**\n     * @return {?}\n     */\n    function () { !this.queued && this._player.restart(); };\n    /**\n     * @return {?}\n     */\n    TransitionAnimationPlayer.prototype.finish = /**\n     * @return {?}\n     */\n    function () { this._player.finish(); };\n    /**\n     * @return {?}\n     */\n    TransitionAnimationPlayer.prototype.destroy = /**\n     * @return {?}\n     */\n    function () {\n        (/** @type {?} */ (this)).destroyed = true;\n        this._player.destroy();\n    };\n    /**\n     * @return {?}\n     */\n    TransitionAnimationPlayer.prototype.reset = /**\n     * @return {?}\n     */\n    function () { !this.queued && this._player.reset(); };\n    /**\n     * @param {?} p\n     * @return {?}\n     */\n    TransitionAnimationPlayer.prototype.setPosition = /**\n     * @param {?} p\n     * @return {?}\n     */\n    function (p) {\n        if (!this.queued) {\n            this._player.setPosition(p);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    TransitionAnimationPlayer.prototype.getPosition = /**\n     * @return {?}\n     */\n    function () { return this.queued ? 0 : this._player.getPosition(); };\n    /** @internal */\n    /**\n     * \\@internal\n     * @param {?} phaseName\n     * @return {?}\n     */\n    TransitionAnimationPlayer.prototype.triggerCallback = /**\n     * \\@internal\n     * @param {?} phaseName\n     * @return {?}\n     */\n    function (phaseName) {\n        /** @type {?} */\n        var p = /** @type {?} */ (this._player);\n        if (p.triggerCallback) {\n            p.triggerCallback(phaseName);\n        }\n    };\n    return TransitionAnimationPlayer;\n}());\nexport { TransitionAnimationPlayer };\nif (false) {\n    /** @type {?} */\n    TransitionAnimationPlayer.prototype._player;\n    /** @type {?} */\n    TransitionAnimationPlayer.prototype._containsRealPlayer;\n    /** @type {?} */\n    TransitionAnimationPlayer.prototype._queuedCallbacks;\n    /** @type {?} */\n    TransitionAnimationPlayer.prototype.destroyed;\n    /** @type {?} */\n    TransitionAnimationPlayer.prototype.parentPlayer;\n    /** @type {?} */\n    TransitionAnimationPlayer.prototype.markedForDestroy;\n    /** @type {?} */\n    TransitionAnimationPlayer.prototype.disabled;\n    /** @type {?} */\n    TransitionAnimationPlayer.prototype.queued;\n    /** @type {?} */\n    TransitionAnimationPlayer.prototype.totalTime;\n    /** @type {?} */\n    TransitionAnimationPlayer.prototype.namespaceId;\n    /** @type {?} */\n    TransitionAnimationPlayer.prototype.triggerName;\n    /** @type {?} */\n    TransitionAnimationPlayer.prototype.element;\n}\n/**\n * @param {?} map\n * @param {?} key\n * @param {?} value\n * @return {?}\n */\nfunction deleteOrUnsetInMap(map, key, value) {\n    /** @type {?} */\n    var currentValues;\n    if (map instanceof Map) {\n        currentValues = map.get(key);\n        if (currentValues) {\n            if (currentValues.length) {\n                /** @type {?} */\n                var index = currentValues.indexOf(value);\n                currentValues.splice(index, 1);\n            }\n            if (currentValues.length == 0) {\n                map.delete(key);\n            }\n        }\n    }\n    else {\n        currentValues = map[key];\n        if (currentValues) {\n            if (currentValues.length) {\n                /** @type {?} */\n                var index = currentValues.indexOf(value);\n                currentValues.splice(index, 1);\n            }\n            if (currentValues.length == 0) {\n                delete map[key];\n            }\n        }\n    }\n    return currentValues;\n}\n/**\n * @param {?} value\n * @return {?}\n */\nfunction normalizeTriggerValue(value) {\n    // we use `!= null` here because it's the most simple\n    // way to test against a \"falsy\" value without mixing\n    // in empty strings or a zero value. DO NOT OPTIMIZE.\n    return value != null ? value : null;\n}\n/**\n * @param {?} node\n * @return {?}\n */\nfunction isElementNode(node) {\n    return node && node['nodeType'] === 1;\n}\n/**\n * @param {?} eventName\n * @return {?}\n */\nfunction isTriggerEventValid(eventName) {\n    return eventName == 'start' || eventName == 'done';\n}\n/**\n * @param {?} element\n * @param {?=} value\n * @return {?}\n */\nfunction cloakElement(element, value) {\n    /** @type {?} */\n    var oldValue = element.style.display;\n    element.style.display = value != null ? value : 'none';\n    return oldValue;\n}\n/**\n * @param {?} valuesMap\n * @param {?} driver\n * @param {?} elements\n * @param {?} elementPropsMap\n * @param {?} defaultStyle\n * @return {?}\n */\nfunction cloakAndComputeStyles(valuesMap, driver, elements, elementPropsMap, defaultStyle) {\n    /** @type {?} */\n    var cloakVals = [];\n    elements.forEach(function (element) { return cloakVals.push(cloakElement(element)); });\n    /** @type {?} */\n    var failedElements = [];\n    elementPropsMap.forEach(function (props, element) {\n        /** @type {?} */\n        var styles = {};\n        props.forEach(function (prop) {\n            /** @type {?} */\n            var value = styles[prop] = driver.computeStyle(element, prop, defaultStyle);\n            // there is no easy way to detect this because a sub element could be removed\n            // by a parent animation element being detached.\n            if (!value || value.length == 0) {\n                element[REMOVAL_FLAG] = NULL_REMOVED_QUERIED_STATE;\n                failedElements.push(element);\n            }\n        });\n        valuesMap.set(element, styles);\n    });\n    /** @type {?} */\n    var i = 0;\n    elements.forEach(function (element) { return cloakElement(element, cloakVals[i++]); });\n    return failedElements;\n}\n/**\n * @param {?} roots\n * @param {?} nodes\n * @return {?}\n */\nfunction buildRootMap(roots, nodes) {\n    /** @type {?} */\n    var rootMap = new Map();\n    roots.forEach(function (root) { return rootMap.set(root, []); });\n    if (nodes.length == 0)\n        return rootMap;\n    /** @type {?} */\n    var NULL_NODE = 1;\n    /** @type {?} */\n    var nodeSet = new Set(nodes);\n    /** @type {?} */\n    var localRootMap = new Map();\n    /**\n     * @param {?} node\n     * @return {?}\n     */\n    function getRoot(node) {\n        if (!node)\n            return NULL_NODE;\n        /** @type {?} */\n        var root = localRootMap.get(node);\n        if (root)\n            return root;\n        /** @type {?} */\n        var parent = node.parentNode;\n        if (rootMap.has(parent)) { // ngIf inside @trigger\n            // ngIf inside @trigger\n            root = parent;\n        }\n        else if (nodeSet.has(parent)) { // ngIf inside ngIf\n            // ngIf inside ngIf\n            root = NULL_NODE;\n        }\n        else { // recurse upwards\n            // recurse upwards\n            root = getRoot(parent);\n        }\n        localRootMap.set(node, root);\n        return root;\n    }\n    nodes.forEach(function (node) {\n        /** @type {?} */\n        var root = getRoot(node);\n        if (root !== NULL_NODE) {\n            /** @type {?} */ ((rootMap.get(root))).push(node);\n        }\n    });\n    return rootMap;\n}\n/** @type {?} */\nvar CLASSES_CACHE_KEY = '$$classes';\n/**\n * @param {?} element\n * @param {?} className\n * @return {?}\n */\nfunction containsClass(element, className) {\n    if (element.classList) {\n        return element.classList.contains(className);\n    }\n    else {\n        /** @type {?} */\n        var classes = element[CLASSES_CACHE_KEY];\n        return classes && classes[className];\n    }\n}\n/**\n * @param {?} element\n * @param {?} className\n * @return {?}\n */\nfunction addClass(element, className) {\n    if (element.classList) {\n        element.classList.add(className);\n    }\n    else {\n        /** @type {?} */\n        var classes = element[CLASSES_CACHE_KEY];\n        if (!classes) {\n            classes = element[CLASSES_CACHE_KEY] = {};\n        }\n        classes[className] = true;\n    }\n}\n/**\n * @param {?} element\n * @param {?} className\n * @return {?}\n */\nfunction removeClass(element, className) {\n    if (element.classList) {\n        element.classList.remove(className);\n    }\n    else {\n        /** @type {?} */\n        var classes = element[CLASSES_CACHE_KEY];\n        if (classes) {\n            delete classes[className];\n        }\n    }\n}\n/**\n * @param {?} engine\n * @param {?} element\n * @param {?} players\n * @return {?}\n */\nfunction removeNodesAfterAnimationDone(engine, element, players) {\n    optimizeGroupPlayer(players).onDone(function () { return engine.processLeaveNode(element); });\n}\n/**\n * @param {?} players\n * @return {?}\n */\nfunction flattenGroupPlayers(players) {\n    /** @type {?} */\n    var finalPlayers = [];\n    _flattenGroupPlayersRecur(players, finalPlayers);\n    return finalPlayers;\n}\n/**\n * @param {?} players\n * @param {?} finalPlayers\n * @return {?}\n */\nfunction _flattenGroupPlayersRecur(players, finalPlayers) {\n    for (var i = 0; i < players.length; i++) {\n        /** @type {?} */\n        var player = players[i];\n        if (player instanceof AnimationGroupPlayer) {\n            _flattenGroupPlayersRecur(player.players, finalPlayers);\n        }\n        else {\n            finalPlayers.push(/** @type {?} */ (player));\n        }\n    }\n}\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\nfunction objEquals(a, b) {\n    /** @type {?} */\n    var k1 = Object.keys(a);\n    /** @type {?} */\n    var k2 = Object.keys(b);\n    if (k1.length != k2.length)\n        return false;\n    for (var i = 0; i < k1.length; i++) {\n        /** @type {?} */\n        var prop = k1[i];\n        if (!b.hasOwnProperty(prop) || a[prop] !== b[prop])\n            return false;\n    }\n    return true;\n}\n/**\n * @param {?} element\n * @param {?} allPreStyleElements\n * @param {?} allPostStyleElements\n * @return {?}\n */\nfunction replacePostStylesAsPre(element, allPreStyleElements, allPostStyleElements) {\n    /** @type {?} */\n    var postEntry = allPostStyleElements.get(element);\n    if (!postEntry)\n        return false;\n    /** @type {?} */\n    var preEntry = allPreStyleElements.get(element);\n    if (preEntry) {\n        postEntry.forEach(function (data) { return ((preEntry)).add(data); });\n    }\n    else {\n        allPreStyleElements.set(element, postEntry);\n    }\n    allPostStyleElements.delete(element);\n    return true;\n}\n//# sourceMappingURL=transition_animation_engine.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nimport { buildAnimationAst } from '../dsl/animation_ast_builder';\nimport { buildTrigger } from '../dsl/animation_trigger';\nimport { parseTimelineCommand } from './shared';\nimport { TimelineAnimationEngine } from './timeline_animation_engine';\nimport { TransitionAnimationEngine } from './transition_animation_engine';\nvar AnimationEngine = /** @class */ (function () {\n    function AnimationEngine(bodyNode, _driver, normalizer) {\n        var _this = this;\n        this.bodyNode = bodyNode;\n        this._driver = _driver;\n        this._triggerCache = {};\n        this.onRemovalComplete = function (element, context) { };\n        this._transitionEngine = new TransitionAnimationEngine(bodyNode, _driver, normalizer);\n        this._timelineEngine = new TimelineAnimationEngine(bodyNode, _driver, normalizer);\n        this._transitionEngine.onRemovalComplete = function (element, context) {\n            return _this.onRemovalComplete(element, context);\n        };\n    }\n    /**\n     * @param {?} componentId\n     * @param {?} namespaceId\n     * @param {?} hostElement\n     * @param {?} name\n     * @param {?} metadata\n     * @return {?}\n     */\n    AnimationEngine.prototype.registerTrigger = /**\n     * @param {?} componentId\n     * @param {?} namespaceId\n     * @param {?} hostElement\n     * @param {?} name\n     * @param {?} metadata\n     * @return {?}\n     */\n    function (componentId, namespaceId, hostElement, name, metadata) {\n        /** @type {?} */\n        var cacheKey = componentId + '-' + name;\n        /** @type {?} */\n        var trigger = this._triggerCache[cacheKey];\n        if (!trigger) {\n            /** @type {?} */\n            var errors = [];\n            /** @type {?} */\n            var ast = /** @type {?} */ (buildAnimationAst(this._driver, /** @type {?} */ (metadata), errors));\n            if (errors.length) {\n                throw new Error(\"The animation trigger \\\"\" + name + \"\\\" has failed to build due to the following errors:\\n - \" + errors.join(\"\\n - \"));\n            }\n            trigger = buildTrigger(name, ast);\n            this._triggerCache[cacheKey] = trigger;\n        }\n        this._transitionEngine.registerTrigger(namespaceId, name, trigger);\n    };\n    /**\n     * @param {?} namespaceId\n     * @param {?} hostElement\n     * @return {?}\n     */\n    AnimationEngine.prototype.register = /**\n     * @param {?} namespaceId\n     * @param {?} hostElement\n     * @return {?}\n     */\n    function (namespaceId, hostElement) {\n        this._transitionEngine.register(namespaceId, hostElement);\n    };\n    /**\n     * @param {?} namespaceId\n     * @param {?} context\n     * @return {?}\n     */\n    AnimationEngine.prototype.destroy = /**\n     * @param {?} namespaceId\n     * @param {?} context\n     * @return {?}\n     */\n    function (namespaceId, context) {\n        this._transitionEngine.destroy(namespaceId, context);\n    };\n    /**\n     * @param {?} namespaceId\n     * @param {?} element\n     * @param {?} parent\n     * @param {?} insertBefore\n     * @return {?}\n     */\n    AnimationEngine.prototype.onInsert = /**\n     * @param {?} namespaceId\n     * @param {?} element\n     * @param {?} parent\n     * @param {?} insertBefore\n     * @return {?}\n     */\n    function (namespaceId, element, parent, insertBefore) {\n        this._transitionEngine.insertNode(namespaceId, element, parent, insertBefore);\n    };\n    /**\n     * @param {?} namespaceId\n     * @param {?} element\n     * @param {?} context\n     * @return {?}\n     */\n    AnimationEngine.prototype.onRemove = /**\n     * @param {?} namespaceId\n     * @param {?} element\n     * @param {?} context\n     * @return {?}\n     */\n    function (namespaceId, element, context) {\n        this._transitionEngine.removeNode(namespaceId, element, context);\n    };\n    /**\n     * @param {?} element\n     * @param {?} disable\n     * @return {?}\n     */\n    AnimationEngine.prototype.disableAnimations = /**\n     * @param {?} element\n     * @param {?} disable\n     * @return {?}\n     */\n    function (element, disable) {\n        this._transitionEngine.markElementAsDisabled(element, disable);\n    };\n    /**\n     * @param {?} namespaceId\n     * @param {?} element\n     * @param {?} property\n     * @param {?} value\n     * @return {?}\n     */\n    AnimationEngine.prototype.process = /**\n     * @param {?} namespaceId\n     * @param {?} element\n     * @param {?} property\n     * @param {?} value\n     * @return {?}\n     */\n    function (namespaceId, element, property, value) {\n        if (property.charAt(0) == '@') {\n            var _a = parseTimelineCommand(property), id = _a[0], action = _a[1];\n            /** @type {?} */\n            var args = /** @type {?} */ (value);\n            this._timelineEngine.command(id, element, action, args);\n        }\n        else {\n            this._transitionEngine.trigger(namespaceId, element, property, value);\n        }\n    };\n    /**\n     * @param {?} namespaceId\n     * @param {?} element\n     * @param {?} eventName\n     * @param {?} eventPhase\n     * @param {?} callback\n     * @return {?}\n     */\n    AnimationEngine.prototype.listen = /**\n     * @param {?} namespaceId\n     * @param {?} element\n     * @param {?} eventName\n     * @param {?} eventPhase\n     * @param {?} callback\n     * @return {?}\n     */\n    function (namespaceId, element, eventName, eventPhase, callback) {\n        // @@listen\n        if (eventName.charAt(0) == '@') {\n            var _a = parseTimelineCommand(eventName), id = _a[0], action = _a[1];\n            return this._timelineEngine.listen(id, element, action, callback);\n        }\n        return this._transitionEngine.listen(namespaceId, element, eventName, eventPhase, callback);\n    };\n    /**\n     * @param {?=} microtaskId\n     * @return {?}\n     */\n    AnimationEngine.prototype.flush = /**\n     * @param {?=} microtaskId\n     * @return {?}\n     */\n    function (microtaskId) {\n        if (microtaskId === void 0) { microtaskId = -1; }\n        this._transitionEngine.flush(microtaskId);\n    };\n    Object.defineProperty(AnimationEngine.prototype, \"players\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            return (/** @type {?} */ (this._transitionEngine.players))\n                .concat(/** @type {?} */ (this._timelineEngine.players));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    AnimationEngine.prototype.whenRenderingDone = /**\n     * @return {?}\n     */\n    function () { return this._transitionEngine.whenRenderingDone(); };\n    return AnimationEngine;\n}());\nexport { AnimationEngine };\nif (false) {\n    /** @type {?} */\n    AnimationEngine.prototype._transitionEngine;\n    /** @type {?} */\n    AnimationEngine.prototype._timelineEngine;\n    /** @type {?} */\n    AnimationEngine.prototype._triggerCache;\n    /** @type {?} */\n    AnimationEngine.prototype.onRemovalComplete;\n    /** @type {?} */\n    AnimationEngine.prototype.bodyNode;\n    /** @type {?} */\n    AnimationEngine.prototype._driver;\n}\n//# sourceMappingURL=animation_engine_next.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** *\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n  @type {?} */\nvar ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;\n/** @type {?} */\nvar ANIMATION_PROP = 'animation';\n/** @type {?} */\nvar ANIMATIONEND_EVENT = 'animationend';\n/** @type {?} */\nvar ONE_SECOND = 1000;\nvar ElementAnimationStyleHandler = /** @class */ (function () {\n    function ElementAnimationStyleHandler(_element, _name, _duration, _delay, _easing, _fillMode, _onDoneFn) {\n        var _this = this;\n        this._element = _element;\n        this._name = _name;\n        this._duration = _duration;\n        this._delay = _delay;\n        this._easing = _easing;\n        this._fillMode = _fillMode;\n        this._onDoneFn = _onDoneFn;\n        this._finished = false;\n        this._destroyed = false;\n        this._startTime = 0;\n        this._position = 0;\n        this._eventFn = function (e) { return _this._handleCallback(e); };\n    }\n    /**\n     * @return {?}\n     */\n    ElementAnimationStyleHandler.prototype.apply = /**\n     * @return {?}\n     */\n    function () {\n        applyKeyframeAnimation(this._element, this._duration + \"ms \" + this._easing + \" \" + this._delay + \"ms 1 normal \" + this._fillMode + \" \" + this._name);\n        addRemoveAnimationEvent(this._element, this._eventFn, false);\n        this._startTime = Date.now();\n    };\n    /**\n     * @return {?}\n     */\n    ElementAnimationStyleHandler.prototype.pause = /**\n     * @return {?}\n     */\n    function () { playPauseAnimation(this._element, this._name, 'paused'); };\n    /**\n     * @return {?}\n     */\n    ElementAnimationStyleHandler.prototype.resume = /**\n     * @return {?}\n     */\n    function () { playPauseAnimation(this._element, this._name, 'running'); };\n    /**\n     * @param {?} position\n     * @return {?}\n     */\n    ElementAnimationStyleHandler.prototype.setPosition = /**\n     * @param {?} position\n     * @return {?}\n     */\n    function (position) {\n        /** @type {?} */\n        var index = findIndexForAnimation(this._element, this._name);\n        this._position = position * this._duration;\n        setAnimationStyle(this._element, 'Delay', \"-\" + this._position + \"ms\", index);\n    };\n    /**\n     * @return {?}\n     */\n    ElementAnimationStyleHandler.prototype.getPosition = /**\n     * @return {?}\n     */\n    function () { return this._position; };\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    ElementAnimationStyleHandler.prototype._handleCallback = /**\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        /** @type {?} */\n        var timestamp = event._ngTestManualTimestamp || Date.now();\n        /** @type {?} */\n        var elapsedTime = parseFloat(event.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES)) * ONE_SECOND;\n        if (event.animationName == this._name &&\n            Math.max(timestamp - this._startTime, 0) >= this._delay && elapsedTime >= this._duration) {\n            this.finish();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    ElementAnimationStyleHandler.prototype.finish = /**\n     * @return {?}\n     */\n    function () {\n        if (this._finished)\n            return;\n        this._finished = true;\n        this._onDoneFn();\n        addRemoveAnimationEvent(this._element, this._eventFn, true);\n    };\n    /**\n     * @return {?}\n     */\n    ElementAnimationStyleHandler.prototype.destroy = /**\n     * @return {?}\n     */\n    function () {\n        if (this._destroyed)\n            return;\n        this._destroyed = true;\n        this.finish();\n        removeKeyframeAnimation(this._element, this._name);\n    };\n    return ElementAnimationStyleHandler;\n}());\nexport { ElementAnimationStyleHandler };\nif (false) {\n    /** @type {?} */\n    ElementAnimationStyleHandler.prototype._eventFn;\n    /** @type {?} */\n    ElementAnimationStyleHandler.prototype._finished;\n    /** @type {?} */\n    ElementAnimationStyleHandler.prototype._destroyed;\n    /** @type {?} */\n    ElementAnimationStyleHandler.prototype._startTime;\n    /** @type {?} */\n    ElementAnimationStyleHandler.prototype._position;\n    /** @type {?} */\n    ElementAnimationStyleHandler.prototype._element;\n    /** @type {?} */\n    ElementAnimationStyleHandler.prototype._name;\n    /** @type {?} */\n    ElementAnimationStyleHandler.prototype._duration;\n    /** @type {?} */\n    ElementAnimationStyleHandler.prototype._delay;\n    /** @type {?} */\n    ElementAnimationStyleHandler.prototype._easing;\n    /** @type {?} */\n    ElementAnimationStyleHandler.prototype._fillMode;\n    /** @type {?} */\n    ElementAnimationStyleHandler.prototype._onDoneFn;\n}\n/**\n * @param {?} element\n * @param {?} name\n * @param {?} status\n * @return {?}\n */\nfunction playPauseAnimation(element, name, status) {\n    /** @type {?} */\n    var index = findIndexForAnimation(element, name);\n    setAnimationStyle(element, 'PlayState', status, index);\n}\n/**\n * @param {?} element\n * @param {?} value\n * @return {?}\n */\nfunction applyKeyframeAnimation(element, value) {\n    /** @type {?} */\n    var anim = getAnimationStyle(element, '').trim();\n    /** @type {?} */\n    var index = 0;\n    if (anim.length) {\n        index = countChars(anim, ',') + 1;\n        value = anim + \", \" + value;\n    }\n    setAnimationStyle(element, '', value);\n    return index;\n}\n/**\n * @param {?} element\n * @param {?} name\n * @return {?}\n */\nfunction removeKeyframeAnimation(element, name) {\n    /** @type {?} */\n    var anim = getAnimationStyle(element, '');\n    /** @type {?} */\n    var tokens = anim.split(',');\n    /** @type {?} */\n    var index = findMatchingTokenIndex(tokens, name);\n    if (index >= 0) {\n        tokens.splice(index, 1);\n        /** @type {?} */\n        var newValue = tokens.join(',');\n        setAnimationStyle(element, '', newValue);\n    }\n}\n/**\n * @param {?} element\n * @param {?} value\n * @return {?}\n */\nfunction findIndexForAnimation(element, value) {\n    /** @type {?} */\n    var anim = getAnimationStyle(element, '');\n    if (anim.indexOf(',') > 0) {\n        /** @type {?} */\n        var tokens = anim.split(',');\n        return findMatchingTokenIndex(tokens, value);\n    }\n    return findMatchingTokenIndex([anim], value);\n}\n/**\n * @param {?} tokens\n * @param {?} searchToken\n * @return {?}\n */\nfunction findMatchingTokenIndex(tokens, searchToken) {\n    for (var i = 0; i < tokens.length; i++) {\n        if (tokens[i].indexOf(searchToken) >= 0) {\n            return i;\n        }\n    }\n    return -1;\n}\n/**\n * @param {?} element\n * @param {?} fn\n * @param {?} doRemove\n * @return {?}\n */\nfunction addRemoveAnimationEvent(element, fn, doRemove) {\n    doRemove ? element.removeEventListener(ANIMATIONEND_EVENT, fn) :\n        element.addEventListener(ANIMATIONEND_EVENT, fn);\n}\n/**\n * @param {?} element\n * @param {?} name\n * @param {?} value\n * @param {?=} index\n * @return {?}\n */\nfunction setAnimationStyle(element, name, value, index) {\n    /** @type {?} */\n    var prop = ANIMATION_PROP + name;\n    if (index != null) {\n        /** @type {?} */\n        var oldValue = element.style[prop];\n        if (oldValue.length) {\n            /** @type {?} */\n            var tokens = oldValue.split(',');\n            tokens[index] = value;\n            value = tokens.join(',');\n        }\n    }\n    element.style[prop] = value;\n}\n/**\n * @param {?} element\n * @param {?} name\n * @return {?}\n */\nfunction getAnimationStyle(element, name) {\n    return element.style[ANIMATION_PROP + name];\n}\n/**\n * @param {?} value\n * @param {?} char\n * @return {?}\n */\nfunction countChars(value, char) {\n    /** @type {?} */\n    var count = 0;\n    for (var i = 0; i < value.length; i++) {\n        /** @type {?} */\n        var c = value.charAt(i);\n        if (c === char)\n            count++;\n    }\n    return count;\n}\n//# sourceMappingURL=element_animation_style_handler.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nimport { computeStyle } from '../../util';\nimport { ElementAnimationStyleHandler } from './element_animation_style_handler';\n/** @type {?} */\nvar DEFAULT_FILL_MODE = 'forwards';\n/** @type {?} */\nvar DEFAULT_EASING = 'linear';\n/** @type {?} */\nvar ANIMATION_END_EVENT = 'animationend';\n/** @enum {number} */\nvar AnimatorControlState = {\n    INITIALIZED: 1, STARTED: 2, FINISHED: 3, DESTROYED: 4,\n};\nexport { AnimatorControlState };\nvar CssKeyframesPlayer = /** @class */ (function () {\n    function CssKeyframesPlayer(element, keyframes, animationName, _duration, _delay, easing, _finalStyles) {\n        this.element = element;\n        this.keyframes = keyframes;\n        this.animationName = animationName;\n        this._duration = _duration;\n        this._delay = _delay;\n        this._finalStyles = _finalStyles;\n        this._onDoneFns = [];\n        this._onStartFns = [];\n        this._onDestroyFns = [];\n        this._started = false;\n        this.currentSnapshot = {};\n        this._state = 0;\n        this.easing = easing || DEFAULT_EASING;\n        this.totalTime = _duration + _delay;\n        this._buildStyler();\n    }\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    CssKeyframesPlayer.prototype.onStart = /**\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) { this._onStartFns.push(fn); };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    CssKeyframesPlayer.prototype.onDone = /**\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) { this._onDoneFns.push(fn); };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    CssKeyframesPlayer.prototype.onDestroy = /**\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) { this._onDestroyFns.push(fn); };\n    /**\n     * @return {?}\n     */\n    CssKeyframesPlayer.prototype.destroy = /**\n     * @return {?}\n     */\n    function () {\n        this.init();\n        if (this._state >= 4 /* DESTROYED */)\n            return;\n        this._state = 4 /* DESTROYED */;\n        this._styler.destroy();\n        this._flushStartFns();\n        this._flushDoneFns();\n        this._onDestroyFns.forEach(function (fn) { return fn(); });\n        this._onDestroyFns = [];\n    };\n    /**\n     * @return {?}\n     */\n    CssKeyframesPlayer.prototype._flushDoneFns = /**\n     * @return {?}\n     */\n    function () {\n        this._onDoneFns.forEach(function (fn) { return fn(); });\n        this._onDoneFns = [];\n    };\n    /**\n     * @return {?}\n     */\n    CssKeyframesPlayer.prototype._flushStartFns = /**\n     * @return {?}\n     */\n    function () {\n        this._onStartFns.forEach(function (fn) { return fn(); });\n        this._onStartFns = [];\n    };\n    /**\n     * @return {?}\n     */\n    CssKeyframesPlayer.prototype.finish = /**\n     * @return {?}\n     */\n    function () {\n        this.init();\n        if (this._state >= 3 /* FINISHED */)\n            return;\n        this._state = 3 /* FINISHED */;\n        this._styler.finish();\n        this._flushStartFns();\n        this._flushDoneFns();\n    };\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    CssKeyframesPlayer.prototype.setPosition = /**\n     * @param {?} value\n     * @return {?}\n     */\n    function (value) { this._styler.setPosition(value); };\n    /**\n     * @return {?}\n     */\n    CssKeyframesPlayer.prototype.getPosition = /**\n     * @return {?}\n     */\n    function () { return this._styler.getPosition(); };\n    /**\n     * @return {?}\n     */\n    CssKeyframesPlayer.prototype.hasStarted = /**\n     * @return {?}\n     */\n    function () { return this._state >= 2 /* STARTED */; };\n    /**\n     * @return {?}\n     */\n    CssKeyframesPlayer.prototype.init = /**\n     * @return {?}\n     */\n    function () {\n        if (this._state >= 1 /* INITIALIZED */)\n            return;\n        this._state = 1 /* INITIALIZED */;\n        /** @type {?} */\n        var elm = this.element;\n        this._styler.apply();\n        if (this._delay) {\n            this._styler.pause();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    CssKeyframesPlayer.prototype.play = /**\n     * @return {?}\n     */\n    function () {\n        this.init();\n        if (!this.hasStarted()) {\n            this._flushStartFns();\n            this._state = 2 /* STARTED */;\n        }\n        this._styler.resume();\n    };\n    /**\n     * @return {?}\n     */\n    CssKeyframesPlayer.prototype.pause = /**\n     * @return {?}\n     */\n    function () {\n        this.init();\n        this._styler.pause();\n    };\n    /**\n     * @return {?}\n     */\n    CssKeyframesPlayer.prototype.restart = /**\n     * @return {?}\n     */\n    function () {\n        this.reset();\n        this.play();\n    };\n    /**\n     * @return {?}\n     */\n    CssKeyframesPlayer.prototype.reset = /**\n     * @return {?}\n     */\n    function () {\n        this._styler.destroy();\n        this._buildStyler();\n        this._styler.apply();\n    };\n    /**\n     * @return {?}\n     */\n    CssKeyframesPlayer.prototype._buildStyler = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._styler = new ElementAnimationStyleHandler(this.element, this.animationName, this._duration, this._delay, this.easing, DEFAULT_FILL_MODE, function () { return _this.finish(); });\n    };\n    /** @internal */\n    /**\n     * \\@internal\n     * @param {?} phaseName\n     * @return {?}\n     */\n    CssKeyframesPlayer.prototype.triggerCallback = /**\n     * \\@internal\n     * @param {?} phaseName\n     * @return {?}\n     */\n    function (phaseName) {\n        /** @type {?} */\n        var methods = phaseName == 'start' ? this._onStartFns : this._onDoneFns;\n        methods.forEach(function (fn) { return fn(); });\n        methods.length = 0;\n    };\n    /**\n     * @return {?}\n     */\n    CssKeyframesPlayer.prototype.beforeDestroy = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this.init();\n        /** @type {?} */\n        var styles = {};\n        if (this.hasStarted()) {\n            /** @type {?} */\n            var finished_1 = this._state >= 3 /* FINISHED */;\n            Object.keys(this._finalStyles).forEach(function (prop) {\n                if (prop != 'offset') {\n                    styles[prop] = finished_1 ? _this._finalStyles[prop] : computeStyle(_this.element, prop);\n                }\n            });\n        }\n        this.currentSnapshot = styles;\n    };\n    return CssKeyframesPlayer;\n}());\nexport { CssKeyframesPlayer };\nif (false) {\n    /** @type {?} */\n    CssKeyframesPlayer.prototype._onDoneFns;\n    /** @type {?} */\n    CssKeyframesPlayer.prototype._onStartFns;\n    /** @type {?} */\n    CssKeyframesPlayer.prototype._onDestroyFns;\n    /** @type {?} */\n    CssKeyframesPlayer.prototype._started;\n    /** @type {?} */\n    CssKeyframesPlayer.prototype._styler;\n    /** @type {?} */\n    CssKeyframesPlayer.prototype.parentPlayer;\n    /** @type {?} */\n    CssKeyframesPlayer.prototype.totalTime;\n    /** @type {?} */\n    CssKeyframesPlayer.prototype.easing;\n    /** @type {?} */\n    CssKeyframesPlayer.prototype.currentSnapshot;\n    /** @type {?} */\n    CssKeyframesPlayer.prototype._state;\n    /** @type {?} */\n    CssKeyframesPlayer.prototype.element;\n    /** @type {?} */\n    CssKeyframesPlayer.prototype.keyframes;\n    /** @type {?} */\n    CssKeyframesPlayer.prototype.animationName;\n    /** @type {?} */\n    CssKeyframesPlayer.prototype._duration;\n    /** @type {?} */\n    CssKeyframesPlayer.prototype._delay;\n    /** @type {?} */\n    CssKeyframesPlayer.prototype._finalStyles;\n}\n//# sourceMappingURL=css_keyframes_player.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nimport * as tslib_1 from \"tslib\";\nimport { NoopAnimationPlayer } from '@angular/animations';\nimport { hypenatePropsObject } from '../shared';\nvar DirectStylePlayer = /** @class */ (function (_super) {\n    tslib_1.__extends(DirectStylePlayer, _super);\n    function DirectStylePlayer(element, styles) {\n        var _this = _super.call(this) || this;\n        _this.element = element;\n        _this._startingStyles = {};\n        _this.__initialized = false;\n        _this._styles = hypenatePropsObject(styles);\n        return _this;\n    }\n    /**\n     * @return {?}\n     */\n    DirectStylePlayer.prototype.init = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (this.__initialized || !this._startingStyles)\n            return;\n        this.__initialized = true;\n        Object.keys(this._styles).forEach(function (prop) {\n            /** @type {?} */ ((_this._startingStyles))[prop] = _this.element.style[prop];\n        });\n        _super.prototype.init.call(this);\n    };\n    /**\n     * @return {?}\n     */\n    DirectStylePlayer.prototype.play = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this._startingStyles)\n            return;\n        this.init();\n        Object.keys(this._styles)\n            .forEach(function (prop) { return _this.element.style.setProperty(prop, _this._styles[prop]); });\n        _super.prototype.play.call(this);\n    };\n    /**\n     * @return {?}\n     */\n    DirectStylePlayer.prototype.destroy = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this._startingStyles)\n            return;\n        Object.keys(this._startingStyles).forEach(function (prop) {\n            /** @type {?} */\n            var value = /** @type {?} */ ((_this._startingStyles))[prop];\n            if (value) {\n                _this.element.style.setProperty(prop, value);\n            }\n            else {\n                _this.element.style.removeProperty(prop);\n            }\n        });\n        this._startingStyles = null;\n        _super.prototype.destroy.call(this);\n    };\n    return DirectStylePlayer;\n}(NoopAnimationPlayer));\nexport { DirectStylePlayer };\nif (false) {\n    /** @type {?} */\n    DirectStylePlayer.prototype._startingStyles;\n    /** @type {?} */\n    DirectStylePlayer.prototype.__initialized;\n    /** @type {?} */\n    DirectStylePlayer.prototype._styles;\n    /** @type {?} */\n    DirectStylePlayer.prototype.element;\n}\n//# sourceMappingURL=direct_style_player.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nimport { allowPreviousPlayerStylesMerge, balancePreviousStylesIntoKeyframes } from '../../util';\nimport { containsElement, hypenatePropsObject, invokeQuery, matchesElement, validateStyleProperty } from '../shared';\nimport { CssKeyframesPlayer } from './css_keyframes_player';\nimport { DirectStylePlayer } from './direct_style_player';\n/** @type {?} */\nvar KEYFRAMES_NAME_PREFIX = 'gen_css_kf_';\n/** @type {?} */\nvar TAB_SPACE = ' ';\nvar CssKeyframesDriver = /** @class */ (function () {\n    function CssKeyframesDriver() {\n        this._count = 0;\n        this._head = document.querySelector('head');\n        this._warningIssued = false;\n    }\n    /**\n     * @param {?} prop\n     * @return {?}\n     */\n    CssKeyframesDriver.prototype.validateStyleProperty = /**\n     * @param {?} prop\n     * @return {?}\n     */\n    function (prop) { return validateStyleProperty(prop); };\n    /**\n     * @param {?} element\n     * @param {?} selector\n     * @return {?}\n     */\n    CssKeyframesDriver.prototype.matchesElement = /**\n     * @param {?} element\n     * @param {?} selector\n     * @return {?}\n     */\n    function (element, selector) {\n        return matchesElement(element, selector);\n    };\n    /**\n     * @param {?} elm1\n     * @param {?} elm2\n     * @return {?}\n     */\n    CssKeyframesDriver.prototype.containsElement = /**\n     * @param {?} elm1\n     * @param {?} elm2\n     * @return {?}\n     */\n    function (elm1, elm2) { return containsElement(elm1, elm2); };\n    /**\n     * @param {?} element\n     * @param {?} selector\n     * @param {?} multi\n     * @return {?}\n     */\n    CssKeyframesDriver.prototype.query = /**\n     * @param {?} element\n     * @param {?} selector\n     * @param {?} multi\n     * @return {?}\n     */\n    function (element, selector, multi) {\n        return invokeQuery(element, selector, multi);\n    };\n    /**\n     * @param {?} element\n     * @param {?} prop\n     * @param {?=} defaultValue\n     * @return {?}\n     */\n    CssKeyframesDriver.prototype.computeStyle = /**\n     * @param {?} element\n     * @param {?} prop\n     * @param {?=} defaultValue\n     * @return {?}\n     */\n    function (element, prop, defaultValue) {\n        return /** @type {?} */ ((/** @type {?} */ (window.getComputedStyle(element)))[prop]);\n    };\n    /**\n     * @param {?} element\n     * @param {?} name\n     * @param {?} keyframes\n     * @return {?}\n     */\n    CssKeyframesDriver.prototype.buildKeyframeElement = /**\n     * @param {?} element\n     * @param {?} name\n     * @param {?} keyframes\n     * @return {?}\n     */\n    function (element, name, keyframes) {\n        keyframes = keyframes.map(function (kf) { return hypenatePropsObject(kf); });\n        /** @type {?} */\n        var keyframeStr = \"@keyframes \" + name + \" {\\n\";\n        /** @type {?} */\n        var tab = '';\n        keyframes.forEach(function (kf) {\n            tab = TAB_SPACE;\n            /** @type {?} */\n            var offset = parseFloat(kf[\"offset\"]);\n            keyframeStr += \"\" + tab + offset * 100 + \"% {\\n\";\n            tab += TAB_SPACE;\n            Object.keys(kf).forEach(function (prop) {\n                /** @type {?} */\n                var value = kf[prop];\n                switch (prop) {\n                    case 'offset':\n                        return;\n                    case 'easing':\n                        if (value) {\n                            keyframeStr += tab + \"animation-timing-function: \" + value + \";\\n\";\n                        }\n                        return;\n                    default:\n                        keyframeStr += \"\" + tab + prop + \": \" + value + \";\\n\";\n                        return;\n                }\n            });\n            keyframeStr += tab + \"}\\n\";\n        });\n        keyframeStr += \"}\\n\";\n        /** @type {?} */\n        var kfElm = document.createElement('style');\n        kfElm.innerHTML = keyframeStr;\n        return kfElm;\n    };\n    /**\n     * @param {?} element\n     * @param {?} keyframes\n     * @param {?} duration\n     * @param {?} delay\n     * @param {?} easing\n     * @param {?=} previousPlayers\n     * @param {?=} scrubberAccessRequested\n     * @return {?}\n     */\n    CssKeyframesDriver.prototype.animate = /**\n     * @param {?} element\n     * @param {?} keyframes\n     * @param {?} duration\n     * @param {?} delay\n     * @param {?} easing\n     * @param {?=} previousPlayers\n     * @param {?=} scrubberAccessRequested\n     * @return {?}\n     */\n    function (element, keyframes, duration, delay, easing, previousPlayers, scrubberAccessRequested) {\n        if (previousPlayers === void 0) { previousPlayers = []; }\n        if (scrubberAccessRequested) {\n            this._notifyFaultyScrubber();\n        }\n        /** @type {?} */\n        var previousCssKeyframePlayers = /** @type {?} */ (previousPlayers.filter(function (player) { return player instanceof CssKeyframesPlayer; }));\n        /** @type {?} */\n        var previousStyles = {};\n        if (allowPreviousPlayerStylesMerge(duration, delay)) {\n            previousCssKeyframePlayers.forEach(function (player) {\n                /** @type {?} */\n                var styles = player.currentSnapshot;\n                Object.keys(styles).forEach(function (prop) { return previousStyles[prop] = styles[prop]; });\n            });\n        }\n        keyframes = balancePreviousStylesIntoKeyframes(element, keyframes, previousStyles);\n        /** @type {?} */\n        var finalStyles = flattenKeyframesIntoStyles(keyframes);\n        // if there is no animation then there is no point in applying\n        // styles and waiting for an event to get fired. This causes lag.\n        // It's better to just directly apply the styles to the element\n        // via the direct styling animation player.\n        if (duration == 0) {\n            return new DirectStylePlayer(element, finalStyles);\n        }\n        /** @type {?} */\n        var animationName = \"\" + KEYFRAMES_NAME_PREFIX + this._count++;\n        /** @type {?} */\n        var kfElm = this.buildKeyframeElement(element, animationName, keyframes); /** @type {?} */\n        ((document.querySelector('head'))).appendChild(kfElm);\n        /** @type {?} */\n        var player = new CssKeyframesPlayer(element, keyframes, animationName, duration, delay, easing, finalStyles);\n        player.onDestroy(function () { return removeElement(kfElm); });\n        return player;\n    };\n    /**\n     * @return {?}\n     */\n    CssKeyframesDriver.prototype._notifyFaultyScrubber = /**\n     * @return {?}\n     */\n    function () {\n        if (!this._warningIssued) {\n            console.warn('@angular/animations: please load the web-animations.js polyfill to allow programmatic access...\\n', '  visit http://bit.ly/IWukam to learn more about using the web-animation-js polyfill.');\n            this._warningIssued = true;\n        }\n    };\n    return CssKeyframesDriver;\n}());\nexport { CssKeyframesDriver };\nif (false) {\n    /** @type {?} */\n    CssKeyframesDriver.prototype._count;\n    /** @type {?} */\n    CssKeyframesDriver.prototype._head;\n    /** @type {?} */\n    CssKeyframesDriver.prototype._warningIssued;\n}\n/**\n * @param {?} keyframes\n * @return {?}\n */\nfunction flattenKeyframesIntoStyles(keyframes) {\n    /** @type {?} */\n    var flatKeyframes = {};\n    if (keyframes) {\n        /** @type {?} */\n        var kfs = Array.isArray(keyframes) ? keyframes : [keyframes];\n        kfs.forEach(function (kf) {\n            Object.keys(kf).forEach(function (prop) {\n                if (prop == 'offset' || prop == 'easing')\n                    return;\n                flatKeyframes[prop] = kf[prop];\n            });\n        });\n    }\n    return flatKeyframes;\n}\n/**\n * @param {?} node\n * @return {?}\n */\nfunction removeElement(node) {\n    node.parentNode.removeChild(node);\n}\n//# sourceMappingURL=css_keyframes_driver.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nimport { computeStyle } from '../../util';\nvar WebAnimationsPlayer = /** @class */ (function () {\n    function WebAnimationsPlayer(element, keyframes, options) {\n        this.element = element;\n        this.keyframes = keyframes;\n        this.options = options;\n        this._onDoneFns = [];\n        this._onStartFns = [];\n        this._onDestroyFns = [];\n        this._initialized = false;\n        this._finished = false;\n        this._started = false;\n        this._destroyed = false;\n        this.time = 0;\n        this.parentPlayer = null;\n        this.currentSnapshot = {};\n        this._duration = /** @type {?} */ (options['duration']);\n        this._delay = /** @type {?} */ (options['delay']) || 0;\n        this.time = this._duration + this._delay;\n    }\n    /**\n     * @return {?}\n     */\n    WebAnimationsPlayer.prototype._onFinish = /**\n     * @return {?}\n     */\n    function () {\n        if (!this._finished) {\n            this._finished = true;\n            this._onDoneFns.forEach(function (fn) { return fn(); });\n            this._onDoneFns = [];\n        }\n    };\n    /**\n     * @return {?}\n     */\n    WebAnimationsPlayer.prototype.init = /**\n     * @return {?}\n     */\n    function () {\n        this._buildPlayer();\n        this._preparePlayerBeforeStart();\n    };\n    /**\n     * @return {?}\n     */\n    WebAnimationsPlayer.prototype._buildPlayer = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (this._initialized)\n            return;\n        this._initialized = true;\n        /** @type {?} */\n        var keyframes = this.keyframes;\n        (/** @type {?} */ (this)).domPlayer =\n            this._triggerWebAnimation(this.element, keyframes, this.options);\n        this._finalKeyframe = keyframes.length ? keyframes[keyframes.length - 1] : {};\n        this.domPlayer.addEventListener('finish', function () { return _this._onFinish(); });\n    };\n    /**\n     * @return {?}\n     */\n    WebAnimationsPlayer.prototype._preparePlayerBeforeStart = /**\n     * @return {?}\n     */\n    function () {\n        // this is required so that the player doesn't start to animate right away\n        if (this._delay) {\n            this._resetDomPlayerState();\n        }\n        else {\n            this.domPlayer.pause();\n        }\n    };\n    /** @internal */\n    /**\n     * \\@internal\n     * @param {?} element\n     * @param {?} keyframes\n     * @param {?} options\n     * @return {?}\n     */\n    WebAnimationsPlayer.prototype._triggerWebAnimation = /**\n     * \\@internal\n     * @param {?} element\n     * @param {?} keyframes\n     * @param {?} options\n     * @return {?}\n     */\n    function (element, keyframes, options) {\n        // jscompiler doesn't seem to know animate is a native property because it's not fully\n        // supported yet across common browsers (we polyfill it for Edge/Safari) [CL #143630929]\n        return /** @type {?} */ (element['animate'](keyframes, options));\n    };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    WebAnimationsPlayer.prototype.onStart = /**\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) { this._onStartFns.push(fn); };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    WebAnimationsPlayer.prototype.onDone = /**\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) { this._onDoneFns.push(fn); };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    WebAnimationsPlayer.prototype.onDestroy = /**\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) { this._onDestroyFns.push(fn); };\n    /**\n     * @return {?}\n     */\n    WebAnimationsPlayer.prototype.play = /**\n     * @return {?}\n     */\n    function () {\n        this._buildPlayer();\n        if (!this.hasStarted()) {\n            this._onStartFns.forEach(function (fn) { return fn(); });\n            this._onStartFns = [];\n            this._started = true;\n        }\n        this.domPlayer.play();\n    };\n    /**\n     * @return {?}\n     */\n    WebAnimationsPlayer.prototype.pause = /**\n     * @return {?}\n     */\n    function () {\n        this.init();\n        this.domPlayer.pause();\n    };\n    /**\n     * @return {?}\n     */\n    WebAnimationsPlayer.prototype.finish = /**\n     * @return {?}\n     */\n    function () {\n        this.init();\n        this._onFinish();\n        this.domPlayer.finish();\n    };\n    /**\n     * @return {?}\n     */\n    WebAnimationsPlayer.prototype.reset = /**\n     * @return {?}\n     */\n    function () {\n        this._resetDomPlayerState();\n        this._destroyed = false;\n        this._finished = false;\n        this._started = false;\n    };\n    /**\n     * @return {?}\n     */\n    WebAnimationsPlayer.prototype._resetDomPlayerState = /**\n     * @return {?}\n     */\n    function () {\n        if (this.domPlayer) {\n            this.domPlayer.cancel();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    WebAnimationsPlayer.prototype.restart = /**\n     * @return {?}\n     */\n    function () {\n        this.reset();\n        this.play();\n    };\n    /**\n     * @return {?}\n     */\n    WebAnimationsPlayer.prototype.hasStarted = /**\n     * @return {?}\n     */\n    function () { return this._started; };\n    /**\n     * @return {?}\n     */\n    WebAnimationsPlayer.prototype.destroy = /**\n     * @return {?}\n     */\n    function () {\n        if (!this._destroyed) {\n            this._destroyed = true;\n            this._resetDomPlayerState();\n            this._onFinish();\n            this._onDestroyFns.forEach(function (fn) { return fn(); });\n            this._onDestroyFns = [];\n        }\n    };\n    /**\n     * @param {?} p\n     * @return {?}\n     */\n    WebAnimationsPlayer.prototype.setPosition = /**\n     * @param {?} p\n     * @return {?}\n     */\n    function (p) { this.domPlayer.currentTime = p * this.time; };\n    /**\n     * @return {?}\n     */\n    WebAnimationsPlayer.prototype.getPosition = /**\n     * @return {?}\n     */\n    function () { return this.domPlayer.currentTime / this.time; };\n    Object.defineProperty(WebAnimationsPlayer.prototype, \"totalTime\", {\n        get: /**\n         * @return {?}\n         */\n        function () { return this._delay + this._duration; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    WebAnimationsPlayer.prototype.beforeDestroy = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        /** @type {?} */\n        var styles = {};\n        if (this.hasStarted()) {\n            Object.keys(this._finalKeyframe).forEach(function (prop) {\n                if (prop != 'offset') {\n                    styles[prop] =\n                        _this._finished ? _this._finalKeyframe[prop] : computeStyle(_this.element, prop);\n                }\n            });\n        }\n        this.currentSnapshot = styles;\n    };\n    /** @internal */\n    /**\n     * \\@internal\n     * @param {?} phaseName\n     * @return {?}\n     */\n    WebAnimationsPlayer.prototype.triggerCallback = /**\n     * \\@internal\n     * @param {?} phaseName\n     * @return {?}\n     */\n    function (phaseName) {\n        /** @type {?} */\n        var methods = phaseName == 'start' ? this._onStartFns : this._onDoneFns;\n        methods.forEach(function (fn) { return fn(); });\n        methods.length = 0;\n    };\n    return WebAnimationsPlayer;\n}());\nexport { WebAnimationsPlayer };\nif (false) {\n    /** @type {?} */\n    WebAnimationsPlayer.prototype._onDoneFns;\n    /** @type {?} */\n    WebAnimationsPlayer.prototype._onStartFns;\n    /** @type {?} */\n    WebAnimationsPlayer.prototype._onDestroyFns;\n    /** @type {?} */\n    WebAnimationsPlayer.prototype._duration;\n    /** @type {?} */\n    WebAnimationsPlayer.prototype._delay;\n    /** @type {?} */\n    WebAnimationsPlayer.prototype._initialized;\n    /** @type {?} */\n    WebAnimationsPlayer.prototype._finished;\n    /** @type {?} */\n    WebAnimationsPlayer.prototype._started;\n    /** @type {?} */\n    WebAnimationsPlayer.prototype._destroyed;\n    /** @type {?} */\n    WebAnimationsPlayer.prototype._finalKeyframe;\n    /** @type {?} */\n    WebAnimationsPlayer.prototype.domPlayer;\n    /** @type {?} */\n    WebAnimationsPlayer.prototype.time;\n    /** @type {?} */\n    WebAnimationsPlayer.prototype.parentPlayer;\n    /** @type {?} */\n    WebAnimationsPlayer.prototype.currentSnapshot;\n    /** @type {?} */\n    WebAnimationsPlayer.prototype.element;\n    /** @type {?} */\n    WebAnimationsPlayer.prototype.keyframes;\n    /** @type {?} */\n    WebAnimationsPlayer.prototype.options;\n}\n//# sourceMappingURL=web_animations_player.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nimport { allowPreviousPlayerStylesMerge, balancePreviousStylesIntoKeyframes, copyStyles } from '../../util';\nimport { CssKeyframesDriver } from '../css_keyframes/css_keyframes_driver';\nimport { containsElement, invokeQuery, isBrowser, matchesElement, validateStyleProperty } from '../shared';\nimport { WebAnimationsPlayer } from './web_animations_player';\nvar WebAnimationsDriver = /** @class */ (function () {\n    function WebAnimationsDriver() {\n        this._isNativeImpl = /\\{\\s*\\[native\\s+code\\]\\s*\\}/.test(getElementAnimateFn().toString());\n        this._cssKeyframesDriver = new CssKeyframesDriver();\n    }\n    /**\n     * @param {?} prop\n     * @return {?}\n     */\n    WebAnimationsDriver.prototype.validateStyleProperty = /**\n     * @param {?} prop\n     * @return {?}\n     */\n    function (prop) { return validateStyleProperty(prop); };\n    /**\n     * @param {?} element\n     * @param {?} selector\n     * @return {?}\n     */\n    WebAnimationsDriver.prototype.matchesElement = /**\n     * @param {?} element\n     * @param {?} selector\n     * @return {?}\n     */\n    function (element, selector) {\n        return matchesElement(element, selector);\n    };\n    /**\n     * @param {?} elm1\n     * @param {?} elm2\n     * @return {?}\n     */\n    WebAnimationsDriver.prototype.containsElement = /**\n     * @param {?} elm1\n     * @param {?} elm2\n     * @return {?}\n     */\n    function (elm1, elm2) { return containsElement(elm1, elm2); };\n    /**\n     * @param {?} element\n     * @param {?} selector\n     * @param {?} multi\n     * @return {?}\n     */\n    WebAnimationsDriver.prototype.query = /**\n     * @param {?} element\n     * @param {?} selector\n     * @param {?} multi\n     * @return {?}\n     */\n    function (element, selector, multi) {\n        return invokeQuery(element, selector, multi);\n    };\n    /**\n     * @param {?} element\n     * @param {?} prop\n     * @param {?=} defaultValue\n     * @return {?}\n     */\n    WebAnimationsDriver.prototype.computeStyle = /**\n     * @param {?} element\n     * @param {?} prop\n     * @param {?=} defaultValue\n     * @return {?}\n     */\n    function (element, prop, defaultValue) {\n        return /** @type {?} */ ((/** @type {?} */ (window.getComputedStyle(element)))[prop]);\n    };\n    /**\n     * @param {?} supported\n     * @return {?}\n     */\n    WebAnimationsDriver.prototype.overrideWebAnimationsSupport = /**\n     * @param {?} supported\n     * @return {?}\n     */\n    function (supported) { this._isNativeImpl = supported; };\n    /**\n     * @param {?} element\n     * @param {?} keyframes\n     * @param {?} duration\n     * @param {?} delay\n     * @param {?} easing\n     * @param {?=} previousPlayers\n     * @param {?=} scrubberAccessRequested\n     * @return {?}\n     */\n    WebAnimationsDriver.prototype.animate = /**\n     * @param {?} element\n     * @param {?} keyframes\n     * @param {?} duration\n     * @param {?} delay\n     * @param {?} easing\n     * @param {?=} previousPlayers\n     * @param {?=} scrubberAccessRequested\n     * @return {?}\n     */\n    function (element, keyframes, duration, delay, easing, previousPlayers, scrubberAccessRequested) {\n        if (previousPlayers === void 0) { previousPlayers = []; }\n        /** @type {?} */\n        var useKeyframes = !scrubberAccessRequested && !this._isNativeImpl;\n        if (useKeyframes) {\n            return this._cssKeyframesDriver.animate(element, keyframes, duration, delay, easing, previousPlayers);\n        }\n        /** @type {?} */\n        var fill = delay == 0 ? 'both' : 'forwards';\n        /** @type {?} */\n        var playerOptions = { duration: duration, delay: delay, fill: fill };\n        // we check for this to avoid having a null|undefined value be present\n        // for the easing (which results in an error for certain browsers #9752)\n        if (easing) {\n            playerOptions['easing'] = easing;\n        }\n        /** @type {?} */\n        var previousStyles = {};\n        /** @type {?} */\n        var previousWebAnimationPlayers = /** @type {?} */ (previousPlayers.filter(function (player) { return player instanceof WebAnimationsPlayer; }));\n        if (allowPreviousPlayerStylesMerge(duration, delay)) {\n            previousWebAnimationPlayers.forEach(function (player) {\n                /** @type {?} */\n                var styles = player.currentSnapshot;\n                Object.keys(styles).forEach(function (prop) { return previousStyles[prop] = styles[prop]; });\n            });\n        }\n        keyframes = keyframes.map(function (styles) { return copyStyles(styles, false); });\n        keyframes = balancePreviousStylesIntoKeyframes(element, keyframes, previousStyles);\n        return new WebAnimationsPlayer(element, keyframes, playerOptions);\n    };\n    return WebAnimationsDriver;\n}());\nexport { WebAnimationsDriver };\nif (false) {\n    /** @type {?} */\n    WebAnimationsDriver.prototype._isNativeImpl;\n    /** @type {?} */\n    WebAnimationsDriver.prototype._cssKeyframesDriver;\n}\n/**\n * @return {?}\n */\nexport function supportsWebAnimations() {\n    return typeof getElementAnimateFn() === 'function';\n}\n/**\n * @return {?}\n */\nfunction getElementAnimateFn() {\n    return (isBrowser() && (/** @type {?} */ (Element)).prototype['animate']) || {};\n}\n//# sourceMappingURL=web_animations_driver.js.map"]}