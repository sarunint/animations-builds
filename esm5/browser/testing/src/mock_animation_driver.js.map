{"version":3,"file":"mock_animation_driver.js","sourceRoot":"","sources":["../../../../../../../packages/animations/browser/testing/src/mock_animation_driver.ts"],"names":[],"mappings":";;;;;AAOA,OAAO,EAAC,UAAU,EAAmB,mBAAmB,EAAa,MAAM,qBAAqB,CAAC;AACjG,OAAO,EAAsC,+BAA+B,IAAI,8BAA8B,EAAE,gBAAgB,IAAI,eAAe,EAAE,YAAY,IAAI,WAAW,EAAE,eAAe,IAAI,cAAc,EAAE,sBAAsB,IAAI,qBAAqB,EAAC,MAAM,6BAA6B,CAAC;;;;;;;;;;;IASvS,mDAAqB;;;;IAArB,UAAsB,IAAY,IAAa,OAAO,qBAAqB,CAAC,IAAI,CAAC,CAAC,EAAE;;;;;;IAEpF,4CAAc;;;;;IAAd,UAAe,OAAY,EAAE,QAAgB;QAC3C,OAAO,cAAc,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;KAC1C;;;;;;IAED,6CAAe;;;;;IAAf,UAAgB,IAAS,EAAE,IAAS,IAAa,OAAO,eAAe,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,EAAE;;;;;;;IAEtF,mCAAK;;;;;;IAAL,UAAM,OAAY,EAAE,QAAgB,EAAE,KAAc;QAClD,OAAO,WAAW,CAAC,OAAO,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAC;KAC9C;;;;;;;IAED,0CAAY;;;;;;IAAZ,UAAa,OAAY,EAAE,IAAY,EAAE,YAAqB;QAC5D,OAAO,YAAY,IAAI,EAAE,CAAC;KAC3B;;;;;;;;;;IAED,qCAAO;;;;;;;;;IAAP,UACI,OAAY,EAAE,SAA6C,EAAE,QAAgB,EAAE,KAAa,EAC5F,MAAc,EAAE,eAA2B;QAA3B,gCAAA,EAAA,oBAA2B;;QAC7C,IAAM,MAAM,GACR,IAAI,mBAAmB,CAAC,OAAO,EAAE,SAAS,EAAE,QAAQ,EAAE,KAAK,EAAE,MAAM,EAAE,eAAe,CAAC,CAAC;QAC1F,mBAAmB,CAAC,GAAG,CAAC,IAAI,mBAAkB,MAAM,EAAC,CAAC;QACtD,OAAO,MAAM,CAAC;KACf;IAzBD,0BAAgC,EAAE,CAAC;8BAfrC;;SAca,mBAAmB;;;;;;;;AAgChC;;;AAAA;IAAyC,+CAAmB;IAO1D,6BACW,SAAqB,SAA6C,EAClE,UAAyB,KAAa,EAAS,MAAc,EAC7D;QAHX,YAIE,kBAAM,QAAQ,EAAE,KAAK,CAAC,SAUvB;QAbU,aAAO,GAAP,OAAO;QAAc,eAAS,GAAT,SAAS,CAAoC;QAClE,cAAQ,GAAR,QAAQ;QAAiB,WAAK,GAAL,KAAK,CAAQ;QAAS,YAAM,GAAN,MAAM,CAAQ;QAC7D,qBAAe,GAAf,eAAe;2BATL,KAAK;0BACN,KAAK;+BACiC,EAAE;2BACxB,EAAE;gCACD,EAAE;QAQrC,IAAI,8BAA8B,CAAC,QAAQ,EAAE,KAAK,CAAC,EAAE;YACnD,eAAe,CAAC,OAAO,CAAC,UAAA,MAAM;gBAC5B,IAAI,MAAM,YAAY,mBAAmB,EAAE;;oBACzC,IAAM,QAAM,GAAG,MAAM,CAAC,eAAe,CAAC;oBACtC,MAAM,CAAC,IAAI,CAAC,QAAM,CAAC,CAAC,OAAO,CAAC,UAAA,IAAI,IAAI,OAAA,KAAI,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG,QAAM,CAAC,IAAI,CAAC,EAAxC,CAAwC,CAAC,CAAC;iBAC/E;aACF,CAAC,CAAC;SACJ;;KACF;IAED,eAAe;;;;;IACf,oCAAM;;;;IAAN,UAAO,EAAa,IAAI,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,EAAE;IAEnD,eAAe;;;;IACf,kCAAI;;;IAAJ;QACE,iBAAM,IAAI,WAAE,CAAC;QACb,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,UAAA,EAAE,IAAI,OAAA,EAAE,EAAE,EAAJ,CAAI,CAAC,CAAC;QACpC,IAAI,CAAC,UAAU,GAAG,EAAE,CAAC;KACtB;;;;IAED,oCAAM;;;IAAN;QACE,iBAAM,MAAM,WAAE,CAAC;QACf,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;KACxB;;;;IAED,qCAAO;;;IAAP;QACE,iBAAM,OAAO,WAAE,CAAC;QAChB,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;KACxB;IAED,eAAe;;;;IACf,8CAAgB;;;IAAhB,eAAqB;;;;IAErB,kCAAI;;;IAAJ;QACE,iBAAM,IAAI,WAAE,CAAC;QACb,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;KACvB;;;;IAED,wCAAU;;;IAAV,cAAe,OAAO,IAAI,CAAC,SAAS,CAAC,EAAE;;;;IAEvC,2CAAa;;;IAAb;QAAA,iBAqBC;;QApBC,IAAM,QAAQ,GAAe,EAAE,CAAC;QAEhC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,OAAO,CAAC,UAAA,IAAI;YAC3C,QAAQ,CAAC,IAAI,CAAC,GAAG,KAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;SAC5C,CAAC,CAAC;QAEH,IAAI,IAAI,CAAC,UAAU,EAAE,EAAE;;;;YAIrB,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,UAAA,EAAE;gBACvB,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,OAAO,CAAC,UAAA,IAAI;oBAC1B,IAAI,IAAI,IAAI,QAAQ,EAAE;wBACpB,QAAQ,CAAC,IAAI,CAAC,GAAG,KAAI,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC;qBAC1D;iBACF,CAAC,CAAC;aACJ,CAAC,CAAC;SACJ;QAED,IAAI,CAAC,eAAe,GAAG,QAAQ,CAAC;KACjC;8BAxHH;EA8CyC,mBAAmB,EA2E3D,CAAA;;;;AA3ED,+BA2EC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AUTO_STYLE, AnimationPlayer, NoopAnimationPlayer, ɵStyleData} from '@angular/animations';\nimport {ɵAnimationDriver as AnimationDriver, ɵallowPreviousPlayerStylesMerge as allowPreviousPlayerStylesMerge, ɵcontainsElement as containsElement, ɵinvokeQuery as invokeQuery, ɵmatchesElement as matchesElement, ɵvalidateStyleProperty as validateStyleProperty} from '@angular/animations/browser';\n\n\n/**\n * @publicApi\n */\nexport class MockAnimationDriver implements AnimationDriver {\n  static log: AnimationPlayer[] = [];\n\n  validateStyleProperty(prop: string): boolean { return validateStyleProperty(prop); }\n\n  matchesElement(element: any, selector: string): boolean {\n    return matchesElement(element, selector);\n  }\n\n  containsElement(elm1: any, elm2: any): boolean { return containsElement(elm1, elm2); }\n\n  query(element: any, selector: string, multi: boolean): any[] {\n    return invokeQuery(element, selector, multi);\n  }\n\n  computeStyle(element: any, prop: string, defaultValue?: string): string {\n    return defaultValue || '';\n  }\n\n  animate(\n      element: any, keyframes: {[key: string]: string | number}[], duration: number, delay: number,\n      easing: string, previousPlayers: any[] = []): MockAnimationPlayer {\n    const player =\n        new MockAnimationPlayer(element, keyframes, duration, delay, easing, previousPlayers);\n    MockAnimationDriver.log.push(<AnimationPlayer>player);\n    return player;\n  }\n}\n\n/**\n * @publicApi\n */\nexport class MockAnimationPlayer extends NoopAnimationPlayer {\n  private __finished = false;\n  private __started = false;\n  public previousStyles: {[key: string]: string | number} = {};\n  private _onInitFns: (() => any)[] = [];\n  public currentSnapshot: ɵStyleData = {};\n\n  constructor(\n      public element: any, public keyframes: {[key: string]: string | number}[],\n      public duration: number, public delay: number, public easing: string,\n      public previousPlayers: any[]) {\n    super(duration, delay);\n\n    if (allowPreviousPlayerStylesMerge(duration, delay)) {\n      previousPlayers.forEach(player => {\n        if (player instanceof MockAnimationPlayer) {\n          const styles = player.currentSnapshot;\n          Object.keys(styles).forEach(prop => this.previousStyles[prop] = styles[prop]);\n        }\n      });\n    }\n  }\n\n  /* @internal */\n  onInit(fn: () => any) { this._onInitFns.push(fn); }\n\n  /* @internal */\n  init() {\n    super.init();\n    this._onInitFns.forEach(fn => fn());\n    this._onInitFns = [];\n  }\n\n  finish(): void {\n    super.finish();\n    this.__finished = true;\n  }\n\n  destroy(): void {\n    super.destroy();\n    this.__finished = true;\n  }\n\n  /* @internal */\n  triggerMicrotask() {}\n\n  play(): void {\n    super.play();\n    this.__started = true;\n  }\n\n  hasStarted() { return this.__started; }\n\n  beforeDestroy() {\n    const captures: ɵStyleData = {};\n\n    Object.keys(this.previousStyles).forEach(prop => {\n      captures[prop] = this.previousStyles[prop];\n    });\n\n    if (this.hasStarted()) {\n      // when assembling the captured styles, it's important that\n      // we build the keyframe styles in the following order:\n      // {other styles within keyframes, ... previousStyles }\n      this.keyframes.forEach(kf => {\n        Object.keys(kf).forEach(prop => {\n          if (prop != 'offset') {\n            captures[prop] = this.__finished ? kf[prop] : AUTO_STYLE;\n          }\n        });\n      });\n    }\n\n    this.currentSnapshot = captures;\n  }\n}\n"]}