{"version":3,"file":"transition_animation_engine.js","sourceRoot":"","sources":["../../../../../../../packages/animations/browser/src/render/transition_animation_engine.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AUTO_STYLE, AnimationOptions, AnimationPlayer, NoopAnimationPlayer, AnimationGroupPlayer as AnimationGroupPlayer, PRE_STYLE as PRE_STYLE, StyleData} from '@angular/animations';\n\nimport {AnimationTimelineInstruction} from '../dsl/animation_timeline_instruction';\nimport {AnimationTransitionFactory} from '../dsl/animation_transition_factory';\nimport {AnimationTransitionInstruction} from '../dsl/animation_transition_instruction';\nimport {AnimationTrigger} from '../dsl/animation_trigger';\nimport {ElementInstructionMap} from '../dsl/element_instruction_map';\nimport {AnimationStyleNormalizer} from '../dsl/style_normalization/animation_style_normalizer';\nimport {ENTER_CLASSNAME, LEAVE_CLASSNAME, NG_ANIMATING_CLASSNAME, NG_ANIMATING_SELECTOR, NG_TRIGGER_CLASSNAME, NG_TRIGGER_SELECTOR, copyObj, eraseStyles, iteratorToArray, setStyles} from '../util';\n\nimport {AnimationDriver} from './animation_driver';\nimport {getOrSetAsInMap, listenOnPlayer, makeAnimationEvent, normalizeKeyframes, optimizeGroupPlayer} from './shared';\n\nconst QUEUED_CLASSNAME = 'ng-animate-queued';\nconst QUEUED_SELECTOR = '.ng-animate-queued';\nconst DISABLED_CLASSNAME = 'ng-animate-disabled';\nconst DISABLED_SELECTOR = '.ng-animate-disabled';\nconst STAR_CLASSNAME = 'ng-star-inserted';\nconst STAR_SELECTOR = '.ng-star-inserted';\n\nconst EMPTY_PLAYER_ARRAY: TransitionAnimationPlayer[] = [];\nconst NULL_REMOVAL_STATE: ElementAnimationState = {\n  namespaceId: '',\n  setForRemoval: false,\n  setForMove: false,\n  hasAnimation: false,\n  removedBeforeQueried: false\n};\nconst NULL_REMOVED_QUERIED_STATE: ElementAnimationState = {\n  namespaceId: '',\n  setForMove: false,\n  setForRemoval: false,\n  hasAnimation: false,\n  removedBeforeQueried: true\n};\n\ninterface TriggerListener {\n  name: string;\n  phase: string;\n  callback: (event: any) => any;\n}\n\nexport interface QueueInstruction {\n  element: any;\n  triggerName: string;\n  fromState: StateValue;\n  toState: StateValue;\n  transition: AnimationTransitionFactory;\n  player: TransitionAnimationPlayer;\n  isFallbackTransition: boolean;\n}\n\nexport const REMOVAL_FLAG = '__ng_removed';\n\nexport interface ElementAnimationState {\n  setForRemoval: boolean;\n  setForMove: boolean;\n  hasAnimation: boolean;\n  namespaceId: string;\n  removedBeforeQueried: boolean;\n}\n\nexport class StateValue {\n  public value: string;\n  public options: AnimationOptions;\n\n  get params(): {[key: string]: any} { return this.options.params as{[key: string]: any}; }\n\n  constructor(input: any, public namespaceId: string = '') {\n    const isObj = input && input.hasOwnProperty('value');\n    const value = isObj ? input['value'] : input;\n    this.value = normalizeTriggerValue(value);\n    if (isObj) {\n      const options = copyObj(input as any);\n      delete options['value'];\n      this.options = options as AnimationOptions;\n    } else {\n      this.options = {};\n    }\n    if (!this.options.params) {\n      this.options.params = {};\n    }\n  }\n\n  absorbOptions(options: AnimationOptions) {\n    const newParams = options.params;\n    if (newParams) {\n      const oldParams = this.options.params !;\n      Object.keys(newParams).forEach(prop => {\n        if (oldParams[prop] == null) {\n          oldParams[prop] = newParams[prop];\n        }\n      });\n    }\n  }\n}\n\nexport const VOID_VALUE = 'void';\nexport const DEFAULT_STATE_VALUE = new StateValue(VOID_VALUE);\n\nexport class AnimationTransitionNamespace {\n  public players: TransitionAnimationPlayer[] = [];\n\n  private _triggers: {[triggerName: string]: AnimationTrigger} = {};\n  private _queue: QueueInstruction[] = [];\n\n  private _elementListeners = new Map<any, TriggerListener[]>();\n\n  private _hostClassName: string;\n\n  constructor(\n      public id: string, public hostElement: any, private _engine: TransitionAnimationEngine) {\n    this._hostClassName = 'ng-tns-' + id;\n    addClass(hostElement, this._hostClassName);\n  }\n\n  listen(element: any, name: string, phase: string, callback: (event: any) => boolean): () => any {\n    if (!this._triggers.hasOwnProperty(name)) {\n      throw new Error(`Unable to listen on the animation trigger event \"${\n          phase}\" because the animation trigger \"${name}\" doesn\\'t exist!`);\n    }\n\n    if (phase == null || phase.length == 0) {\n      throw new Error(`Unable to listen on the animation trigger \"${\n          name}\" because the provided event is undefined!`);\n    }\n\n    if (!isTriggerEventValid(phase)) {\n      throw new Error(`The provided animation trigger event \"${phase}\" for the animation trigger \"${\n          name}\" is not supported!`);\n    }\n\n    const listeners = getOrSetAsInMap(this._elementListeners, element, []);\n    const data = {name, phase, callback};\n    listeners.push(data);\n\n    const triggersWithStates = getOrSetAsInMap(this._engine.statesByElement, element, {});\n    if (!triggersWithStates.hasOwnProperty(name)) {\n      addClass(element, NG_TRIGGER_CLASSNAME);\n      addClass(element, NG_TRIGGER_CLASSNAME + '-' + name);\n      triggersWithStates[name] = DEFAULT_STATE_VALUE;\n    }\n\n    return () => {\n      // the event listener is removed AFTER the flush has occurred such\n      // that leave animations callbacks can fire (otherwise if the node\n      // is removed in between then the listeners would be deregistered)\n      this._engine.afterFlush(() => {\n        const index = listeners.indexOf(data);\n        if (index >= 0) {\n          listeners.splice(index, 1);\n        }\n\n        if (!this._triggers[name]) {\n          delete triggersWithStates[name];\n        }\n      });\n    };\n  }\n\n  register(name: string, ast: AnimationTrigger): boolean {\n    if (this._triggers[name]) {\n      // throw\n      return false;\n    } else {\n      this._triggers[name] = ast;\n      return true;\n    }\n  }\n\n  private _getTrigger(name: string) {\n    const trigger = this._triggers[name];\n    if (!trigger) {\n      throw new Error(`The provided animation trigger \"${name}\" has not been registered!`);\n    }\n    return trigger;\n  }\n\n  trigger(element: any, triggerName: string, value: any, defaultToFallback: boolean = true):\n      TransitionAnimationPlayer|undefined {\n    const trigger = this._getTrigger(triggerName);\n    const player = new TransitionAnimationPlayer(this.id, triggerName, element);\n\n    let triggersWithStates = this._engine.statesByElement.get(element);\n    if (!triggersWithStates) {\n      addClass(element, NG_TRIGGER_CLASSNAME);\n      addClass(element, NG_TRIGGER_CLASSNAME + '-' + triggerName);\n      this._engine.statesByElement.set(element, triggersWithStates = {});\n    }\n\n    let fromState = triggersWithStates[triggerName];\n    const toState = new StateValue(value, this.id);\n\n    const isObj = value && value.hasOwnProperty('value');\n    if (!isObj && fromState) {\n      toState.absorbOptions(fromState.options);\n    }\n\n    triggersWithStates[triggerName] = toState;\n\n    if (!fromState) {\n      fromState = DEFAULT_STATE_VALUE;\n    }\n\n    const isRemoval = toState.value === VOID_VALUE;\n\n    // normally this isn't reached by here, however, if an object expression\n    // is passed in then it may be a new object each time. Comparing the value\n    // is important since that will stay the same despite there being a new object.\n    // The removal arc here is special cased because the same element is triggered\n    // twice in the event that it contains animations on the outer/inner portions\n    // of the host container\n    if (!isRemoval && fromState.value === toState.value) {\n      // this means that despite the value not changing, some inner params\n      // have changed which means that the animation final styles need to be applied\n      if (!objEquals(fromState.params, toState.params)) {\n        const errors: any[] = [];\n        const fromStyles = trigger.matchStyles(fromState.value, fromState.params, errors);\n        const toStyles = trigger.matchStyles(toState.value, toState.params, errors);\n        if (errors.length) {\n          this._engine.reportError(errors);\n        } else {\n          this._engine.afterFlush(() => {\n            eraseStyles(element, fromStyles);\n            setStyles(element, toStyles);\n          });\n        }\n      }\n      return;\n    }\n\n    const playersOnElement: TransitionAnimationPlayer[] =\n        getOrSetAsInMap(this._engine.playersByElement, element, []);\n    playersOnElement.forEach(player => {\n      // only remove the player if it is queued on the EXACT same trigger/namespace\n      // we only also deal with queued players here because if the animation has\n      // started then we want to keep the player alive until the flush happens\n      // (which is where the previousPlayers are passed into the new palyer)\n      if (player.namespaceId == this.id && player.triggerName == triggerName && player.queued) {\n        player.destroy();\n      }\n    });\n\n    let transition =\n        trigger.matchTransition(fromState.value, toState.value, element, toState.params);\n    let isFallbackTransition = false;\n    if (!transition) {\n      if (!defaultToFallback) return;\n      transition = trigger.fallbackTransition;\n      isFallbackTransition = true;\n    }\n\n    this._engine.totalQueuedPlayers++;\n    this._queue.push(\n        {element, triggerName, transition, fromState, toState, player, isFallbackTransition});\n\n    if (!isFallbackTransition) {\n      addClass(element, QUEUED_CLASSNAME);\n      player.onStart(() => { removeClass(element, QUEUED_CLASSNAME); });\n    }\n\n    player.onDone(() => {\n      let index = this.players.indexOf(player);\n      if (index >= 0) {\n        this.players.splice(index, 1);\n      }\n\n      const players = this._engine.playersByElement.get(element);\n      if (players) {\n        let index = players.indexOf(player);\n        if (index >= 0) {\n          players.splice(index, 1);\n        }\n      }\n    });\n\n    this.players.push(player);\n    playersOnElement.push(player);\n\n    return player;\n  }\n\n  deregister(name: string) {\n    delete this._triggers[name];\n\n    this._engine.statesByElement.forEach((stateMap, element) => { delete stateMap[name]; });\n\n    this._elementListeners.forEach((listeners, element) => {\n      this._elementListeners.set(\n          element, listeners.filter(entry => { return entry.name != name; }));\n    });\n  }\n\n  clearElementCache(element: any) {\n    this._engine.statesByElement.delete(element);\n    this._elementListeners.delete(element);\n    const elementPlayers = this._engine.playersByElement.get(element);\n    if (elementPlayers) {\n      elementPlayers.forEach(player => player.destroy());\n      this._engine.playersByElement.delete(element);\n    }\n  }\n\n  private _signalRemovalForInnerTriggers(rootElement: any, context: any, animate: boolean = false) {\n    // emulate a leave animation for all inner nodes within this node.\n    // If there are no animations found for any of the nodes then clear the cache\n    // for the element.\n    this._engine.driver.query(rootElement, NG_TRIGGER_SELECTOR, true).forEach(elm => {\n      // this means that an inner remove() operation has already kicked off\n      // the animation on this element...\n      if (elm[REMOVAL_FLAG]) return;\n\n      const namespaces = this._engine.fetchNamespacesByElement(elm);\n      if (namespaces.size) {\n        namespaces.forEach(ns => ns.triggerLeaveAnimation(elm, context, false, true));\n      } else {\n        this.clearElementCache(elm);\n      }\n    });\n  }\n\n  triggerLeaveAnimation(\n      element: any, context: any, destroyAfterComplete?: boolean,\n      defaultToFallback?: boolean): boolean {\n    const triggerStates = this._engine.statesByElement.get(element);\n    if (triggerStates) {\n      const players: TransitionAnimationPlayer[] = [];\n      Object.keys(triggerStates).forEach(triggerName => {\n        // this check is here in the event that an element is removed\n        // twice (both on the host level and the component level)\n        if (this._triggers[triggerName]) {\n          const player = this.trigger(element, triggerName, VOID_VALUE, defaultToFallback);\n          if (player) {\n            players.push(player);\n          }\n        }\n      });\n\n      if (players.length) {\n        this._engine.markElementAsRemoved(this.id, element, true, context);\n        if (destroyAfterComplete) {\n          optimizeGroupPlayer(players).onDone(() => this._engine.processLeaveNode(element));\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n  prepareLeaveAnimationListeners(element: any) {\n    const listeners = this._elementListeners.get(element);\n    if (listeners) {\n      const visitedTriggers = new Set<string>();\n      listeners.forEach(listener => {\n        const triggerName = listener.name;\n        if (visitedTriggers.has(triggerName)) return;\n        visitedTriggers.add(triggerName);\n\n        const trigger = this._triggers[triggerName];\n        const transition = trigger.fallbackTransition;\n        const elementStates = this._engine.statesByElement.get(element) !;\n        const fromState = elementStates[triggerName] || DEFAULT_STATE_VALUE;\n        const toState = new StateValue(VOID_VALUE);\n        const player = new TransitionAnimationPlayer(this.id, triggerName, element);\n\n        this._engine.totalQueuedPlayers++;\n        this._queue.push({\n          element,\n          triggerName,\n          transition,\n          fromState,\n          toState,\n          player,\n          isFallbackTransition: true\n        });\n      });\n    }\n  }\n\n  removeNode(element: any, context: any): void {\n    const engine = this._engine;\n\n    if (element.childElementCount) {\n      this._signalRemovalForInnerTriggers(element, context, true);\n    }\n\n    // this means that a * => VOID animation was detected and kicked off\n    if (this.triggerLeaveAnimation(element, context, true)) return;\n\n    // find the player that is animating and make sure that the\n    // removal is delayed until that player has completed\n    let containsPotentialParentTransition = false;\n    if (engine.totalAnimations) {\n      const currentPlayers =\n          engine.players.length ? engine.playersByQueriedElement.get(element) : [];\n\n      // when this `if statement` does not continue forward it means that\n      // a previous animation query has selected the current element and\n      // is animating it. In this situation want to continue forwards and\n      // allow the element to be queued up for animation later.\n      if (currentPlayers && currentPlayers.length) {\n        containsPotentialParentTransition = true;\n      } else {\n        let parent = element;\n        while (parent = parent.parentNode) {\n          const triggers = engine.statesByElement.get(parent);\n          if (triggers) {\n            containsPotentialParentTransition = true;\n            break;\n          }\n        }\n      }\n    }\n\n    // at this stage we know that the element will either get removed\n    // during flush or will be picked up by a parent query. Either way\n    // we need to fire the listeners for this element when it DOES get\n    // removed (once the query parent animation is done or after flush)\n    this.prepareLeaveAnimationListeners(element);\n\n    // whether or not a parent has an animation we need to delay the deferral of the leave\n    // operation until we have more information (which we do after flush() has been called)\n    if (containsPotentialParentTransition) {\n      engine.markElementAsRemoved(this.id, element, false, context);\n    } else {\n      // we do this after the flush has occurred such\n      // that the callbacks can be fired\n      engine.afterFlush(() => this.clearElementCache(element));\n      engine.destroyInnerAnimations(element);\n      engine._onRemovalComplete(element, context);\n    }\n  }\n\n  insertNode(element: any, parent: any): void { addClass(element, this._hostClassName); }\n\n  drainQueuedTransitions(microtaskId: number): QueueInstruction[] {\n    const instructions: QueueInstruction[] = [];\n    this._queue.forEach(entry => {\n      const player = entry.player;\n      if (player.destroyed) return;\n\n      const element = entry.element;\n      const listeners = this._elementListeners.get(element);\n      if (listeners) {\n        listeners.forEach((listener: TriggerListener) => {\n          if (listener.name == entry.triggerName) {\n            const baseEvent = makeAnimationEvent(\n                element, entry.triggerName, entry.fromState.value, entry.toState.value);\n            (baseEvent as any)['_data'] = microtaskId;\n            listenOnPlayer(entry.player, listener.phase, baseEvent, listener.callback);\n          }\n        });\n      }\n\n      if (player.markedForDestroy) {\n        this._engine.afterFlush(() => {\n          // now we can destroy the element properly since the event listeners have\n          // been bound to the player\n          player.destroy();\n        });\n      } else {\n        instructions.push(entry);\n      }\n    });\n\n    this._queue = [];\n\n    return instructions.sort((a, b) => {\n      // if depCount == 0 them move to front\n      // otherwise if a contains b then move back\n      const d0 = a.transition.ast.depCount;\n      const d1 = b.transition.ast.depCount;\n      if (d0 == 0 || d1 == 0) {\n        return d0 - d1;\n      }\n      return this._engine.driver.containsElement(a.element, b.element) ? 1 : -1;\n    });\n  }\n\n  destroy(context: any) {\n    this.players.forEach(p => p.destroy());\n    this._signalRemovalForInnerTriggers(this.hostElement, context);\n  }\n\n  elementContainsData(element: any): boolean {\n    let containsData = false;\n    if (this._elementListeners.has(element)) containsData = true;\n    containsData =\n        (this._queue.find(entry => entry.element === element) ? true : false) || containsData;\n    return containsData;\n  }\n}\n\nexport interface QueuedTransition {\n  element: any;\n  instruction: AnimationTransitionInstruction;\n  player: TransitionAnimationPlayer;\n}\n\nexport class TransitionAnimationEngine {\n  public players: TransitionAnimationPlayer[] = [];\n  public newHostElements = new Map<any, AnimationTransitionNamespace>();\n  public playersByElement = new Map<any, TransitionAnimationPlayer[]>();\n  public playersByQueriedElement = new Map<any, TransitionAnimationPlayer[]>();\n  public statesByElement = new Map<any, {[triggerName: string]: StateValue}>();\n  public disabledNodes = new Set<any>();\n\n  public totalAnimations = 0;\n  public totalQueuedPlayers = 0;\n\n  private _namespaceLookup: {[id: string]: AnimationTransitionNamespace} = {};\n  private _namespaceList: AnimationTransitionNamespace[] = [];\n  private _flushFns: (() => any)[] = [];\n  private _whenQuietFns: (() => any)[] = [];\n\n  public namespacesByHostElement = new Map<any, AnimationTransitionNamespace>();\n  public collectedEnterElements: any[] = [];\n  public collectedLeaveElements: any[] = [];\n\n  // this method is designed to be overridden by the code that uses this engine\n  public onRemovalComplete = (element: any, context: any) => {};\n\n  /** @internal */\n  _onRemovalComplete(element: any, context: any) { this.onRemovalComplete(element, context); }\n\n  constructor(\n      public bodyNode: any, public driver: AnimationDriver,\n      private _normalizer: AnimationStyleNormalizer) {}\n\n  get queuedPlayers(): TransitionAnimationPlayer[] {\n    const players: TransitionAnimationPlayer[] = [];\n    this._namespaceList.forEach(ns => {\n      ns.players.forEach(player => {\n        if (player.queued) {\n          players.push(player);\n        }\n      });\n    });\n    return players;\n  }\n\n  createNamespace(namespaceId: string, hostElement: any) {\n    const ns = new AnimationTransitionNamespace(namespaceId, hostElement, this);\n    if (hostElement.parentNode) {\n      this._balanceNamespaceList(ns, hostElement);\n    } else {\n      // defer this later until flush during when the host element has\n      // been inserted so that we know exactly where to place it in\n      // the namespace list\n      this.newHostElements.set(hostElement, ns);\n\n      // given that this host element is apart of the animation code, it\n      // may or may not be inserted by a parent node that is an of an\n      // animation renderer type. If this happens then we can still have\n      // access to this item when we query for :enter nodes. If the parent\n      // is a renderer then the set data-structure will normalize the entry\n      this.collectEnterElement(hostElement);\n    }\n    return this._namespaceLookup[namespaceId] = ns;\n  }\n\n  private _balanceNamespaceList(ns: AnimationTransitionNamespace, hostElement: any) {\n    const limit = this._namespaceList.length - 1;\n    if (limit >= 0) {\n      let found = false;\n      for (let i = limit; i >= 0; i--) {\n        const nextNamespace = this._namespaceList[i];\n        if (this.driver.containsElement(nextNamespace.hostElement, hostElement)) {\n          this._namespaceList.splice(i + 1, 0, ns);\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        this._namespaceList.splice(0, 0, ns);\n      }\n    } else {\n      this._namespaceList.push(ns);\n    }\n\n    this.namespacesByHostElement.set(hostElement, ns);\n    return ns;\n  }\n\n  register(namespaceId: string, hostElement: any) {\n    let ns = this._namespaceLookup[namespaceId];\n    if (!ns) {\n      ns = this.createNamespace(namespaceId, hostElement);\n    }\n    return ns;\n  }\n\n  registerTrigger(namespaceId: string, name: string, trigger: AnimationTrigger) {\n    let ns = this._namespaceLookup[namespaceId];\n    if (ns && ns.register(name, trigger)) {\n      this.totalAnimations++;\n    }\n  }\n\n  destroy(namespaceId: string, context: any) {\n    if (!namespaceId) return;\n\n    const ns = this._fetchNamespace(namespaceId);\n\n    this.afterFlush(() => {\n      this.namespacesByHostElement.delete(ns.hostElement);\n      delete this._namespaceLookup[namespaceId];\n      const index = this._namespaceList.indexOf(ns);\n      if (index >= 0) {\n        this._namespaceList.splice(index, 1);\n      }\n    });\n\n    this.afterFlushAnimationsDone(() => ns.destroy(context));\n  }\n\n  private _fetchNamespace(id: string) { return this._namespaceLookup[id]; }\n\n  fetchNamespacesByElement(element: any): Set<AnimationTransitionNamespace> {\n    // normally there should only be one namespace per element, however\n    // if @triggers are placed on both the component element and then\n    // its host element (within the component code) then there will be\n    // two namespaces returned. We use a set here to simply the dedupe\n    // of namespaces incase there are multiple triggers both the elm and host\n    const namespaces = new Set<AnimationTransitionNamespace>();\n    const elementStates = this.statesByElement.get(element);\n    if (elementStates) {\n      const keys = Object.keys(elementStates);\n      for (let i = 0; i < keys.length; i++) {\n        const nsId = elementStates[keys[i]].namespaceId;\n        if (nsId) {\n          const ns = this._fetchNamespace(nsId);\n          if (ns) {\n            namespaces.add(ns);\n          }\n        }\n      }\n    }\n    return namespaces;\n  }\n\n  trigger(namespaceId: string, element: any, name: string, value: any): boolean {\n    if (isElementNode(element)) {\n      const ns = this._fetchNamespace(namespaceId);\n      if (ns) {\n        ns.trigger(element, name, value);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  insertNode(namespaceId: string, element: any, parent: any, insertBefore: boolean): void {\n    if (!isElementNode(element)) return;\n\n    // special case for when an element is removed and reinserted (move operation)\n    // when this occurs we do not want to use the element for deletion later\n    const details = element[REMOVAL_FLAG] as ElementAnimationState;\n    if (details && details.setForRemoval) {\n      details.setForRemoval = false;\n      details.setForMove = true;\n      const index = this.collectedLeaveElements.indexOf(element);\n      if (index >= 0) {\n        this.collectedLeaveElements.splice(index, 1);\n      }\n    }\n\n    // in the event that the namespaceId is blank then the caller\n    // code does not contain any animation code in it, but it is\n    // just being called so that the node is marked as being inserted\n    if (namespaceId) {\n      const ns = this._fetchNamespace(namespaceId);\n      // This if-statement is a workaround for router issue #21947.\n      // The router sometimes hits a race condition where while a route\n      // is being instantiated a new navigation arrives, triggering leave\n      // animation of DOM that has not been fully initialized, until this\n      // is resolved, we need to handle the scenario when DOM is not in a\n      // consistent state during the animation.\n      if (ns) {\n        ns.insertNode(element, parent);\n      }\n    }\n\n    // only *directives and host elements are inserted before\n    if (insertBefore) {\n      this.collectEnterElement(element);\n    }\n  }\n\n  collectEnterElement(element: any) { this.collectedEnterElements.push(element); }\n\n  markElementAsDisabled(element: any, value: boolean) {\n    if (value) {\n      if (!this.disabledNodes.has(element)) {\n        this.disabledNodes.add(element);\n        addClass(element, DISABLED_CLASSNAME);\n      }\n    } else if (this.disabledNodes.has(element)) {\n      this.disabledNodes.delete(element);\n      removeClass(element, DISABLED_CLASSNAME);\n    }\n  }\n\n  removeNode(namespaceId: string, element: any, context: any): void {\n    if (!isElementNode(element)) {\n      this._onRemovalComplete(element, context);\n      return;\n    }\n\n    const ns = namespaceId ? this._fetchNamespace(namespaceId) : null;\n    if (ns) {\n      ns.removeNode(element, context);\n    } else {\n      this.markElementAsRemoved(namespaceId, element, false, context);\n    }\n  }\n\n  markElementAsRemoved(namespaceId: string, element: any, hasAnimation?: boolean, context?: any) {\n    this.collectedLeaveElements.push(element);\n    element[REMOVAL_FLAG] = {\n      namespaceId,\n      setForRemoval: context, hasAnimation,\n      removedBeforeQueried: false\n    };\n  }\n\n  listen(\n      namespaceId: string, element: any, name: string, phase: string,\n      callback: (event: any) => boolean): () => any {\n    if (isElementNode(element)) {\n      return this._fetchNamespace(namespaceId).listen(element, name, phase, callback);\n    }\n    return () => {};\n  }\n\n  private _buildInstruction(\n      entry: QueueInstruction, subTimelines: ElementInstructionMap, enterClassName: string,\n      leaveClassName: string, skipBuildAst?: boolean) {\n    return entry.transition.build(\n        this.driver, entry.element, entry.fromState.value, entry.toState.value, enterClassName,\n        leaveClassName, entry.fromState.options, entry.toState.options, subTimelines, skipBuildAst);\n  }\n\n  destroyInnerAnimations(containerElement: any) {\n    let elements = this.driver.query(containerElement, NG_TRIGGER_SELECTOR, true);\n    elements.forEach(element => this.destroyActiveAnimationsForElement(element));\n\n    if (this.playersByQueriedElement.size == 0) return;\n\n    elements = this.driver.query(containerElement, NG_ANIMATING_SELECTOR, true);\n    elements.forEach(element => this.finishActiveQueriedAnimationOnElement(element));\n  }\n\n  destroyActiveAnimationsForElement(element: any) {\n    const players = this.playersByElement.get(element);\n    if (players) {\n      players.forEach(player => {\n        // special case for when an element is set for destruction, but hasn't started.\n        // in this situation we want to delay the destruction until the flush occurs\n        // so that any event listeners attached to the player are triggered.\n        if (player.queued) {\n          player.markedForDestroy = true;\n        } else {\n          player.destroy();\n        }\n      });\n    }\n  }\n\n  finishActiveQueriedAnimationOnElement(element: any) {\n    const players = this.playersByQueriedElement.get(element);\n    if (players) {\n      players.forEach(player => player.finish());\n    }\n  }\n\n  whenRenderingDone(): Promise<any> {\n    return new Promise(resolve => {\n      if (this.players.length) {\n        return optimizeGroupPlayer(this.players).onDone(() => resolve());\n      } else {\n        resolve();\n      }\n    });\n  }\n\n  processLeaveNode(element: any) {\n    const details = element[REMOVAL_FLAG] as ElementAnimationState;\n    if (details && details.setForRemoval) {\n      // this will prevent it from removing it twice\n      element[REMOVAL_FLAG] = NULL_REMOVAL_STATE;\n      if (details.namespaceId) {\n        this.destroyInnerAnimations(element);\n        const ns = this._fetchNamespace(details.namespaceId);\n        if (ns) {\n          ns.clearElementCache(element);\n        }\n      }\n      this._onRemovalComplete(element, details.setForRemoval);\n    }\n\n    if (this.driver.matchesElement(element, DISABLED_SELECTOR)) {\n      this.markElementAsDisabled(element, false);\n    }\n\n    this.driver.query(element, DISABLED_SELECTOR, true).forEach(node => {\n      this.markElementAsDisabled(element, false);\n    });\n  }\n\n  flush(microtaskId: number = -1) {\n    let players: AnimationPlayer[] = [];\n    if (this.newHostElements.size) {\n      this.newHostElements.forEach((ns, element) => this._balanceNamespaceList(ns, element));\n      this.newHostElements.clear();\n    }\n\n    if (this.totalAnimations && this.collectedEnterElements.length) {\n      for (let i = 0; i < this.collectedEnterElements.length; i++) {\n        const elm = this.collectedEnterElements[i];\n        addClass(elm, STAR_CLASSNAME);\n      }\n    }\n\n    if (this._namespaceList.length &&\n        (this.totalQueuedPlayers || this.collectedLeaveElements.length)) {\n      const cleanupFns: Function[] = [];\n      try {\n        players = this._flushAnimations(cleanupFns, microtaskId);\n      } finally {\n        for (let i = 0; i < cleanupFns.length; i++) {\n          cleanupFns[i]();\n        }\n      }\n    } else {\n      for (let i = 0; i < this.collectedLeaveElements.length; i++) {\n        const element = this.collectedLeaveElements[i];\n        this.processLeaveNode(element);\n      }\n    }\n\n    this.totalQueuedPlayers = 0;\n    this.collectedEnterElements.length = 0;\n    this.collectedLeaveElements.length = 0;\n    this._flushFns.forEach(fn => fn());\n    this._flushFns = [];\n\n    if (this._whenQuietFns.length) {\n      // we move these over to a variable so that\n      // if any new callbacks are registered in another\n      // flush they do not populate the existing set\n      const quietFns = this._whenQuietFns;\n      this._whenQuietFns = [];\n\n      if (players.length) {\n        optimizeGroupPlayer(players).onDone(() => { quietFns.forEach(fn => fn()); });\n      } else {\n        quietFns.forEach(fn => fn());\n      }\n    }\n  }\n\n  reportError(errors: string[]) {\n    throw new Error(\n        `Unable to process animations due to the following failed trigger transitions\\n ${\n            errors.join('\\n')}`);\n  }\n\n  private _flushAnimations(cleanupFns: Function[], microtaskId: number):\n      TransitionAnimationPlayer[] {\n    const subTimelines = new ElementInstructionMap();\n    const skippedPlayers: TransitionAnimationPlayer[] = [];\n    const skippedPlayersMap = new Map<any, AnimationPlayer[]>();\n    const queuedInstructions: QueuedTransition[] = [];\n    const queriedElements = new Map<any, TransitionAnimationPlayer[]>();\n    const allPreStyleElements = new Map<any, Set<string>>();\n    const allPostStyleElements = new Map<any, Set<string>>();\n\n    const disabledElementsSet = new Set<any>();\n    this.disabledNodes.forEach(node => {\n      disabledElementsSet.add(node);\n      const nodesThatAreDisabled = this.driver.query(node, QUEUED_SELECTOR, true);\n      for (let i = 0; i < nodesThatAreDisabled.length; i++) {\n        disabledElementsSet.add(nodesThatAreDisabled[i]);\n      }\n    });\n\n    const bodyNode = this.bodyNode;\n    const allTriggerElements = Array.from(this.statesByElement.keys());\n    const enterNodeMap = buildRootMap(allTriggerElements, this.collectedEnterElements);\n\n    // this must occur before the instructions are built below such that\n    // the :enter queries match the elements (since the timeline queries\n    // are fired during instruction building).\n    const enterNodeMapIds = new Map<any, string>();\n    let i = 0;\n    enterNodeMap.forEach((nodes, root) => {\n      const className = ENTER_CLASSNAME + i++;\n      enterNodeMapIds.set(root, className);\n      nodes.forEach(node => addClass(node, className));\n    });\n\n    const allLeaveNodes: any[] = [];\n    const mergedLeaveNodes = new Set<any>();\n    const leaveNodesWithoutAnimations = new Set<any>();\n    for (let i = 0; i < this.collectedLeaveElements.length; i++) {\n      const element = this.collectedLeaveElements[i];\n      const details = element[REMOVAL_FLAG] as ElementAnimationState;\n      if (details && details.setForRemoval) {\n        allLeaveNodes.push(element);\n        mergedLeaveNodes.add(element);\n        if (details.hasAnimation) {\n          this.driver.query(element, STAR_SELECTOR, true).forEach(elm => mergedLeaveNodes.add(elm));\n        } else {\n          leaveNodesWithoutAnimations.add(element);\n        }\n      }\n    }\n\n    const leaveNodeMapIds = new Map<any, string>();\n    const leaveNodeMap = buildRootMap(allTriggerElements, Array.from(mergedLeaveNodes));\n    leaveNodeMap.forEach((nodes, root) => {\n      const className = LEAVE_CLASSNAME + i++;\n      leaveNodeMapIds.set(root, className);\n      nodes.forEach(node => addClass(node, className));\n    });\n\n    cleanupFns.push(() => {\n      enterNodeMap.forEach((nodes, root) => {\n        const className = enterNodeMapIds.get(root) !;\n        nodes.forEach(node => removeClass(node, className));\n      });\n\n      leaveNodeMap.forEach((nodes, root) => {\n        const className = leaveNodeMapIds.get(root) !;\n        nodes.forEach(node => removeClass(node, className));\n      });\n\n      allLeaveNodes.forEach(element => { this.processLeaveNode(element); });\n    });\n\n    const allPlayers: TransitionAnimationPlayer[] = [];\n    const erroneousTransitions: AnimationTransitionInstruction[] = [];\n    for (let i = this._namespaceList.length - 1; i >= 0; i--) {\n      const ns = this._namespaceList[i];\n      ns.drainQueuedTransitions(microtaskId).forEach(entry => {\n        const player = entry.player;\n        const element = entry.element;\n        allPlayers.push(player);\n\n        if (this.collectedEnterElements.length) {\n          const details = element[REMOVAL_FLAG] as ElementAnimationState;\n          // move animations are currently not supported...\n          if (details && details.setForMove) {\n            player.destroy();\n            return;\n          }\n        }\n\n        const nodeIsOrphaned = !bodyNode || !this.driver.containsElement(bodyNode, element);\n        const leaveClassName = leaveNodeMapIds.get(element) !;\n        const enterClassName = enterNodeMapIds.get(element) !;\n        const instruction = this._buildInstruction(\n            entry, subTimelines, enterClassName, leaveClassName, nodeIsOrphaned) !;\n        if (instruction.errors && instruction.errors.length) {\n          erroneousTransitions.push(instruction);\n          return;\n        }\n\n        // even though the element may not be apart of the DOM, it may\n        // still be added at a later point (due to the mechanics of content\n        // projection and/or dynamic component insertion) therefore it's\n        // important we still style the element.\n        if (nodeIsOrphaned) {\n          player.onStart(() => eraseStyles(element, instruction.fromStyles));\n          player.onDestroy(() => setStyles(element, instruction.toStyles));\n          skippedPlayers.push(player);\n          return;\n        }\n\n        // if a unmatched transition is queued to go then it SHOULD NOT render\n        // an animation and cancel the previously running animations.\n        if (entry.isFallbackTransition) {\n          player.onStart(() => eraseStyles(element, instruction.fromStyles));\n          player.onDestroy(() => setStyles(element, instruction.toStyles));\n          skippedPlayers.push(player);\n          return;\n        }\n\n        // this means that if a parent animation uses this animation as a sub trigger\n        // then it will instruct the timeline builder to not add a player delay, but\n        // instead stretch the first keyframe gap up until the animation starts. The\n        // reason this is important is to prevent extra initialization styles from being\n        // required by the user in the animation.\n        instruction.timelines.forEach(tl => tl.stretchStartingKeyframe = true);\n\n        subTimelines.append(element, instruction.timelines);\n\n        const tuple = {instruction, player, element};\n\n        queuedInstructions.push(tuple);\n\n        instruction.queriedElements.forEach(\n            element => getOrSetAsInMap(queriedElements, element, []).push(player));\n\n        instruction.preStyleProps.forEach((stringMap, element) => {\n          const props = Object.keys(stringMap);\n          if (props.length) {\n            let setVal: Set<string> = allPreStyleElements.get(element) !;\n            if (!setVal) {\n              allPreStyleElements.set(element, setVal = new Set<string>());\n            }\n            props.forEach(prop => setVal.add(prop));\n          }\n        });\n\n        instruction.postStyleProps.forEach((stringMap, element) => {\n          const props = Object.keys(stringMap);\n          let setVal: Set<string> = allPostStyleElements.get(element) !;\n          if (!setVal) {\n            allPostStyleElements.set(element, setVal = new Set<string>());\n          }\n          props.forEach(prop => setVal.add(prop));\n        });\n      });\n    }\n\n    if (erroneousTransitions.length) {\n      const errors: string[] = [];\n      erroneousTransitions.forEach(instruction => {\n        errors.push(`@${instruction.triggerName} has failed due to:\\n`);\n        instruction.errors !.forEach(error => errors.push(`- ${error}\\n`));\n      });\n\n      allPlayers.forEach(player => player.destroy());\n      this.reportError(errors);\n    }\n\n    const allPreviousPlayersMap = new Map<any, TransitionAnimationPlayer[]>();\n    // this map works to tell which element in the DOM tree is contained by\n    // which animation. Further down below this map will get populated once\n    // the players are built and in doing so it can efficiently figure out\n    // if a sub player is skipped due to a parent player having priority.\n    const animationElementMap = new Map<any, any>();\n    queuedInstructions.forEach(entry => {\n      const element = entry.element;\n      if (subTimelines.has(element)) {\n        animationElementMap.set(element, element);\n        this._beforeAnimationBuild(\n            entry.player.namespaceId, entry.instruction, allPreviousPlayersMap);\n      }\n    });\n\n    skippedPlayers.forEach(player => {\n      const element = player.element;\n      const previousPlayers =\n          this._getPreviousPlayers(element, false, player.namespaceId, player.triggerName, null);\n      previousPlayers.forEach(prevPlayer => {\n        getOrSetAsInMap(allPreviousPlayersMap, element, []).push(prevPlayer);\n        prevPlayer.destroy();\n      });\n    });\n\n    // this is a special case for nodes that will be removed (either by)\n    // having their own leave animations or by being queried in a container\n    // that will be removed once a parent animation is complete. The idea\n    // here is that * styles must be identical to ! styles because of\n    // backwards compatibility (* is also filled in by default in many places).\n    // Otherwise * styles will return an empty value or auto since the element\n    // that is being getComputedStyle'd will not be visible (since * = destination)\n    const replaceNodes = allLeaveNodes.filter(node => {\n      return replacePostStylesAsPre(node, allPreStyleElements, allPostStyleElements);\n    });\n\n    // POST STAGE: fill the * styles\n    const postStylesMap = new Map<any, StyleData>();\n    const allLeaveQueriedNodes = cloakAndComputeStyles(\n        postStylesMap, this.driver, leaveNodesWithoutAnimations, allPostStyleElements, AUTO_STYLE);\n\n    allLeaveQueriedNodes.forEach(node => {\n      if (replacePostStylesAsPre(node, allPreStyleElements, allPostStyleElements)) {\n        replaceNodes.push(node);\n      }\n    });\n\n    // PRE STAGE: fill the ! styles\n    const preStylesMap = new Map<any, StyleData>();\n    enterNodeMap.forEach((nodes, root) => {\n      cloakAndComputeStyles(\n          preStylesMap, this.driver, new Set(nodes), allPreStyleElements, PRE_STYLE);\n    });\n\n    replaceNodes.forEach(node => {\n      const post = postStylesMap.get(node);\n      const pre = preStylesMap.get(node);\n      postStylesMap.set(node, { ...post, ...pre } as any);\n    });\n\n    const rootPlayers: TransitionAnimationPlayer[] = [];\n    const subPlayers: TransitionAnimationPlayer[] = [];\n    const NO_PARENT_ANIMATION_ELEMENT_DETECTED = {};\n    queuedInstructions.forEach(entry => {\n      const {element, player, instruction} = entry;\n      // this means that it was never consumed by a parent animation which\n      // means that it is independent and therefore should be set for animation\n      if (subTimelines.has(element)) {\n        if (disabledElementsSet.has(element)) {\n          player.onDestroy(() => setStyles(element, instruction.toStyles));\n          player.disabled = true;\n          player.overrideTotalTime(instruction.totalTime);\n          skippedPlayers.push(player);\n          return;\n        }\n\n        // this will flow up the DOM and query the map to figure out\n        // if a parent animation has priority over it. In the situation\n        // that a parent is detected then it will cancel the loop. If\n        // nothing is detected, or it takes a few hops to find a parent,\n        // then it will fill in the missing nodes and signal them as having\n        // a detected parent (or a NO_PARENT value via a special constant).\n        let parentWithAnimation: any = NO_PARENT_ANIMATION_ELEMENT_DETECTED;\n        if (animationElementMap.size > 1) {\n          let elm = element;\n          const parentsToAdd: any[] = [];\n          while (elm = elm.parentNode) {\n            const detectedParent = animationElementMap.get(elm);\n            if (detectedParent) {\n              parentWithAnimation = detectedParent;\n              break;\n            }\n            parentsToAdd.push(elm);\n          }\n          parentsToAdd.forEach(parent => animationElementMap.set(parent, parentWithAnimation));\n        }\n\n        const innerPlayer = this._buildAnimation(\n            player.namespaceId, instruction, allPreviousPlayersMap, skippedPlayersMap, preStylesMap,\n            postStylesMap);\n\n        player.setRealPlayer(innerPlayer);\n\n        if (parentWithAnimation === NO_PARENT_ANIMATION_ELEMENT_DETECTED) {\n          rootPlayers.push(player);\n        } else {\n          const parentPlayers = this.playersByElement.get(parentWithAnimation);\n          if (parentPlayers && parentPlayers.length) {\n            player.parentPlayer = optimizeGroupPlayer(parentPlayers);\n          }\n          skippedPlayers.push(player);\n        }\n      } else {\n        eraseStyles(element, instruction.fromStyles);\n        player.onDestroy(() => setStyles(element, instruction.toStyles));\n        // there still might be a ancestor player animating this\n        // element therefore we will still add it as a sub player\n        // even if its animation may be disabled\n        subPlayers.push(player);\n        if (disabledElementsSet.has(element)) {\n          skippedPlayers.push(player);\n        }\n      }\n    });\n\n    // find all of the sub players' corresponding inner animation player\n    subPlayers.forEach(player => {\n      // even if any players are not found for a sub animation then it\n      // will still complete itself after the next tick since it's Noop\n      const playersForElement = skippedPlayersMap.get(player.element);\n      if (playersForElement && playersForElement.length) {\n        const innerPlayer = optimizeGroupPlayer(playersForElement);\n        player.setRealPlayer(innerPlayer);\n      }\n    });\n\n    // the reason why we don't actually play the animation is\n    // because all that a skipped player is designed to do is to\n    // fire the start/done transition callback events\n    skippedPlayers.forEach(player => {\n      if (player.parentPlayer) {\n        player.syncPlayerEvents(player.parentPlayer);\n      } else {\n        player.destroy();\n      }\n    });\n\n    // run through all of the queued removals and see if they\n    // were picked up by a query. If not then perform the removal\n    // operation right away unless a parent animation is ongoing.\n    for (let i = 0; i < allLeaveNodes.length; i++) {\n      const element = allLeaveNodes[i];\n      const details = element[REMOVAL_FLAG] as ElementAnimationState;\n      removeClass(element, LEAVE_CLASSNAME);\n\n      // this means the element has a removal animation that is being\n      // taken care of and therefore the inner elements will hang around\n      // until that animation is over (or the parent queried animation)\n      if (details && details.hasAnimation) continue;\n\n      let players: TransitionAnimationPlayer[] = [];\n\n      // if this element is queried or if it contains queried children\n      // then we want for the element not to be removed from the page\n      // until the queried animations have finished\n      if (queriedElements.size) {\n        let queriedPlayerResults = queriedElements.get(element);\n        if (queriedPlayerResults && queriedPlayerResults.length) {\n          players.push(...queriedPlayerResults);\n        }\n\n        let queriedInnerElements = this.driver.query(element, NG_ANIMATING_SELECTOR, true);\n        for (let j = 0; j < queriedInnerElements.length; j++) {\n          let queriedPlayers = queriedElements.get(queriedInnerElements[j]);\n          if (queriedPlayers && queriedPlayers.length) {\n            players.push(...queriedPlayers);\n          }\n        }\n      }\n\n      const activePlayers = players.filter(p => !p.destroyed);\n      if (activePlayers.length) {\n        removeNodesAfterAnimationDone(this, element, activePlayers);\n      } else {\n        this.processLeaveNode(element);\n      }\n    }\n\n    // this is required so the cleanup method doesn't remove them\n    allLeaveNodes.length = 0;\n\n    rootPlayers.forEach(player => {\n      this.players.push(player);\n      player.onDone(() => {\n        player.destroy();\n\n        const index = this.players.indexOf(player);\n        this.players.splice(index, 1);\n      });\n      player.play();\n    });\n\n    return rootPlayers;\n  }\n\n  elementContainsData(namespaceId: string, element: any) {\n    let containsData = false;\n    const details = element[REMOVAL_FLAG] as ElementAnimationState;\n    if (details && details.setForRemoval) containsData = true;\n    if (this.playersByElement.has(element)) containsData = true;\n    if (this.playersByQueriedElement.has(element)) containsData = true;\n    if (this.statesByElement.has(element)) containsData = true;\n    return this._fetchNamespace(namespaceId).elementContainsData(element) || containsData;\n  }\n\n  afterFlush(callback: () => any) { this._flushFns.push(callback); }\n\n  afterFlushAnimationsDone(callback: () => any) { this._whenQuietFns.push(callback); }\n\n  private _getPreviousPlayers(\n      element: string, isQueriedElement: boolean, namespaceId?: string, triggerName?: string,\n      toStateValue?: any): TransitionAnimationPlayer[] {\n    let players: TransitionAnimationPlayer[] = [];\n    if (isQueriedElement) {\n      const queriedElementPlayers = this.playersByQueriedElement.get(element);\n      if (queriedElementPlayers) {\n        players = queriedElementPlayers;\n      }\n    } else {\n      const elementPlayers = this.playersByElement.get(element);\n      if (elementPlayers) {\n        const isRemovalAnimation = !toStateValue || toStateValue == VOID_VALUE;\n        elementPlayers.forEach(player => {\n          if (player.queued) return;\n          if (!isRemovalAnimation && player.triggerName != triggerName) return;\n          players.push(player);\n        });\n      }\n    }\n    if (namespaceId || triggerName) {\n      players = players.filter(player => {\n        if (namespaceId && namespaceId != player.namespaceId) return false;\n        if (triggerName && triggerName != player.triggerName) return false;\n        return true;\n      });\n    }\n    return players;\n  }\n\n  private _beforeAnimationBuild(\n      namespaceId: string, instruction: AnimationTransitionInstruction,\n      allPreviousPlayersMap: Map<any, TransitionAnimationPlayer[]>) {\n    const triggerName = instruction.triggerName;\n    const rootElement = instruction.element;\n\n    // when a removal animation occurs, ALL previous players are collected\n    // and destroyed (even if they are outside of the current namespace)\n    const targetNameSpaceId: string|undefined =\n        instruction.isRemovalTransition ? undefined : namespaceId;\n    const targetTriggerName: string|undefined =\n        instruction.isRemovalTransition ? undefined : triggerName;\n\n    for (const timelineInstruction of instruction.timelines) {\n      const element = timelineInstruction.element;\n      const isQueriedElement = element !== rootElement;\n      const players = getOrSetAsInMap(allPreviousPlayersMap, element, []);\n      const previousPlayers = this._getPreviousPlayers(\n          element, isQueriedElement, targetNameSpaceId, targetTriggerName, instruction.toState);\n      previousPlayers.forEach(player => {\n        const realPlayer = player.getRealPlayer() as any;\n        if (realPlayer.beforeDestroy) {\n          realPlayer.beforeDestroy();\n        }\n        player.destroy();\n        players.push(player);\n      });\n    }\n\n    // this needs to be done so that the PRE/POST styles can be\n    // computed properly without interfering with the previous animation\n    eraseStyles(rootElement, instruction.fromStyles);\n  }\n\n  private _buildAnimation(\n      namespaceId: string, instruction: AnimationTransitionInstruction,\n      allPreviousPlayersMap: Map<any, TransitionAnimationPlayer[]>,\n      skippedPlayersMap: Map<any, AnimationPlayer[]>, preStylesMap: Map<any, StyleData>,\n      postStylesMap: Map<any, StyleData>): AnimationPlayer {\n    const triggerName = instruction.triggerName;\n    const rootElement = instruction.element;\n\n    // we first run this so that the previous animation player\n    // data can be passed into the successive animation players\n    const allQueriedPlayers: TransitionAnimationPlayer[] = [];\n    const allConsumedElements = new Set<any>();\n    const allSubElements = new Set<any>();\n    const allNewPlayers = instruction.timelines.map(timelineInstruction => {\n      const element = timelineInstruction.element;\n      allConsumedElements.add(element);\n\n      // FIXME (matsko): make sure to-be-removed animations are removed properly\n      const details = element[REMOVAL_FLAG];\n      if (details && details.removedBeforeQueried)\n        return new NoopAnimationPlayer(timelineInstruction.duration, timelineInstruction.delay);\n\n      const isQueriedElement = element !== rootElement;\n      const previousPlayers =\n          flattenGroupPlayers((allPreviousPlayersMap.get(element) || EMPTY_PLAYER_ARRAY)\n                                  .map(p => p.getRealPlayer()))\n              .filter(p => {\n                // the `element` is not apart of the AnimationPlayer definition, but\n                // Mock/WebAnimations\n                // use the element within their implementation. This will be added in Angular5 to\n                // AnimationPlayer\n                const pp = p as any;\n                return pp.element ? pp.element === element : false;\n              });\n\n      const preStyles = preStylesMap.get(element);\n      const postStyles = postStylesMap.get(element);\n      const keyframes = normalizeKeyframes(\n          this.driver, this._normalizer, element, timelineInstruction.keyframes, preStyles,\n          postStyles);\n      const player = this._buildPlayer(timelineInstruction, keyframes, previousPlayers);\n\n      // this means that this particular player belongs to a sub trigger. It is\n      // important that we match this player up with the corresponding (@trigger.listener)\n      if (timelineInstruction.subTimeline && skippedPlayersMap) {\n        allSubElements.add(element);\n      }\n\n      if (isQueriedElement) {\n        const wrappedPlayer = new TransitionAnimationPlayer(namespaceId, triggerName, element);\n        wrappedPlayer.setRealPlayer(player);\n        allQueriedPlayers.push(wrappedPlayer);\n      }\n\n      return player;\n    });\n\n    allQueriedPlayers.forEach(player => {\n      getOrSetAsInMap(this.playersByQueriedElement, player.element, []).push(player);\n      player.onDone(() => deleteOrUnsetInMap(this.playersByQueriedElement, player.element, player));\n    });\n\n    allConsumedElements.forEach(element => addClass(element, NG_ANIMATING_CLASSNAME));\n    const player = optimizeGroupPlayer(allNewPlayers);\n    player.onDestroy(() => {\n      allConsumedElements.forEach(element => removeClass(element, NG_ANIMATING_CLASSNAME));\n      setStyles(rootElement, instruction.toStyles);\n    });\n\n    // this basically makes all of the callbacks for sub element animations\n    // be dependent on the upper players for when they finish\n    allSubElements.forEach(\n        element => { getOrSetAsInMap(skippedPlayersMap, element, []).push(player); });\n\n    return player;\n  }\n\n  private _buildPlayer(\n      instruction: AnimationTimelineInstruction, keyframes: StyleData[],\n      previousPlayers: AnimationPlayer[]): AnimationPlayer {\n    if (keyframes.length > 0) {\n      return this.driver.animate(\n          instruction.element, keyframes, instruction.duration, instruction.delay,\n          instruction.easing, previousPlayers);\n    }\n\n    // special case for when an empty transition|definition is provided\n    // ... there is no point in rendering an empty animation\n    return new NoopAnimationPlayer(instruction.duration, instruction.delay);\n  }\n}\n\nexport class TransitionAnimationPlayer implements AnimationPlayer {\n  private _player: AnimationPlayer = new NoopAnimationPlayer();\n  private _containsRealPlayer = false;\n\n  private _queuedCallbacks: {[name: string]: (() => any)[]} = {};\n  public readonly destroyed = false;\n  // TODO(issue/24571): remove '!'.\n  public parentPlayer !: AnimationPlayer;\n\n  public markedForDestroy: boolean = false;\n  public disabled = false;\n\n  readonly queued: boolean = true;\n  public readonly totalTime: number = 0;\n\n  constructor(public namespaceId: string, public triggerName: string, public element: any) {}\n\n  setRealPlayer(player: AnimationPlayer) {\n    if (this._containsRealPlayer) return;\n\n    this._player = player;\n    Object.keys(this._queuedCallbacks).forEach(phase => {\n      this._queuedCallbacks[phase].forEach(\n          callback => listenOnPlayer(player, phase, undefined, callback));\n    });\n    this._queuedCallbacks = {};\n    this._containsRealPlayer = true;\n    this.overrideTotalTime(player.totalTime);\n    (this as{queued: boolean}).queued = false;\n  }\n\n  getRealPlayer() { return this._player; }\n\n  overrideTotalTime(totalTime: number) { (this as any).totalTime = totalTime; }\n\n  syncPlayerEvents(player: AnimationPlayer) {\n    const p = this._player as any;\n    if (p.triggerCallback) {\n      player.onStart(() => p.triggerCallback !('start'));\n    }\n    player.onDone(() => this.finish());\n    player.onDestroy(() => this.destroy());\n  }\n\n  private _queueEvent(name: string, callback: (event: any) => any): void {\n    getOrSetAsInMap(this._queuedCallbacks, name, []).push(callback);\n  }\n\n  onDone(fn: () => void): void {\n    if (this.queued) {\n      this._queueEvent('done', fn);\n    }\n    this._player.onDone(fn);\n  }\n\n  onStart(fn: () => void): void {\n    if (this.queued) {\n      this._queueEvent('start', fn);\n    }\n    this._player.onStart(fn);\n  }\n\n  onDestroy(fn: () => void): void {\n    if (this.queued) {\n      this._queueEvent('destroy', fn);\n    }\n    this._player.onDestroy(fn);\n  }\n\n  init(): void { this._player.init(); }\n\n  hasStarted(): boolean { return this.queued ? false : this._player.hasStarted(); }\n\n  play(): void { !this.queued && this._player.play(); }\n\n  pause(): void { !this.queued && this._player.pause(); }\n\n  restart(): void { !this.queued && this._player.restart(); }\n\n  finish(): void { this._player.finish(); }\n\n  destroy(): void {\n    (this as{destroyed: boolean}).destroyed = true;\n    this._player.destroy();\n  }\n\n  reset(): void { !this.queued && this._player.reset(); }\n\n  setPosition(p: any): void {\n    if (!this.queued) {\n      this._player.setPosition(p);\n    }\n  }\n\n  getPosition(): number { return this.queued ? 0 : this._player.getPosition(); }\n\n  /** @internal */\n  triggerCallback(phaseName: string): void {\n    const p = this._player as any;\n    if (p.triggerCallback) {\n      p.triggerCallback(phaseName);\n    }\n  }\n}\n\nfunction deleteOrUnsetInMap(map: Map<any, any[]>| {[key: string]: any}, key: any, value: any) {\n  let currentValues: any[]|null|undefined;\n  if (map instanceof Map) {\n    currentValues = map.get(key);\n    if (currentValues) {\n      if (currentValues.length) {\n        const index = currentValues.indexOf(value);\n        currentValues.splice(index, 1);\n      }\n      if (currentValues.length == 0) {\n        map.delete(key);\n      }\n    }\n  } else {\n    currentValues = map[key];\n    if (currentValues) {\n      if (currentValues.length) {\n        const index = currentValues.indexOf(value);\n        currentValues.splice(index, 1);\n      }\n      if (currentValues.length == 0) {\n        delete map[key];\n      }\n    }\n  }\n  return currentValues;\n}\n\nfunction normalizeTriggerValue(value: any): any {\n  // we use `!= null` here because it's the most simple\n  // way to test against a \"falsy\" value without mixing\n  // in empty strings or a zero value. DO NOT OPTIMIZE.\n  return value != null ? value : null;\n}\n\nfunction isElementNode(node: any) {\n  return node && node['nodeType'] === 1;\n}\n\nfunction isTriggerEventValid(eventName: string): boolean {\n  return eventName == 'start' || eventName == 'done';\n}\n\nfunction cloakElement(element: any, value?: string) {\n  const oldValue = element.style.display;\n  element.style.display = value != null ? value : 'none';\n  return oldValue;\n}\n\nfunction cloakAndComputeStyles(\n    valuesMap: Map<any, StyleData>, driver: AnimationDriver, elements: Set<any>,\n    elementPropsMap: Map<any, Set<string>>, defaultStyle: string): any[] {\n  const cloakVals: string[] = [];\n  elements.forEach(element => cloakVals.push(cloakElement(element)));\n\n  const failedElements: any[] = [];\n\n  elementPropsMap.forEach((props: Set<string>, element: any) => {\n    const styles: StyleData = {};\n    props.forEach(prop => {\n      const value = styles[prop] = driver.computeStyle(element, prop, defaultStyle);\n\n      // there is no easy way to detect this because a sub element could be removed\n      // by a parent animation element being detached.\n      if (!value || value.length == 0) {\n        element[REMOVAL_FLAG] = NULL_REMOVED_QUERIED_STATE;\n        failedElements.push(element);\n      }\n    });\n    valuesMap.set(element, styles);\n  });\n\n  // we use a index variable here since Set.forEach(a, i) does not return\n  // an index value for the closure (but instead just the value)\n  let i = 0;\n  elements.forEach(element => cloakElement(element, cloakVals[i++]));\n\n  return failedElements;\n}\n\n/*\nSince the Angular renderer code will return a collection of inserted\nnodes in all areas of a DOM tree, it's up to this algorithm to figure\nout which nodes are roots for each animation @trigger.\n\nBy placing each inserted node into a Set and traversing upwards, it\nis possible to find the @trigger elements and well any direct *star\ninsertion nodes, if a @trigger root is found then the enter element\nis placed into the Map[@trigger] spot.\n */\nfunction buildRootMap(roots: any[], nodes: any[]): Map<any, any[]> {\n  const rootMap = new Map<any, any[]>();\n  roots.forEach(root => rootMap.set(root, []));\n\n  if (nodes.length == 0) return rootMap;\n\n  const NULL_NODE = 1;\n  const nodeSet = new Set(nodes);\n  const localRootMap = new Map<any, any>();\n\n  function getRoot(node: any): any {\n    if (!node) return NULL_NODE;\n\n    let root = localRootMap.get(node);\n    if (root) return root;\n\n    const parent = node.parentNode;\n    if (rootMap.has(parent)) {  // ngIf inside @trigger\n      root = parent;\n    } else if (nodeSet.has(parent)) {  // ngIf inside ngIf\n      root = NULL_NODE;\n    } else {  // recurse upwards\n      root = getRoot(parent);\n    }\n\n    localRootMap.set(node, root);\n    return root;\n  }\n\n  nodes.forEach(node => {\n    const root = getRoot(node);\n    if (root !== NULL_NODE) {\n      rootMap.get(root) !.push(node);\n    }\n  });\n\n  return rootMap;\n}\n\nconst CLASSES_CACHE_KEY = '$$classes';\nfunction containsClass(element: any, className: string): boolean {\n  if (element.classList) {\n    return element.classList.contains(className);\n  } else {\n    const classes = element[CLASSES_CACHE_KEY];\n    return classes && classes[className];\n  }\n}\n\nfunction addClass(element: any, className: string) {\n  if (element.classList) {\n    element.classList.add(className);\n  } else {\n    let classes: {[className: string]: boolean} = element[CLASSES_CACHE_KEY];\n    if (!classes) {\n      classes = element[CLASSES_CACHE_KEY] = {};\n    }\n    classes[className] = true;\n  }\n}\n\nfunction removeClass(element: any, className: string) {\n  if (element.classList) {\n    element.classList.remove(className);\n  } else {\n    let classes: {[className: string]: boolean} = element[CLASSES_CACHE_KEY];\n    if (classes) {\n      delete classes[className];\n    }\n  }\n}\n\nfunction removeNodesAfterAnimationDone(\n    engine: TransitionAnimationEngine, element: any, players: AnimationPlayer[]) {\n  optimizeGroupPlayer(players).onDone(() => engine.processLeaveNode(element));\n}\n\nfunction flattenGroupPlayers(players: AnimationPlayer[]): AnimationPlayer[] {\n  const finalPlayers: AnimationPlayer[] = [];\n  _flattenGroupPlayersRecur(players, finalPlayers);\n  return finalPlayers;\n}\n\nfunction _flattenGroupPlayersRecur(players: AnimationPlayer[], finalPlayers: AnimationPlayer[]) {\n  for (let i = 0; i < players.length; i++) {\n    const player = players[i];\n    if (player instanceof AnimationGroupPlayer) {\n      _flattenGroupPlayersRecur(player.players, finalPlayers);\n    } else {\n      finalPlayers.push(player as AnimationPlayer);\n    }\n  }\n}\n\nfunction objEquals(a: {[key: string]: any}, b: {[key: string]: any}): boolean {\n  const k1 = Object.keys(a);\n  const k2 = Object.keys(b);\n  if (k1.length != k2.length) return false;\n  for (let i = 0; i < k1.length; i++) {\n    const prop = k1[i];\n    if (!b.hasOwnProperty(prop) || a[prop] !== b[prop]) return false;\n  }\n  return true;\n}\n\nfunction replacePostStylesAsPre(\n    element: any, allPreStyleElements: Map<any, Set<string>>,\n    allPostStyleElements: Map<any, Set<string>>): boolean {\n  const postEntry = allPostStyleElements.get(element);\n  if (!postEntry) return false;\n\n  let preEntry = allPreStyleElements.get(element);\n  if (preEntry) {\n    postEntry.forEach(data => preEntry !.add(data));\n  } else {\n    allPreStyleElements.set(element, postEntry);\n  }\n\n  allPostStyleElements.delete(element);\n  return true;\n}\n"]}